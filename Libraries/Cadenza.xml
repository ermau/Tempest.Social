<doc>
    <assembly>
        <name>Cadenza</name>
    </assembly>
    <members>
        <member name="T:Cadenza.ActionCoda">
            <summary>
            Provides extension methods on <see cref="T:System.Action{T}" />,
            <see cref="T:System.Func{T,TResult}" />, and related delegates.
            </summary>
            <remarks>
                <para>
                    <see cref="T:Cadenza.ActionCoda" /> provides methods methods for:
            </para>
                <list type="bullet">
                    <item>
                        <term>
            Delegate currying and partial application (<see cref="M:Cadenza.DelegateCoda.Curry" />)
            </term>
                    </item>
                    <item>
                        <term>
            Delegate composition (<see cref="M:Cadenza.DelegateCoda.Compose" />)
            </term>
                    </item>
                    <item>
                        <term>
            Timing generation (<see cref="M:Cadenza.DelegateCoda.Timings" />)
            </term>
                    </item>
                </list>
                <para>
            Currying via partial application is a way to easily transform
            functions which accept N arguments into functions which accept
            N-1 arguments, by "fixing" arguments with a value.
            </para>
                <code lang="C#">
            // partial application:
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,int,int&gt;     f_3      = function.Curry (3);
            Func&lt;int&gt;             f_321    = function.Curry (3, 2, 1);
            Console.WriteLine (f_3 (2, 1));  // prints (3 + 2 + 1) == "6"
            Console.WriteLine (f_321 ());    // prints (3 + 2 + 1) == "6"</code>
                <para>
            "Traditional" currying converts a delegate that accepts N arguments
            into a delegate which accepts only one argument, but when invoked may
            return a further delegate (etc.) until the final value is returned.
            </para>
                <code lang="C#">
            // traditional currying:
            Func&lt;int, Func&lt;int, Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Func&lt;int, Func&lt;int, int&gt;&gt;            fc_1  = curry (1);
            Func&lt;int, int&gt;                       fc_12 = fc_1 (2);
            Console.WriteLine (fc_12 (3));        // prints (3 + 2 + 1) == "6"
            Console.WriteLine (curry (3)(2)(1));  // prints (3 + 2 + 1) == "6"</code>
                <para>
            Composition is a way to easy chain (or pipe) together multiple delegates
            so that the return value of a "composer" delegate is used as the input
            parameter for the chained delegate:
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
                <para>
            All possible argument and return delegate permutations are provided
            for the <see cref="T:System.Action{T}" /> and related types.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.ActionCoda.Compose``1(System.Action{``0},System.Func{``0})">
            <typeparam name="T">
            The <see cref="T:System.Func{T}" /> return type, and <see cref="T:System.Action{T}" /> argument type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Compose``2(System.Action{``1},System.Func{``0,``1})">
            <typeparam name="T1">To be added.</typeparam>
            <typeparam name="T2">
            The <see cref="T:System.Func{T1,T2}" /> return type, and <see cref="T:System.Action{T2}" /> argument type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T2}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T1}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Compose``3(System.Action{``2},System.Func{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">To be added.</typeparam>
            <typeparam name="T3">
            The <see cref="T:System.Func{T1,T2,T3}" /> return type, and <see cref="T:System.Action{T3}" /> argument type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T3}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1,T2}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T1,T2}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Compose``4(System.Action{``3},System.Func{``0,``1,``2,``3})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">To be added.</typeparam>
            <typeparam name="T4">
            The <see cref="T:System.Func{T1,T2,T3,T4}" /> return type, and <see cref="T:System.Action{T4}" /> argument type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T4}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3,T4}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1,T2,T3}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T1,T2,T3}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Compose``5(System.Action{``4},System.Func{``0,``1,``2,``3,``4})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
            <typeparam name="T4">To be added.</typeparam>
            <typeparam name="T5">
            The <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> return type, and <see cref="T:System.Action{T5}" /> argument type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T5}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1,T2,T3,T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T1,T2,T3,T4}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``1(System.Action{``0})">
            <typeparam name="T">
            The first value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Action{T}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``1(System.Action{``0},Cadenza.Tuple{``0})">
            <typeparam name="T">
            A <see cref="T:System.Action{T}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``1(System.Action{``0},``0)">
            <typeparam name="T">
            A <see cref="T:System.Action{T}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T}" /> to curry.
            </param>
            <param name="value">
            A value of type <typeparamref name="T" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``2(System.Action{``0,``1})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,System.Action{T2}}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T1,System.Action{T2}}" /> which, when invoked, will
            return a <see cref="T:System.Action{T2}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``2(System.Action{``0,``1},Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``2(System.Action{``0,``1},Cadenza.Tuple{``0})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T2}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T2}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``2(System.Action{``0,``1},``0)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T2}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T2}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``2(System.Action{``0,``1},``0,``1)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,System.Action{T3}}}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,System.Action{T3}}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,System.Action{T3}}" /> which, when invoked, will return a <see cref="T:System.Action{T3}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2},Cadenza.Tuple{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2},Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T3}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T3}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2},Cadenza.Tuple{``0})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T2,T3}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T2,T3}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2},``0)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T2,T3}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T2,T3}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2},``0,``1)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T3}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T3}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``3(System.Action{``0,``1,``2},``0,``1,``2)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="T4">
            The fourth value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,System.Action{T4}}}}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,System.Action{T4}}}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,System.Func{T3,System.Action{T4}}}" /> which, when invoked, will return a <see cref="T:System.Func{T3,System.Action{T4}}" /> which, when invoked, will return a <see cref="T:System.Action{T4}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},Cadenza.Tuple{``0,``1,``2,``3})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},Cadenza.Tuple{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T4}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T3,T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T3,T4}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},Cadenza.Tuple{``0})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T2,T3,T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T2,T3,T4}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},``0)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T2,T3,T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T2,T3,T4}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},``0,``1)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T3,T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T3,T4}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},``0,``1,``2)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T4}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action{T4}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Curry``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
            <param name="value4">
            A value of type <typeparamref name="T4" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Action" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings(System.Action,System.Int32)">
            <param name="self">
            The <see cref="T:System.Action" /> to generate timings for.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <see cref="M:Cadenza.ActionCoda.Timings(System.Action,System.Int32,System.Int32)" />
            with a <paramref name="loopsPerRun" /> value of <c>1</c>,
            e.g. as if by calling <c>self.Timing (runs, 1)</c>.
            </para>
            </remarks>
            <altmember cref="M:Cadenza.ActionCoda.Timings(System.Action,System.Int32,System.Int32)" />
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings(System.Action,System.Int32,System.Int32)">
            <param name="self">
            The <see cref="T:System.Action" /> to generate timings for.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <param name="loopsPerRun">
            An <see cref="T:System.Int32" /> containing the number of times to invoke <paramref name="self" /> for each <see cref="T:System.TimeSpan" /> value returned.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Generates <paramref name="runs" /><see cref="T:System.TimeSpan" />
            instances, in which each <c>TimeSpan</c> instance is the amount of time
            required to execute <paramref name="self" /> for
            <paramref name="loopsPerRun" /> times.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="loopsPerRun" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``1(System.Action{``0},``0,System.Int32)">
            <typeparam name="T">
            A <see cref="T:System.Action{T}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T}" /> to generate timings for.
            </param>
            <param name="value">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <see cref="M:Cadenza.ActionCoda.Timings``1(System.Action{``0},``0,System.Int32,System.Int32)" />
            with a <paramref name="loopsPerRun" /> value of <c>1</c>,
            e.g. as if by calling <c>self.Timing (value, runs, 1)</c>.
            </para>
            </remarks>
            <altmember cref="M:Cadenza.ActionCoda.Timings``1(System.Action{``0},``0,System.Int32,System.Int32)" />
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``1(System.Action{``0},``0,System.Int32,System.Int32)">
            <typeparam name="T">
            A <see cref="T:System.Action{T}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T}" /> to generate timings for.
            </param>
            <param name="value">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <param name="loopsPerRun">
            An <see cref="T:System.Int32" /> containing the number of times to invoke <paramref name="self" /> for each <see cref="T:System.TimeSpan" /> value returned.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Generates <paramref name="runs" /><see cref="T:System.TimeSpan" />
            instances, in which each <c>TimeSpan</c> instance is the amount of time
            required to execute <paramref name="self" /> for
            <paramref name="loopsPerRun" /> times.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="loopsPerRun" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``2(System.Action{``0,``1},``0,``1,System.Int32)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to generate timings for.
            </param>
            <param name="value1">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value2">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <see cref="M:Cadenza.ActionCoda.Timings``2(System.Action{``0,``1},``0,``1,System.Int32,System.Int32)" />
            with a <paramref name="loopsPerRun" /> value of <c>1</c>,
            e.g. as if by calling <c>self.Timing (value1, value2, runs, 1)</c>.
            </para>
            </remarks>
            <altmember cref="M:Cadenza.ActionCoda.Timings``2(System.Action{``0,``1},``0,``1,System.Int32,System.Int32)" />
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``2(System.Action{``0,``1},``0,``1,System.Int32,System.Int32)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2}" /> to generate timings for.
            </param>
            <param name="value1">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value2">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <param name="loopsPerRun">
            An <see cref="T:System.Int32" /> containing the number of times to invoke <paramref name="self" /> for each <see cref="T:System.TimeSpan" /> value returned.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Generates <paramref name="runs" /><see cref="T:System.TimeSpan" />
            instances, in which each <c>TimeSpan</c> instance is the amount of time
            required to execute <paramref name="self" /> for
            <paramref name="loopsPerRun" /> times.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="loopsPerRun" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``3(System.Action{``0,``1,``2},``0,``1,``2,System.Int32)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to generate timings for.
            </param>
            <param name="value1">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value2">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value3">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <see cref="M:Cadenza.ActionCoda.Timings``3(System.Action{``0,``1,``2},``0,``1,``2,System.Int32,System.Int32)" />
            with a <paramref name="loopsPerRun" /> value of <c>1</c>,
            e.g. as if by calling <c>self.Timing (value1, value2, value3, runs, 1)</c>.
            </para>
            </remarks>
            <altmember cref="M:Cadenza.ActionCoda.Timings``3(System.Action{``0,``1,``2},``0,``1,``2,System.Int32,System.Int32)" />
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``3(System.Action{``0,``1,``2},``0,``1,``2,System.Int32,System.Int32)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3}" /> to generate timings for.
            </param>
            <param name="value1">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value2">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value3">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <param name="loopsPerRun">
            An <see cref="T:System.Int32" /> containing the number of times to invoke <paramref name="self" /> for each <see cref="T:System.TimeSpan" /> value returned.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Generates <paramref name="runs" /><see cref="T:System.TimeSpan" />
            instances, in which each <c>TimeSpan</c> instance is the amount of time
            required to execute <paramref name="self" /> for
            <paramref name="loopsPerRun" /> times.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="loopsPerRun" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3,System.Int32)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to generate timings for.
            </param>
            <param name="value1">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value2">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value3">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value4">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <see cref="M:Cadenza.ActionCoda.Timings``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3,System.Int32,System.Int32)" />
            with a <paramref name="loopsPerRun" /> value of <c>1</c>,
            e.g. as if by calling <c>self.Timing (value1, value2, value3, value4, runs, 1)</c>.
            </para>
            </remarks>
            <altmember cref="M:Cadenza.ActionCoda.Timings``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3,System.Int32,System.Int32)" />
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.ActionCoda.Timings``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3,System.Int32,System.Int32)">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to generate timings for.
            </param>
            <param name="value1">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value2">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value3">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="value4">
            The *unknown* <paramref name="self" /> parameter value.
            </param>
            <param name="runs">
            An <see cref="T:System.Int32" /> containing the number of <see cref="T:System.TimeSpan" /> values to return.
            </param>
            <param name="loopsPerRun">
            An <see cref="T:System.Int32" /> containing the number of times to invoke <paramref name="self" /> for each <see cref="T:System.TimeSpan" /> value returned.
            </param>
            <summary>
            Get timing information for delegate invocations.
            </summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable{System.TimeSpan}" />
            which will return the timing information for <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Generates <paramref name="runs" /><see cref="T:System.TimeSpan" />
            instances, in which each <c>TimeSpan</c> instance is the amount of time
            required to execute <paramref name="self" /> for
            <paramref name="loopsPerRun" /> times.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <para>
                    <paramref name="runs" /> is negative.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="loopsPerRun" /> is negative.
            </para>
            </exception>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="T:Cadenza.Either">
            <summary>
      Provides static utility methods to create
      <see cref="T:Cadenza.Either{TValue,Exception}" /> instances.
    </summary>
            <remarks>
      Use the <see cref="M:Cadenza.Either.TryParse" /> methods if it is
      necessary to know why the value couldn't be parsed.  Otherwise, use the
      <see cref="M:Cadenza.Maybe.TryParse" /> methods.
    </remarks>
        </member>
        <member name="M:Cadenza.Either.TryConvert``1(System.Object)">
            <typeparam name="TResult">To be added.</typeparam>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Either.TryConvert``1(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Either.TryConvert``2(``0)">
            <typeparam name="TSource">
          The type to convert from.
        </typeparam>
            <typeparam name="TResult">
          The type to convert to.
        </typeparam>
            <param name="value">
          An instance of type <typeparamref name="TSource" /> containing the
          value to convert into a <typeparamref name="TResult" /> instance.
        </param>
            <summary>
          Attempt to convert the value within a <typeparamref name="TSource" />
          into an instance of type <typeparamref name="TResult" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Either{``1,System.Exception}" />
          containing either the parsed value or the error that results from
          attempting to convert <paramref name="value" /> into an instance
          of type <typeparamref name="TResult" />.
        </returns>
            <remarks>
                <para>
                    <c>TryParse</c> attempts to use a variety of mechanisms to convert
            <paramref name="value" /> into a <typeparamref name="TResult" />,
            attempting, in order:
          </para>
                <list type="number">
                    <item>
                        <term>
                            <c>TypeDescriptor.GetConverter(typeof(TResult)).ConvertFrom(value)</c>
                        </term>
                    </item>
                    <item>
                        <term>
                            <c>TypeDescriptor.GetConverter(typeof(TSource)).ConvertTo(value, typeof(TResult))</c>
                        </term>
                    </item>
                    <item>
                        <term>
                            <c>Convert.ChangeType(value, typeof(TResult))</c>
                        </term>
                    </item>
                </list>
                <para>
            If none of these methods are able to convert the value, then the returned
            <see cref="T:Cadenza.Either{TSource,System.Exception}" /> will contain
            a <see cref="T:System.NotSupportedException" />, and
            <see cref="P:System.Exception.InnerException" /> will contain the original
            exception.
          </para>
                <code lang="C#" src="../../Test/Cadenza/EitherTest.cs#TryConvert">Either&lt;DateTime, Exception&gt; a = Either.TryConvert&lt;int, DateTime&gt; (42);
Exception e = a.Fold (i =&gt; null, i =&gt; i);
Assert.IsNotNull (e);
Assert.AreEqual (typeof (InvalidCastException), e.GetType ());

Either&lt;string, Exception&gt; b = Either.TryConvert&lt;int, string&gt; (42);
string n2 = b.Fold (i =&gt; i, i =&gt; null);
Assert.AreEqual ("42", n2);

Either&lt;int, Exception&gt; c = 
	Either.TryConvert&lt;CustomConvertible, int&gt; (new CustomConvertible ());
int n3 = c.Fold (i =&gt; i, i =&gt; -1);
Assert.AreEqual (CustomConvertible.Int32, n3);

Either&lt;ulong, Exception&gt; u = 
	Either.TryConvert&lt;CustomConvertible, ulong&gt; (new CustomConvertible ());
e = u.Fold (i =&gt; null, i =&gt; i);
Assert.IsNotNull (e);
Assert.AreEqual (typeof (NotSupportedException), e.GetType ());
Assert.AreEqual (typeof (BadException), e.InnerException.GetType ());
</code>
            </remarks>
            <altmember cref="M:System.Convert.ChangeType(System.Object,System.Type)" />
            <altmember cref="M:System.ComponentModel.TypeConverter.ConvertFrom(System.Object)" />
            <altmember cref="M:System.ComponentModel.TypeConverter.ConvertTo(System.Object,System.Type)" />
            <altmember cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)" />
        </member>
        <member name="M:Cadenza.Either.TryParse``1(System.String)">
            <typeparam name="T">
          The type to convert <paramref name="value" /> to.
        </typeparam>
            <param name="value">
          A <see cref="T:System.String" /> containing the value to convert
          into a <typeparamref name="T" />.
        </param>
            <summary>
          Attempt to convert the value within a <see cref="T:System.String" />
          into an instance of type <typeparamref name="T" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Either{``0,System.Exception}" />
          containing either the parsed value or the error that results from
          attempting to convert <paramref name="value" /> into an instance
          of type <typeparamref name="T" />.
        </returns>
            <remarks>
                <para>
            This method calls
            <see cref="M:Cadenza.Either.TryConvert``2(``0)" />, with
            <see cref="T:System.String" /> as the 
            <typeparamref name="TSource" /> type.
          </para>
                <code lang="C#" src="../../Test/Cadenza/EitherTest.cs#TryParse">var v = Either.TryParse&lt;int&gt; ("3.14159");
var e = v.Fold (i =&gt; null, i =&gt; i);
Assert.IsNotNull (e);
Assert.IsTrue (typeof(Exception).IsAssignableFrom (e.GetType()));

v = Either.TryParse&lt;int&gt; ("42");
var n = v.Fold (i =&gt; i, i =&gt; -1);
Assert.AreEqual (42, n);

var v2 = Either.TryParse&lt;int?&gt; ("3.14159");
e = v2.Fold (i =&gt; null, i =&gt; i);
Assert.IsNotNull (e);
Assert.IsTrue (typeof(Exception).IsAssignableFrom (e.GetType()));

v2 = Either.TryParse&lt;int?&gt; ("42");
n = v2.Fold (i =&gt; i.Value, i =&gt; -1);
Assert.AreEqual (42, n);
</code>
            </remarks>
        </member>
        <member name="T:Cadenza.Either`2">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <summary>
            A union of 2 values.
            </summary>
            <remarks>
                <para>
            An <c>Either</c> is an immutable, strongly typed union of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position, which is not exposed.  It stores only one (non-null)
            value from a set of types (as determined by the type parameter list).
            </para>
                <para>
            The value held by a <see cref="T:Cadenza.Either{T1, T2}" /> instance
            can be converted into a value by using the
            <see cref="M:Cadenza.Either{T1, T2}.Fold``1(System.Func{`0,``0},System.Func{`1,``0})" /> method.
            <c>Fold</c> takes a list of delegates to perform the conversion; the
            delegate used to perform the conversion is based upon the internal
            position of the value stored.
            </para>
                <para>
                    <c>Either</c> instances are created through one of the following
            creation methods:
            </para>
                <list type="bullet">
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2}.A(`0)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2}.op_Implicit(`0)~Cadenza.Either{`0,`1}" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2}.B(`1)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2}.op_Implicit(`1)~Cadenza.Either{`0,`1}" />
                        </term>
                    </item>
                </list>
                <code lang="C#">
            var a = Either&lt;double, string&gt;.A (Math.PI);   // value stored in 1st position
            int r = a.Fold (
            v =&gt; (int) v,                                 // 1st position converter
            v =&gt; v.Length);                               // 2nd position converter
            Console.WriteLine (r);                        // prints 3</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`2.A(``10T1`1``10`1)">
            <param name="value">
            A <typeparamref name="T1" /> containing the value
            to provide to the first
            <see cref="M:Cadenza.Either{T1,T2}.Fold``1(System.Func{`0,``0},System.Func{`1,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2}" /> instance which
            holds a <typeparamref name="T1" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2}" /> instance which holds a
            holds a <typeparamref name="T1" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2}.Fold``1(System.Func{`0,``0},System.Func{`1,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2}" /> instance
            will invoke the first delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`2.B(``10T2`1``10`1)">
            <param name="value">
            A <typeparamref name="T2" /> containing the value
            to provide to the second
            <see cref="M:Cadenza.Either{T1,T2}.Fold``1(System.Func{`0,``0},System.Func{`1,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2}" /> instance which
            holds a <typeparamref name="T2" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2}" /> instance which holds a
            holds a <typeparamref name="T2" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2}.Fold``1(System.Func{`0,``0},System.Func{`1,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2}" /> instance
            will invoke the second delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`2.Equals(``10Cadenza`1``10`1.``10Either`1``10`1{``10T1`1``10`1,``10T2`1``10`1})">
            <param name="obj">
            A <see cref="T:Cadenza.Either{T1,T2}" />to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified <see cref="T:Cadenza.Either{T1,T2}" /> have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Object.Equals(System.Object)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Object.Equals(System.Object)" />), as defined by each
            value type.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`2.Equals(``10System`1``10`1.``10Object`1``10`1)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Either{T1,T2}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Object.Equals(System.Object)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Object.Equals(System.Object)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`2.Fold``1(``10System`1``10`1.``10Func`1``10`1{``10T1`1``10`1,``10TResult`1``10`1},``10System`1``10`1.``10Func`1``10`1{``10T2`1``10`1,``10TResult`1``10`1})">
            <typeparam name="TResult">
            The type to convert the <see cref="T:Cadenza.Either{T1,T2}" /> to.
            </typeparam>
            <param name="a">
            A <see cref="T:System.Func{T1,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2}" /> stores a
            <typeparamref name="T1" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <param name="b">
            A <see cref="T:System.Func{T2,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2}" /> stores a
            <typeparamref name="T2" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <summary>
            Converts a <see cref="T:Cadenza.Either{T1,T2}" /> into a <typeparamref name="TResult" /> value.
            </summary>
            <returns>
            A <typeparamref name="TResult" /> as generated by one
            of the conversion delegate parameters.
            </returns>
            <remarks>
                <para>
            Converts a <see cref="T:Cadenza.Either{T1,T2}" /> into a <typeparamref name="TResult" />
            by invoking one of the provided delegate parameters.
            </para>
                <para>
            The parameter which is invoked is predicated upon the internal position of
            the value held.  For example, if the internal value is in the first position
            (i.e. <see cref="M:Cadenza.Either{T1,T2}.A(`0)" />
            was used to create the <see cref="T:Cadenza.Either{T1,T2}" /> instance), then
            <paramref name="a" /> (the first delegate parameter) will be invoked to
            convert the <typeparamref name="T1" /> into a
            <typeparamref name="TResult" />.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="a" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="b" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.Either`2.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`2.op_Implicit(``10T1`1``10`1)~``10Cadenza`1``10`1.``10Either`1``10`1{``10T1`1``10`1,``10T2`1``10`1}">
            <param name="value">
           A <typeparamref name="T1" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2}" /> instance which
           holds a <typeparamref name="T1" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2}" /> instance which
           holds a <typeparamref name="T1" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2}.A(`0)" />
        </member>
        <member name="M:Cadenza.Either`2.op_Implicit(``10T2`1``10`1)~``10Cadenza`1``10`1.``10Either`1``10`1{``10T1`1``10`1,``10T2`1``10`1}">
            <param name="value">
           A <typeparamref name="T2" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2}" /> instance which
           holds a <typeparamref name="T2" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2}" /> instance which
           holds a <typeparamref name="T2" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2}.B(`1)" />
        </member>
        <member name="T:Cadenza.Either`3">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <summary>
            A union of 3 values.
            </summary>
            <remarks>
                <para>
            An <c>Either</c> is an immutable, strongly typed union of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position, which is not exposed.  It stores only one (non-null)
            value from a set of types (as determined by the type parameter list).
            </para>
                <para>
            The value held by a <see cref="T:Cadenza.Either{T1, T2, T3}" /> instance
            can be converted into a value by using the
            <see cref="M:Cadenza.Either{T1, T2, T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" /> method.
            <c>Fold</c> takes a list of delegates to perform the conversion; the
            delegate used to perform the conversion is based upon the internal
            position of the value stored.
            </para>
                <para>
                    <c>Either</c> instances are created through one of the following
            creation methods:
            </para>
                <list type="bullet">
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3}.A(`0)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3}.op_Implicit(`0)~Cadenza.Either{`0,`1,`2}" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3}.B(`1)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3}.op_Implicit(`1)~Cadenza.Either{`0,`1,`2}" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3}.C(`2)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3}.op_Implicit(`2)~Cadenza.Either{`0,`1,`2}" />
                        </term>
                    </item>
                </list>
                <code lang="C#">
            var a = Either&lt;double, string&gt;.A (Math.PI);   // value stored in 1st position
            int r = a.Fold (
            v =&gt; (int) v,                                 // 1st position converter
            v =&gt; v.Length);                               // 2nd position converter
            Console.WriteLine (r);                        // prints 3</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`3.A(```210T1`2``21`2```210`2``21`2)">
            <param name="value">
            A <typeparamref name="T1" /> containing the value
            to provide to the first
            <see cref="M:Cadenza.Either{T1,T2,T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
            holds a <typeparamref name="T1" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which holds a
            holds a <typeparamref name="T1" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance
            will invoke the first delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`3.B(```210T2`2``21`2```210`2``21`2)">
            <param name="value">
            A <typeparamref name="T2" /> containing the value
            to provide to the second
            <see cref="M:Cadenza.Either{T1,T2,T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
            holds a <typeparamref name="T2" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which holds a
            holds a <typeparamref name="T2" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance
            will invoke the second delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`3.C(```210T3`2``21`2```210`2``21`2)">
            <param name="value">
            A <typeparamref name="T3" /> containing the value
            to provide to the third
            <see cref="M:Cadenza.Either{T1,T2,T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
            holds a <typeparamref name="T3" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which holds a
            holds a <typeparamref name="T3" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance
            will invoke the third delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`3.Equals(```210Cadenza`2``21`2```210`2``21`2.```210Either`2``21`2```210`2``21`2{```210T1`2``21`2```210`2``21`2,```210T2`2``21`2```210`2``21`2,```210T3`2``21`2```210`2``21`2})">
            <param name="obj">
            A <see cref="T:Cadenza.Either{T1,T2,T3}" />to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified <see cref="T:Cadenza.Either{T1,T2,T3}" /> have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Object.Equals(System.Object)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Object.Equals(System.Object)" />), as defined by each
            value type.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`3.Equals(```210System`2``21`2```210`2``21`2.```210Object`2``21`2```210`2``21`2)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Either{T1,T2,T3}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Object.Equals(System.Object)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Object.Equals(System.Object)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`3.Fold``1(```210System`2``21`2```210`2``21`2.```210Func`2``21`2```210`2``21`2{```210T1`2``21`2```210`2``21`2,```210TResult`2``21`2```210`2``21`2},```210System`2``21`2```210`2``21`2.```210Func`2``21`2```210`2``21`2{```210T2`2``21`2```210`2``21`2,```210TResult`2``21`2```210`2``21`2},```210System`2``21`2```210`2``21`2.```210Func`2``21`2```210`2``21`2{```210T3`2``21`2```210`2``21`2,```210TResult`2``21`2```210`2``21`2})">
            <typeparam name="TResult">
            The type to convert the <see cref="T:Cadenza.Either{T1,T2,T3}" /> to.
            </typeparam>
            <param name="a">
            A <see cref="T:System.Func{T1,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3}" /> stores a
            <typeparamref name="T1" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <param name="b">
            A <see cref="T:System.Func{T2,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3}" /> stores a
            <typeparamref name="T2" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <param name="c">
            A <see cref="T:System.Func{T3,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3}" /> stores a
            <typeparamref name="T3" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <summary>
            Converts a <see cref="T:Cadenza.Either{T1,T2,T3}" /> into a <typeparamref name="TResult" /> value.
            </summary>
            <returns>
            A <typeparamref name="TResult" /> as generated by one
            of the conversion delegate parameters.
            </returns>
            <remarks>
                <para>
            Converts a <see cref="T:Cadenza.Either{T1,T2,T3}" /> into a <typeparamref name="TResult" />
            by invoking one of the provided delegate parameters.
            </para>
                <para>
            The parameter which is invoked is predicated upon the internal position of
            the value held.  For example, if the internal value is in the first position
            (i.e. <see cref="M:Cadenza.Either{T1,T2,T3}.A(`0)" />
            was used to create the <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance), then
            <paramref name="a" /> (the first delegate parameter) will be invoked to
            convert the <typeparamref name="T1" /> into a
            <typeparamref name="TResult" />.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="a" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="b" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="c" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.Either`3.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`3.op_Implicit(```210T1`2``21`2```210`2``21`2)~```210Cadenza`2``21`2```210`2``21`2.```210Either`2``21`2```210`2``21`2{```210T1`2``21`2```210`2``21`2,```210T2`2``21`2```210`2``21`2,```210T3`2``21`2```210`2``21`2}">
            <param name="value">
           A <typeparamref name="T1" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
           holds a <typeparamref name="T1" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
           holds a <typeparamref name="T1" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3}.A(`0)" />
        </member>
        <member name="M:Cadenza.Either`3.op_Implicit(```210T2`2``21`2```210`2``21`2)~```210Cadenza`2``21`2```210`2``21`2.```210Either`2``21`2```210`2``21`2{```210T1`2``21`2```210`2``21`2,```210T2`2``21`2```210`2``21`2,```210T3`2``21`2```210`2``21`2}">
            <param name="value">
           A <typeparamref name="T2" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
           holds a <typeparamref name="T2" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
           holds a <typeparamref name="T2" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3}.B(`1)" />
        </member>
        <member name="M:Cadenza.Either`3.op_Implicit(```210T3`2``21`2```210`2``21`2)~```210Cadenza`2``21`2```210`2``21`2.```210Either`2``21`2```210`2``21`2{```210T1`2``21`2```210`2``21`2,```210T2`2``21`2```210`2``21`2,```210T3`2``21`2```210`2``21`2}">
            <param name="value">
           A <typeparamref name="T3" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
           holds a <typeparamref name="T3" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance which
           holds a <typeparamref name="T3" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3}.C(`2)" />
        </member>
        <member name="T:Cadenza.Either`4">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="T4">
            The fourth value type.
            </typeparam>
            <summary>
            A union of 4 values.
            </summary>
            <remarks>
                <para>
            An <c>Either</c> is an immutable, strongly typed union of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position, which is not exposed.  It stores only one (non-null)
            value from a set of types (as determined by the type parameter list).
            </para>
                <para>
            The value held by a <see cref="T:Cadenza.Either{T1, T2, T3, T4}" /> instance
            can be converted into a value by using the
            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" /> method.
            <c>Fold</c> takes a list of delegates to perform the conversion; the
            delegate used to perform the conversion is based upon the internal
            position of the value stored.
            </para>
                <para>
                    <c>Either</c> instances are created through one of the following
            creation methods:
            </para>
                <list type="bullet">
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.A(`0)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.op_Implicit(`0)~Cadenza.Either{`0,`1,`2,`3}" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.B(`1)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.op_Implicit(`1)~Cadenza.Either{`0,`1,`2,`3}" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.C(`2)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.op_Implicit(`2)~Cadenza.Either{`0,`1,`2,`3}" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.D(`3)" />
                        </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Either{T1, T2, T3, T4}.op_Implicit(`3)~Cadenza.Either{`0,`1,`2,`3}" />
                        </term>
                    </item>
                </list>
                <code lang="C#">
            var a = Either&lt;double, string&gt;.A (Math.PI);   // value stored in 1st position
            int r = a.Fold (
            v =&gt; (int) v,                                 // 1st position converter
            v =&gt; v.Length);                               // 2nd position converter
            Console.WriteLine (r);                        // prints 3</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`4.A(````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="value">
            A <typeparamref name="T1" /> containing the value
            to provide to the first
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
            holds a <typeparamref name="T1" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which holds a
            holds a <typeparamref name="T1" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance
            will invoke the first delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`4.B(````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="value">
            A <typeparamref name="T2" /> containing the value
            to provide to the second
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
            holds a <typeparamref name="T2" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which holds a
            holds a <typeparamref name="T2" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance
            will invoke the second delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`4.C(````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="value">
            A <typeparamref name="T3" /> containing the value
            to provide to the third
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
            holds a <typeparamref name="T3" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which holds a
            holds a <typeparamref name="T3" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance
            will invoke the third delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`4.D(````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="value">
            A <typeparamref name="T4" /> containing the value
            to provide to the fourth
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            delegate.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
            holds a <typeparamref name="T4" /> value.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which holds a
            holds a <typeparamref name="T4" /> value.
            </returns>
            <remarks>
                <para>
            When
            <see cref="M:Cadenza.Either{T1,T2,T3,T4}.Fold``1(System.Func{`0,``0},System.Func{`1,``0},System.Func{`2,``0},System.Func{`3,``0})" />
            is invoked,
            the returned <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance
            will invoke the fourth delegate
            for conversions.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="value" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Either`4.Equals(````3210Cadenza`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Either`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3})">
            <param name="obj">
            A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" />to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Object.Equals(System.Object)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Object.Equals(System.Object)" />), as defined by each
            value type.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`4.Equals(````3210System`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Object`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Object.Equals(System.Object)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Object.Equals(System.Object)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`4.Fold``1(````3210System`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Func`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210TResult`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3},````3210System`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Func`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210TResult`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3},````3210System`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Func`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210TResult`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3},````3210System`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Func`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210TResult`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3})">
            <typeparam name="TResult">
            The type to convert the <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> to.
            </typeparam>
            <param name="a">
            A <see cref="T:System.Func{T1,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> stores a
            <typeparamref name="T1" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <param name="b">
            A <see cref="T:System.Func{T2,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> stores a
            <typeparamref name="T2" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <param name="c">
            A <see cref="T:System.Func{T3,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> stores a
            <typeparamref name="T3" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <param name="d">
            A <see cref="T:System.Func{T4,TResult}" />
            used if the <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> stores a
            <typeparamref name="T4" /> value into a
            <typeparamref name="TResult" /> value.
            </param>
            <summary>
            Converts a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> into a <typeparamref name="TResult" /> value.
            </summary>
            <returns>
            A <typeparamref name="TResult" /> as generated by one
            of the conversion delegate parameters.
            </returns>
            <remarks>
                <para>
            Converts a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> into a <typeparamref name="TResult" />
            by invoking one of the provided delegate parameters.
            </para>
                <para>
            The parameter which is invoked is predicated upon the internal position of
            the value held.  For example, if the internal value is in the first position
            (i.e. <see cref="M:Cadenza.Either{T1,T2,T3,T4}.A(`0)" />
            was used to create the <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance), then
            <paramref name="a" /> (the first delegate parameter) will be invoked to
            convert the <typeparamref name="T1" /> into a
            <typeparamref name="TResult" />.
            </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="a" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="b" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="c" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="d" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.Either`4.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Either`4.op_Implicit(````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)~````3210Cadenza`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Either`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3}">
            <param name="value">
           A <typeparamref name="T1" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T1" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T1" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3,T4}.A(`0)" />
        </member>
        <member name="M:Cadenza.Either`4.op_Implicit(````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)~````3210Cadenza`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Either`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3}">
            <param name="value">
           A <typeparamref name="T2" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T2" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T2" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3,T4}.B(`1)" />
        </member>
        <member name="M:Cadenza.Either`4.op_Implicit(````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)~````3210Cadenza`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Either`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3}">
            <param name="value">
           A <typeparamref name="T3" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T3" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T3" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3,T4}.C(`2)" />
        </member>
        <member name="M:Cadenza.Either`4.op_Implicit(````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)~````3210Cadenza`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Either`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3{````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3}">
            <param name="value">
           A <typeparamref name="T4" /> containing the value to store.
        </param>
            <summary>
           Creates a <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T4" /> value.
        </summary>
            <returns>
           A <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance which
           holds a <typeparamref name="T4" /> value.
        </returns>
            <remarks>
                <para>
            This conversion operator is provided to make
            <see cref="T:Cadenza.Either{T1,T2,T3,T4}" /> instance creation easier:
          </para>
                <code lang="C#">
        Either&lt;int, double&gt; value = 42.0;  // value stored in 2nd position</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
           if <paramref name="value" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Either{T1,T2,T3,T4}.D(`3)" />
        </member>
        <member name="T:Cadenza.EventHandlerCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.EventHandlerCoda.Raise(System.EventHandler,System.Object)">
            <param name="self">To be added.</param>
            <param name="sender">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.EventHandlerCoda.Raise(System.EventHandler,System.Object,System.EventArgs)">
            <param name="self">To be added.</param>
            <param name="sender">To be added.</param>
            <param name="e">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.EventHandlerCoda.Raise(System.EventHandler,System.Object,System.Func{System.EventArgs})">
            <param name="self">To be added.</param>
            <param name="sender">To be added.</param>
            <param name="creator">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.EventHandlerCoda.Raise(System.EventHandler,System.Object,System.Func{System.EventArgs})" /></exception>
        </member>
        <member name="M:Cadenza.EventHandlerCoda.Raise``1(System.EventHandler{``0},System.Object,System.Func{``0})">
            <typeparam name="T">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="sender">To be added.</param>
            <param name="creator">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.EventHandlerCoda.Raise``1(System.EventHandler{``0},System.Object,System.Func{``0})" /></exception>
        </member>
        <member name="M:Cadenza.EventHandlerCoda.Raise``1(System.EventHandler{``0},System.Object,``0)">
            <typeparam name="T">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="sender">To be added.</param>
            <param name="args">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.FuncCoda">
            <summary>
            Provides extension methods on <see cref="T:System.Action{T}" />,
            <see cref="T:System.Func{T,TResult}" />, and related delegates.
            </summary>
            <remarks>
                <para>
                    <see cref="T:Cadenza.FuncCoda" /> provides methods methods for:
            </para>
                <list type="bullet">
                    <item>
                        <term>
            Delegate currying and partial application (<see cref="M:Cadenza.DelegateCoda.Curry" />)
            </term>
                    </item>
                    <item>
                        <term>
            Delegate composition (<see cref="M:Cadenza.DelegateCoda.Compose" />)
            </term>
                    </item>
                    <item>
                        <term>
            Timing generation (<see cref="M:Cadenza.DelegateCoda.Timings" />)
            </term>
                    </item>
                </list>
                <para>
            Currying via partial application is a way to easily transform
            functions which accept N arguments into functions which accept
            N-1 arguments, by "fixing" arguments with a value.
            </para>
                <code lang="C#">
            // partial application:
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,int,int&gt;     f_3      = function.Curry (3);
            Func&lt;int&gt;             f_321    = function.Curry (3, 2, 1);
            Console.WriteLine (f_3 (2, 1));  // prints (3 + 2 + 1) == "6"
            Console.WriteLine (f_321 ());    // prints (3 + 2 + 1) == "6"</code>
                <para>
            "Traditional" currying converts a delegate that accepts N arguments
            into a delegate which accepts only one argument, but when invoked may
            return a further delegate (etc.) until the final value is returned.
            </para>
                <code lang="C#">
            // traditional currying:
            Func&lt;int, Func&lt;int, Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Func&lt;int, Func&lt;int, int&gt;&gt;            fc_1  = curry (1);
            Func&lt;int, int&gt;                       fc_12 = fc_1 (2);
            Console.WriteLine (fc_12 (3));        // prints (3 + 2 + 1) == "6"
            Console.WriteLine (curry (3)(2)(1));  // prints (3 + 2 + 1) == "6"</code>
                <para>
            Composition is a way to easy chain (or pipe) together multiple delegates
            so that the return value of a "composer" delegate is used as the input
            parameter for the chained delegate:
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
                <para>
            All possible argument and return delegate permutations are provided
            for the <see cref="T:System.Func{T,TResult}" /> and related types.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.FuncCoda.Compose``2(System.Func{``0,``1},System.Func{``0})">
            <typeparam name="T">
            The <see cref="T:System.Func{T}" /> return type, and <see cref="T:System.Func{T,TResult}" /> argument type.
            </typeparam>
            <typeparam name="TResult">
            The <see cref="T:System.Func{T,TResult}" /> return type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Compose``3(System.Func{``1,``2},System.Func{``0,``1})">
            <typeparam name="T1">To be added.</typeparam>
            <typeparam name="T2">
            The <see cref="T:System.Func{T1,T2}" /> return type, and <see cref="T:System.Func{T2,TResult}" /> argument type.
            </typeparam>
            <typeparam name="TResult">
            The <see cref="T:System.Func{T2,TResult}" /> return type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T2,TResult}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Compose``4(System.Func{``2,``3},System.Func{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">To be added.</typeparam>
            <typeparam name="T3">
            The <see cref="T:System.Func{T1,T2,T3}" /> return type, and <see cref="T:System.Func{T3,TResult}" /> argument type.
            </typeparam>
            <typeparam name="TResult">
            The <see cref="T:System.Func{T3,TResult}" /> return type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T3,TResult}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,T2,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Compose``5(System.Func{``3,``4},System.Func{``0,``1,``2,``3})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">To be added.</typeparam>
            <typeparam name="T4">
            The <see cref="T:System.Func{T1,T2,T3,T4}" /> return type, and <see cref="T:System.Func{T4,TResult}" /> argument type.
            </typeparam>
            <typeparam name="TResult">
            The <see cref="T:System.Func{T4,TResult}" /> return type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T4,TResult}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3,T4}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,T2,T3,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Compose``6(System.Func{``4,``5},System.Func{``0,``1,``2,``3,``4})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> parameter type.
            </typeparam>
            <typeparam name="T4">To be added.</typeparam>
            <typeparam name="T5">
            The <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> return type, and <see cref="T:System.Func{T5,TResult}" /> argument type.
            </typeparam>
            <typeparam name="TResult">
            The <see cref="T:System.Func{T5,TResult}" /> return type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T5,TResult}" /> to compose.
            </param>
            <param name="composer">
            The <see cref="T:System.Func{T1,T2,T3,T4,T5}" /> to compose with <paramref name="self" />.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="composer" /> and pass the return value of
            <paramref name="composer" /> to <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            Composition is useful for chaining delegates together, so that the
            return value of <paramref name="composer" /> is automatically used as
            the input parameter for <paramref name="self" />.
            </para>
                <code lang="C#">
            Func&lt;int,string&gt; tostring = Lambda.F ((int n) =&gt; n.ToString ());
            Func&lt;int, int&gt;    doubler = Lambda.F ((int n) =&gt; n * 2);
            Func&lt;int, string&gt;
            double_then_tostring = tostring.Compose (doubler);
            Console.WriteLine (double_then_tostring (5));
            // Prints "10";</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="composer" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``2(System.Func{``0,``1})">
            <typeparam name="T">
            The first value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T,TResult}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``2(System.Func{``0,``1},Cadenza.Tuple{``0})">
            <typeparam name="T">
            A <see cref="T:System.Func{T,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``2(System.Func{``0,``1},``0)">
            <typeparam name="T">
            A <see cref="T:System.Func{T,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T,TResult}" /> to curry.
            </param>
            <param name="value">
            A value of type <typeparamref name="T" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``3(System.Func{``0,``1,``2})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,TResult}}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,TResult}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``3(System.Func{``0,``1,``2},Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``3(System.Func{``0,``1,``2},Cadenza.Tuple{``0})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T2,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T2,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``3(System.Func{``0,``1,``2},``0)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T2,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T2,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``3(System.Func{``0,``1,``2},``0,``1)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,TResult}}}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,TResult}}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,System.Func{T3,TResult}}" /> which, when invoked, will return a <see cref="T:System.Func{T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3},Cadenza.Tuple{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3},Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T3,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3},Cadenza.Tuple{``0})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T2,T3,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T2,T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3},``0)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T2,T3,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T2,T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3},``0,``1)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T3,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T3,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``4(System.Func{``0,``1,``2,``3},``0,``1,``2)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="T4">
            The fourth value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,System.Func{T4,TResult}}}}" /> for currying.
            </summary>
            <returns>
            A <see cref="T:System.Func{T1,System.Func{T2,System.Func{T3,System.Func{T4,TResult}}}}" /> which, when invoked, will
            return a <see cref="T:System.Func{T2,System.Func{T3,System.Func{T4,TResult}}}" /> which, when invoked, will return a <see cref="T:System.Func{T3,System.Func{T4,TResult}}" /> which, when invoked, will return a <see cref="T:System.Func{T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" />.
            </returns>
            <remarks>
                <para>
            This is the more "traditional" view of currying, turning a method
            which takes <c>(X * Y)-&gt;Z</c> (i.e. separate arguments) into a
            <c>X -&gt; (Y -&gt; Z)</c> (that is a "chain" of nested Funcs such that
            you provide only one argument to each Func until you provide enough
            arguments to invoke the original method).
            </para>
                <code lang="C#">
            Func&lt;int,int,int,int&gt; function = (int a, int b, int c) =&gt; a + b + c;
            Func&lt;int,Func&lt;int,Func&lt;int, int&gt;&gt;&gt; curry = function.Curry ();
            Assert.AreEqual(6, curry (3)(2)(1));</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},Cadenza.Tuple{``0,``1,``2,``3})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},Cadenza.Tuple{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1,T2}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T3,T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},Cadenza.Tuple{``0})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="values">
            A value of type <see cref="T:Cadenza.Tuple{T1}" /> which contains the values to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T2,T3,T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T2,T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},``0)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T2,T3,T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T2,T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},``0,``1)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T3,T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T3,T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},``0,``1,``2)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T4,TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.FuncCoda.Curry``5(System.Func{``0,``1,``2,``3,``4},``0,``1,``2,``3)">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to curry.
            </param>
            <param name="value1">
            A value of type <typeparamref name="T1" /> to fix.
            </param>
            <param name="value2">
            A value of type <typeparamref name="T2" /> to fix.
            </param>
            <param name="value3">
            A value of type <typeparamref name="T3" /> to fix.
            </param>
            <param name="value4">
            A value of type <typeparamref name="T4" /> to fix.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{TResult}" /> which, when invoked, will
            invoke <paramref name="self" /> along with the provided fixed parameters.
            </returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="T:Cadenza.Int16Coda">
            <summary>
      Extension methods for <see cref="T:System.Int16" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Int16Coda.IsEven(System.Int16)">
            <param name="value">
          A <see cref="T:System.Int16" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an even number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an even number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.Int16Coda.IsOdd(System.Int16)" />
        </member>
        <member name="M:Cadenza.Int16Coda.IsOdd(System.Int16)">
            <param name="value">
          A <see cref="T:System.Int16" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an odd number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an odd number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.Int16Coda.IsEven(System.Int16)" />
        </member>
        <member name="T:Cadenza.Int32Coda">
            <summary>Extension methods for <see cref="T:System.Int32" />.</summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Int32Coda.DownTo(System.Int32,System.Int32)">
            <param name="self">
          An <see cref="T:System.Int32" /> containing the upper starting value.
        </param>
            <param name="limit">
          An <see cref="T:System.Int32" /> containing the lower ending value.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          which will return the values from <paramref name="self" /> down to
          <paramref name="limit" />, inclusive.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          with values between <paramref name="self" /> down to 
          <paramref name="limit" />, inclusive.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <block subset="none" type="note">
            No bounds checking is performed, so if <paramref name="limit" />
            is greater than <paramref name="self" />, then
            <c>(<see cref="F:System.Int32.MaxValue" /> - 
            <paramref name="self" /> - <paramref name="limit" />)</c> 
            values will be returned.
          </block>
            </remarks>
            <example>
                <para>
            The following example demonstrates use of 
            <see cref="M:Cadenza.Int32Coda.DownTo(System.Int32,System.Int32)" />:
          </para>
                <code lang="C#">
Console.WriteLine (5.DownTo (0).Implode (", "));
    // Prints "5, 4, 3, 2, 1, 0"</code>
            </example>
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="M:Cadenza.Int32Coda.IsEven(System.Int32)">
            <param name="value">
          A <see cref="T:System.Int32" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an even number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an even number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.Int32Coda.IsOdd(System.Int32)" />
        </member>
        <member name="M:Cadenza.Int32Coda.IsOdd(System.Int32)">
            <param name="value">
          A <see cref="T:System.Int32" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an odd number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an odd number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.Int32Coda.IsEven(System.Int32)" />
        </member>
        <member name="M:Cadenza.Int32Coda.Step(System.Int32,System.Int32,System.Int32)">
            <param name="self">
          An <see cref="T:System.Int32" /> containing the lower starting value.
        </param>
            <param name="limit">
          An <see cref="T:System.Int32" /> containing the upper ending value.
        </param>
            <param name="step">
          An <see cref="T:System.In32" /> containing the value to increment
          by.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          which will return the values from <paramref name="self" /> up to
          <paramref name="limit" />, inclusive, incrementing by 
          <paramref name="step" /> between each value.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          with values between <paramref name="self" /> up to 
          <paramref name="limit" />, inclusive.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <block subset="none" type="note">
            No bounds checking is performed, so if <paramref name="limit" />
            is less than <paramref name="self" />, then
            <c>((<see cref="F:System.Int32.MaxValue" /> - 
            <paramref name="self" /> - <paramref name="limit" />) /
            <paramref name="step" />)</c> values will be returned.
          </block>
            </remarks>
            <example>
                <para>
            The following example demonstrates use of 
            <see cref="M:Cadenza.Int32Coda.Step(System.Int32,System.Int32,System.Int32)" />:
          </para>
                <code lang="C#">
Console.WriteLine (1.Step(9, 2).Implode (", "));
    // Prints "1, 3, 5, 7, 9"</code>
            </example>
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="M:Cadenza.Int32Coda.Times(System.Int32)">
            <param name="self">
          An <see cref="T:System.Int32" /> containing the positive upper limit.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          which will return the values between <c>0</c> and 
          <paramref name="self" />, exclusive.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          with values between <c>0</c> up to <paramref name="self" /> 
          exclusive.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="self" /> is less than <c>0</c>.
        </exception>
            <example>
                <para>
            The following example demonstrates use of 
            <see cref="M:Cadenza.Int32Coda.Times(System.Int32)" />:
          </para>
                <code lang="C#">
Console.WriteLine (6.Times ().Implode (", "));
    // Prints "0, 1, 2, 3, 4, 5"</code>
            </example>
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="M:Cadenza.Int32Coda.UpTo(System.Int32,System.Int32)">
            <param name="self">
          An <see cref="T:System.Int32" /> containing the lower starting value.
        </param>
            <param name="limit">
          An <see cref="T:System.Int32" /> containing the upper ending value.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          which will return the values from <paramref name="self" /> up to
          <paramref name="limit" />, inclusive.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.Int32}" />
          with values between <paramref name="self" /> up to 
          <paramref name="limit" />, inclusive.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <block subset="none" type="note">
            No bounds checking is performed, so if <paramref name="limit" />
            is less than than <paramref name="self" />, then
            <c>(<see cref="F:System.Int32.MaxValue" /> - 
            <paramref name="self" /> - <paramref name="limit" />)</c> 
            values will be returned.
          </block>
            </remarks>
            <example>
                <para>
            The following example demonstrates use of 
            <see cref="M:Cadenza.Int32Coda.UpTo(System.Int32,System.Int32)" />:
          </para>
                <code lang="C#">
Console.WriteLine (6.UpTo (12).Implode (", "));
    // Prints "6, 7, 8, 9, 10, 11, 12"</code>
            </example>
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
            <altmember cref="M:Cadenza.IEnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="T:Cadenza.Int64Coda">
            <summary>
      Extension methods for <see cref="T:System.Int64" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Int64Coda.IsEven(System.Int64)">
            <param name="value">
          A <see cref="T:System.Int64" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an even number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an even number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.Int64Coda.IsOdd(System.Int64)" />
        </member>
        <member name="M:Cadenza.Int64Coda.IsOdd(System.Int64)">
            <param name="value">
          A <see cref="T:System.Int64" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an odd number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an odd number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.Int64Coda.IsEven(System.Int64)" />
        </member>
        <member name="T:Cadenza.JaggedArrayCoda">
            <summary>
      Extension methods for jagged arrays.
    </summary>
            <remarks>
      A jagged array is a type like <c>int[][]</c>.
    </remarks>
        </member>
        <member name="M:Cadenza.JaggedArrayCoda.Rows``1(``0[][])">
            <typeparam name="TSource">
          The type of elements within the jagged array.
        </typeparam>
            <param name="self">
          A jagged array of <typeparamref name="TSource" /> elements.
        </param>
            <summary>
          Converts a jagged array into an 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />.
        </summary>
            <returns>
          An <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          of each element within <paramref name="self" /> in row-major order.
        </returns>
            <remarks>
                <para>
            This is particularly useful for transposing jagged arrays, as
            it can be used with
            <see cref="M:Cadenza.IEnumerableCoda.Transpose``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/JaggedArrayCodaTest.cs#Rows">int[][] s = new []{
	new[]{1, 2, 3},
	new[]{4, 5, 6},
	new[]{7, 8, 9},
};
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; r = s.Rows();
Assert.AreEqual (3, r.Count ());

Assert.IsTrue (new[]{1,2,3}.SequenceEqual (r.ElementAt (0)));
Assert.IsTrue (new[]{4,5,6}.SequenceEqual (r.ElementAt (1)));
Assert.IsTrue (new[]{7,8,9}.SequenceEqual (r.ElementAt (2)));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="T:Cadenza.Lambda">
            <summary>
            Provides static utility methods to generate anonymous delegates
            or expression trees of pre-determined types.
            </summary>
            <remarks>
                <para>
            C# lambda methods and anonymous delegates are a curious
            1.5-class citizen: They are implicitly convertable to any
            delegate type, but have no type by themselves.  Thus,
            the following code fails to compile:
            </para>
                <code lang="C#">
            ((int x) =&gt; Console.WriteLine (x))(5);
            </code>
                <para>It would instead need:</para>
                <code lang="C#">
            // either:
            Action&lt;int&gt; a = x =&gt; Console.WriteLine (x);
            a (5);
            //
            // or
            //
            ((Action&lt;int&gt;) (x =&gt; Console.WriteLine (x)))(5);
            </code>
                <para>
            So you'd either need to assign the lambda to an actual
            delegate type, or insert a cast.
            </para>
                <para>
                    <see cref="M:Cadenza.Lambda.A" /> allows you to
            provide a lambda body for the <see cref="T:System.Action" />
            builtin delegate type, and <see cref="M:Cadenza.Lambda.F" />
            allows you to provide a lambda body for the
            <see cref="T:System.Func{TResult}" /> delegate type,
            thus removing the need for a cast or an extra variable:
            </para>
                <code lang="C#">
            Lambda.F ((int x) =&gt; Console.WriteLine (x)) (5);</code>
                <para>
                    <see cref="T:Cadenza.Lambda" /> provides the following sets of
            functionality:
            </para>
                <list type="bullet">
                    <item>
                        <term>Delegate creation methods, which return
            <see cref="T:System.Action" />-like delegates:
            <see cref="M:Cadenza.Lambda.A(System.Action)" />,
            <see cref="M:Cadenza.Lambda.A``1(System.Action{``0})" />,
            <see cref="M:Cadenza.Lambda.A``2(System.Action{``0,``1})" />,
            <see cref="M:Cadenza.Lambda.A``3(System.Action{``0,``1,``2})" />, and
            <see cref="M:Cadenza.Lambda.A``4(System.Action{``0,``1,``2,``3})" />.
            </term>
                    </item>
                    <item>
                        <term>Delegate creation methods which return
            return <see cref="T:System.Func{TResult}" />-like delegates
            <see cref="M:Cadenza.Lambda.F``1(System.Func{``0})" />,
            <see cref="M:Cadenza.Lambda.F``2(System.Func{``0,``1})" />,
            <see cref="M:Cadenza.Lambda.F``3(System.Func{``0,``1,``2})" />,
            <see cref="M:Cadenza.Lambda.F``4(System.Func{``0,``1,``2,``3})" />, and
            <see cref="M:Cadenza.Lambda.F``5(System.Func{``0,``1,``2,``3,``4})" />.
            </term>
                    </item>
                    <item>
                        <term>
                            <see cref="T:System.Linq.Expressions.Expression" />-creating methods:
            <see cref="M:Cadenza.Lambda.XA(System.Linq.Expressions.Expression{System.Action})" />,
            <see cref="M:Cadenza.Lambda.XA``1(System.Linq.Expressions.Expression{System.Action{``0}})" />,
            <see cref="M:Cadenza.Lambda.XA``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})" />,
            <see cref="M:Cadenza.Lambda.XA``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}})" />,
            <see cref="M:Cadenza.Lambda.XA``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}})" />, and
            <see cref="M:Cadenza.Lambda.XF``1(System.Linq.Expressions.Expression{System.Func{``0}})" />,
            <see cref="M:Cadenza.Lambda.XF``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})" />,
            <see cref="M:Cadenza.Lambda.XF``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})" />,
            <see cref="M:Cadenza.Lambda.XF``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})" />,
            <see cref="M:Cadenza.Lambda.XF``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})" />.
            </term>
                    </item>
                    <item>
                        <term>Y-Combinators, which permit writing recursive lambdas:
            <see cref="M:Cadenza.Lambda.RecFunc``2(System.Func{System.Func{``0,``1},System.Func{``0,``1}})" />,
            <see cref="M:Cadenza.Lambda.RecFunc``3(System.Func{System.Func{``0,``1,``2},System.Func{``0,``1,``2}})" />,
            <see cref="M:Cadenza.Lambda.RecFunc``4(System.Func{System.Func{``0,``1,``2,``3},System.Func{``0,``1,``2,``3}})" />, and
            <see cref="M:Cadenza.Lambda.RecFunc``5(System.Func{System.Func{``0,``1,``2,``3,``4},System.Func{``0,``1,``2,``3,``4}})" />.
            </term>
                    </item>
                </list>
            </remarks>
        </member>
        <member name="M:Cadenza.Lambda.A(System.Action)">
            <param name="lambda">
            The <see cref="T:System.Action" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Action" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.A``1(System.Action{``0})">
            <typeparam name="T">
            A <see cref="T:System.Action{T}" /> parameter type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Action{T}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.A``2(System.Action{``0,``1})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2}" /> parameter type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Action{T1,T2}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1,T2}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.A``3(System.Action{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3}" /> parameter type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Action{T1,T2,T3}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1,T2,T3}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.A``4(System.Action{``0,``1,``2,``3})">
            <typeparam name="T1">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Action{T1,T2,T3,T4}" /> parameter type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Action{T1,T2,T3,T4}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Action{T1,T2,T3,T4}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.F``1(System.Func{``0})">
            <typeparam name="TResult">
            A <see cref="T:System.Func{TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{TResult}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{TResult}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.F``2(System.Func{``0,``1})">
            <typeparam name="T">
            A <see cref="T:System.Func{T,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T,TResult}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T,TResult}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.F``3(System.Func{``0,``1,``2})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T1,T2,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,TResult}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.F``4(System.Func{``0,``1,``2,``3})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,TResult}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.F``5(System.Func{``0,``1,``2,``3,``4})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> delegate.
            </summary>
            <returns>
            Returns <paramref name="lambda" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.RecFunc``2(System.Func{System.Func{``0,``1},System.Func{``0,``1}})">
            <typeparam name="T">
            A <see cref="T:System.Func{T,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T,TResult}" /> to use.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T,TResult}" /> delegate, which may be recursive.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T,TResult}" /> which (eventually) invokes <paramref name="lambda" />.
            </returns>
            <remarks>
                <para>
            The following example makes use of a recursive lambda:
            </para>
                <code lang="C#">
            Func&lt;int, int&gt; factorial = Lambda.RecFunc&lt;int, int&gt; (
            fac =&gt; x =&gt; x == 0 ? 1 : x * fac (x-1));
            Console.WriteLine (factorial (5));  // prints "120"
            </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="lambda" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Lambda.RecFunc``3(System.Func{System.Func{``0,``1,``2},System.Func{``0,``1,``2}})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T1,T2,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T1,T2,TResult}" /> to use.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,TResult}" /> delegate, which may be recursive.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,T2,TResult}" /> which (eventually) invokes <paramref name="lambda" />.
            </returns>
            <remarks>
                <para>
            The following example makes use of a recursive lambda:
            </para>
                <code lang="C#">
            Func&lt;int, int&gt; factorial = Lambda.RecFunc&lt;int, int&gt; (
            fac =&gt; x =&gt; x == 0 ? 1 : x * fac (x-1));
            Console.WriteLine (factorial (5));  // prints "120"
            </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="lambda" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Lambda.RecFunc``4(System.Func{System.Func{``0,``1,``2,``3},System.Func{``0,``1,``2,``3}})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T1,T2,T3,TResult}" /> to use.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,TResult}" /> delegate, which may be recursive.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,T2,T3,TResult}" /> which (eventually) invokes <paramref name="lambda" />.
            </returns>
            <remarks>
                <para>
            The following example makes use of a recursive lambda:
            </para>
                <code lang="C#">
            Func&lt;int, int&gt; factorial = Lambda.RecFunc&lt;int, int&gt; (
            fac =&gt; x =&gt; x == 0 ? 1 : x * fac (x-1));
            Console.WriteLine (factorial (5));  // prints "120"
            </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="lambda" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Lambda.RecFunc``5(System.Func{System.Func{``0,``1,``2,``3,``4},System.Func{``0,``1,``2,``3,``4}})">
            <typeparam name="T1">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> return type.
            </typeparam>
            <param name="lambda">
            The <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> to use.
            </param>
            <summary>
            Creates a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> delegate, which may be recursive.
            </summary>
            <returns>
            Returns a <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> which (eventually) invokes <paramref name="lambda" />.
            </returns>
            <remarks>
                <para>
            The following example makes use of a recursive lambda:
            </para>
                <code lang="C#">
            Func&lt;int, int&gt; factorial = Lambda.RecFunc&lt;int, int&gt; (
            fac =&gt; x =&gt; x == 0 ? 1 : x * fac (x-1));
            Console.WriteLine (factorial (5));  // prints "120"
            </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="lambda" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.Lambda.XA(System.Linq.Expressions.Expression{System.Action})">
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Action}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Action}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XA``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <typeparam name="T">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T}}" /> parameter type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Action{T}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Action{T}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XA``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
            <typeparam name="T1">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2}}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2}}" /> parameter type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XA``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}})">
            <typeparam name="T1">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3}}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3}}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3}}" /> parameter type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XA``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}})">
            <typeparam name="T1">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3,T4}}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3,T4}}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3,T4}}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3,T4}}" /> parameter type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3,T4}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Action{T1,T2,T3,T4}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XF``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <typeparam name="TResult">
            The <see cref="T:System.Linq.Expressions.Expression{System.Func{TResult}}" /> return type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Func{TResult}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Func{TResult}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XF``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <typeparam name="T">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T,TResult}}" /> return type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Func{T,TResult}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Func{T,TResult}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XF``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <typeparam name="T1">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,TResult}}" /> return type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,TResult}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,TResult}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XF``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <typeparam name="T1">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,TResult}}" /> return type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,TResult}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,TResult}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Lambda.XF``5(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3,``4}})">
            <typeparam name="T1">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="T2">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="T3">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="T4">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> parameter type.
            </typeparam>
            <typeparam name="TResult">
            A <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> return type.
            </typeparam>
            <param name="expr">
            The <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> to return.
            </param>
            <summary>
            Creates a <see cref="T:System.Linq.Expressions.Expression{System.Func{T1,T2,T3,T4,TResult}}" /> expression tree.
            </summary>
            <returns>
            Returns <paramref name="expr" />.
            </returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Maybe">
            <summary>
      Static utility methods for creating 
      <see cref="T:Cadenza.Maybe{T}" /> instances.
    </summary>
            <remarks>
      Use the <see cref="M:Cadenza.Maybe.TryParse" /> methods if it is
      not necessary to know why the value couldn't be parsed.  Otherwise, use the
      <see cref="M:Cadenza.Either.TryParse" /> methods.
    </remarks>
        </member>
        <member name="M:Cadenza.Maybe.TryConvert``2(``0)">
            <typeparam name="TSource">
          The type to convert from.
        </typeparam>
            <typeparam name="TResult">
          The type to convert to.
        </typeparam>
            <param name="value">
          A <typeparamref name="TSource" /> containing the value to parse into
          an instance of type <typeparamref name="TResult" />.
        </param>
            <summary>
          Converts the <paramref name="value" /> of type
          <typeparamref name="TSource" /> into an instance of type 
          <typeparamref name="TResult" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Maybe{TResult}" />.  If <paramref name="value" />
          could be converted into a value of type <typeparamref name="TResult" />,
          then <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> will be
          <see langword="true" /> and 
          <see cref="P:Cadenza.Maybe{TResult}.Value" /> will contain the
          converted value; otherwise, 
          <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> will be
          <see langword="false" />.
        </returns>
            <remarks>
                <para>
                    <c>TryConvert</c> uses
            <see cref="M:Cadenza.Either.TryConvert``2(``0)" /> to convert
            <paramref name="value" /> into an instance of type
            <typeparamref name="TResult" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#TryConvert">Maybe&lt;string&gt; a = Maybe.TryConvert&lt;int, string&gt; (42);
Assert.IsTrue (a.HasValue);
Assert.AreEqual ("42", a.Value);

Maybe&lt;DateTime&gt; b = Maybe.TryConvert&lt;int, DateTime&gt; (42);
Assert.IsFalse (b.HasValue);
</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe.TryParse``1(System.String)">
            <typeparam name="T">
          The type of object to attempt to parse out of 
          <paramref name="value" />.
        </typeparam>
            <param name="value">
          A <see cref="T:System.String" /> containing the value to parse into
          an instance of type <typeparamref name="T" />.
        </param>
            <summary>
          Converts a <see cref="T:System.String" />
          into an instance of type <typeparamref name="T" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Maybe{T}" />.  If <paramref name="value" />
          could be converted into a value of type <typeparamref name="T" />,
          then <see cref="P:Cadenza.Maybe{T}.HasValue" /> will be
          <see langword="true" /> and 
          <see cref="P:Cadenza.Maybe{T}.Value" /> will contain the
          converted value; otherwise, 
          <see cref="P:Cadenza.Maybe{T}.HasValue" /> will be
          <see langword="false" />.
        </returns>
            <remarks>
                <para>
                    <c>TryParse</c> uses
            <see cref="M:Cadenza.Either.TryConvert``2(``0)" /> to convert
            the string <paramref name="value" /> into an instance of type
            <typeparamref name="T" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#TryParse">Maybe&lt;int&gt; n;

n = Maybe.TryParse&lt;int&gt; (null);
Assert.IsFalse (n.HasValue);

n = Maybe.TryParse&lt;int&gt; ("");
Assert.IsFalse (n.HasValue);

n = Maybe.TryParse&lt;int&gt; ("foo");
Assert.IsFalse (n.HasValue);

n = Maybe.TryParse&lt;int&gt; ("42.01");
Assert.IsFalse (n.HasValue);

n = Maybe.TryParse&lt;int&gt; ("42");
Assert.IsTrue (n.HasValue);
Assert.AreEqual (42, n.Value);
</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe.When``1(System.Boolean,System.Func{``0})">
            <typeparam name="T">
          The type of value that <see cref="T:Cadenza.Maybe{T}" /> should
          contain.
        </typeparam>
            <param name="condition">
          If <see langword="true" />, <c>When</c> returns
          <c><paramref name="creator" />().Just()</c>.
          Otherwise, <c>When</c> returns 
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </param>
            <param name="creator">
          A <see cref="T:System.Func{T}" /> which is used to create the value
          returned when <paramref name="condition" /> is 
          <see langword="true" />.
        </param>
            <summary>
          Returns a value-containing <see cref="T:Cadenza.Maybe{T}" />
          instance or <see cref="F:Cadenza.Maybe{T}.Nothing" />, depending
          on <paramref name="condition" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Maybe{T}" />.  If 
          <paramref name="condition" /> is <see langword="true" />,
          then <paramref name="creator" /> is evaluated and a 
          <see cref="T:Cadenza.Maybe{T}" /> instance containing the value
          returned by <paramref name="creator" /> is returned; otherwise,
          <see cref="F:Cadenza.Maybe{T}.Nothing" /> is returned.
        </returns>
            <remarks>
                <para>
            Use this method instead of 
            <see cref="M:Cadenza.Maybe.When``1(System.Boolean,``0)" />
            when the value you need to return can only be created when
            <paramref name="condition" /> is <see langword="true" />.
          </para>
                <code lang="C#">string s = GetSomeString();
int length;

// BAD:
length = s.Match (
    v =&gt; Maybe.When (s != null, s.Length),  // may throw, if s == null
    v =&gt; Maybe.When (s == null, 0));

// GOOD:
length = s.Match (
    v =&gt; Maybe.When (s != null, () =&gt; s.Length),  // delays evaluation.
    v =&gt; Maybe.When (s == null, 0));
          </code>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#When_Creator">bool invoked = false;
r = Maybe.When (false, () =&gt; {invoked = true; return 42;});
Assert.IsFalse (invoked);
Assert.IsFalse (r.HasValue);

r = Maybe.When (true, () =&gt; {invoked = true; return 42;});
Assert.IsTrue (invoked);
Assert.IsTrue (r.HasValue);
Assert.AreEqual (42, r.Value);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="condition" /> is <see langword="true" /> and
          <paramref name="creator" /> returned <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Maybe.When``1(System.Boolean,``0)" />
            <altmember cref="M:Cadenza.ObjectCoda.Match``2(``0,System.Func{``0,Cadenza.Maybe{``1}}[])" />
        </member>
        <member name="M:Cadenza.Maybe.When``1(System.Boolean,``0)">
            <typeparam name="T">
          The type of value that <see cref="T:Cadenza.Maybe{T}" /> should
          contain.
        </typeparam>
            <param name="condition">
          If <see langword="true" />, <c>When</c> returns
          <c><paramref name="value" />.Just()</c>.
          Otherwise, <c>When</c> returns 
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </param>
            <param name="value">
          A <typeparamref name="T" /> containing the value to return when
          <paramref name="condition" /> is <see langword="true" />.
        </param>
            <summary>
          Returns a value-containing <see cref="T:Cadenza.Maybe{T}" />
          instance or <see cref="F:Cadenza.Maybe{T}.Nothing" />, depending
          on <paramref name="condition" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Maybe{T}" />.  If 
          <paramref name="condition" /> is <see langword="true" />,
          then a 
          <see cref="T:Cadenza.Maybe{T}" /> instance containing the value
          <paramref name="value" /> is returned; otherwise,
          <see cref="F:Cadenza.Maybe{T}.Nothing" /> is returned.
        </returns>
            <remarks>
                <para>
            Use this method instead of 
            <see cref="M:Cadenza.Maybe.When``1(System.Boolean,System.Func{``0})" />
            when it doesn't matter of <paramref name="value" /> is
            immediately evaluated.
          </para>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#When">var r = Maybe.When (true, 42);
Assert.IsTrue (r.HasValue);
Assert.AreEqual (42, r.Value);

r = Maybe.When (false, 42);
Assert.IsFalse (r.HasValue);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="condition" /> is <see langword="true" /> and
          <paramref name="value" /> returned <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Maybe.When``1(System.Boolean,``0)" />
            <altmember cref="M:Cadenza.ObjectCoda.Match``2(``0,System.Func{``0,Cadenza.Maybe{``1}}[])" />
        </member>
        <member name="T:Cadenza.Maybe`1">
            <typeparam name="T">
      The type of the optional value.
    </typeparam>
            <summary>
      Represents an optional value. An instance of 
      <see cref="T:Cadenza.Maybe{T}" /> can contain a value of type 
      <typeparamref name="T" /> or an indication that the instance contains 
      no value. 
    </summary>
            <remarks>
                <para>
        The <see cref="T:Cadenza.Maybe{T}" /> value type represents a value 
        of a given type <typenameref name="T" /> or an indication that the 
        instance contains no value. Such an optional value type is useful in a 
        variety of situations, such as denoting that a conversion couldn't be
        performed without resorting to an exception or by-ref parameters 
        (<see langword="out" /> or <see langword="ref" />).
      </para>
                <para>
        An instance of <see cref="T:Cadenza.Maybe{T}" /> has two 
        properties, <see cref="P:Cadenza.Maybe{T}.HasValue" /> and 
        <see cref="P:Cadenza.Maybe{T}.Value" />. 
        <see cref="P:Cadenza.Maybe{T}.HasValue" /> is used to determine 
        whether the current instance currently has a value.  
        It returns <see langword="true" /> or <see langword="false" />, and 
        never throws an exception. 
        <see cref="P:Cadenza.Maybe{T}.Value" /> returns the current value 
        of the instance, provided it has one 
        (i.e., <see cref="P:Cadenza.Maybe{T}.HasValue" /> is 
        <see langword="true" />); otherwise, it throws an exception.
      </para>
                <para>
        In addition to the above properties, there is a pair of methods, both 
        overloads of <see cref="M:Cadenza.Maybe{T}.GetValueOrDefault" />. 
        The version taking no arguments returns the instance's current value, 
        if it has one; otherwise, it returns the default value of type 
        <typeparamref name="T" />. The version taking an argument of type 
        <typeparamref name="T" /> returns the instance's current value, if it 
        has one; otherwise, it returns the default value argument passed to it.
      </para>
                <para>
                    <see cref="T:Cadenza.Maybe{T}" /> instances can be created in one
        of four ways:
      </para>
                <list type="number">
                    <item>
                        <term>
          By using the default constructor provided for all value types.  This
          will create an instance that contains no value, and will be equal to
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </term>
                    </item>
                    <item>
                        <term>
          By explicitly using the <see cref="C:Cadenza.Maybe{T}(`0)" />
          constructor.  This will throw an 
          <see cref="T:System.ArgumentNullException" /> if the value is
          <see langword="null" />.
        </term>
                    </item>
                    <item>
                        <term>
          By using the <see cref="M:Cadenza.ObjectCoda.Just``1(``0)" />
          extension method.  This will throw an 
          <see cref="T:System.ArgumentNullException" /> if the value is
          <see langword="null" />.
        </term>
                    </item>
                    <item>
                        <term>
          By using the <see cref="M:Cadenza.ObjectCoda.ToMaybe``1(``0)" />
          extension method.  If the value is <see langword="null" />, then
          <see cref="F:Cadenza.Maybe{T}.Nothing" /> is returned.
        </term>
                    </item>
                </list>
                <para>
        Query comprehension support is also provided, allowing:
      </para>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#SelectMany_QueryComprehension">Assert.AreEqual (Maybe&lt;int&gt;.Nothing,
		from x in 5.ToMaybe ()
		from y in Maybe&lt;int&gt;.Nothing
		select x + y);
Assert.AreEqual (9.ToMaybe (),
		from x in 5.ToMaybe ()
		from y in 4.ToMaybe ()
		select x + y);
</code>
            </remarks>
        </member>
        <member name="C:Cadenza.Maybe`1(`0T`0)">
            <param name="value">
          A <typeparamref name="T" /> which is the value of the new instance.
        </param>
            <summary>
          Constructs and initializes a new instance of 
          <see cref="T:Cadenza.Maybe{T}" /> giving it the specified initial
          value.
        </summary>
            <remarks>
                <para>
            This constructor initializes the 
            <see cref="P:Cadenza.Maybe{T}.Value" /> property of the new
            instance using <paramref name="value" />.
          </para>
                <block subset="none" type="note">
            Once this constructor has executed, calling
            <see cref="P:Cadenza.Maybe{T}.HasValue" /> on the new instance 
            will return <see langword="true" />.
          </block>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="value" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Maybe`1.Equals(`0Cadenza`0.`0Maybe`0{`0T`0})">
            <param name="obj">
          An <see cref="T:System.Object" /> to compare the current instance
          against.
        </param>
            <summary>
          Determines whether the current instance and the specified
          <see cref="T:System.Object" /> represent the same value.
        </summary>
            <returns>
                <para>
            The following table defines the conditions under which the return 
            value is <see langword="true" /> or <see langword="false" />:
          </para>
                <list type="table">
                    <listheader>
                        <term>Returned Value</term>
                        <description>HasValue Condition</description>
                        <description>obj.HasValue Condition</description>
                    </listheader>
                    <item>
                        <term>
                            <see langword="true" />
                        </term>
                        <description>
                            <see langword="false" />
                        </description>
                        <description>
                            <see langword="false" />
                        </description>
                    </item>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>
                            <see langword="false" />
                        </description>
                        <description>
                            <see langword="true" />
                        </description>
                    </item>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>
                            <see langword="true" />
                        </description>
                        <description>
                            <see langword="false" />
                        </description>
                    </item>
                    <item>
                        <term>
                            <c>Value.Equals(<paramref name="obj" />.Value)</c>
                        </term>
                        <description>
                            <see langword="true" />
                        </description>
                        <description>
                            <see langword="true" />
                        </description>
                    </item>
                </list>
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
              This method implements
              <see cref="M:System.IEquatable{Cadenza.Maybe{T}}.Equals(`0)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.Equals(`0System`0.`0Object`0)">
            <param name="obj">
          An <see cref="T:System.Object" /> to compare the current instance
          against.
        </param>
            <summary>
          Determines whether the current instance and the specified
          <see cref="T:System.Object" /> represent the same type and value.
        </summary>
            <returns>
                <para>
            The following table defines the conditions under which the return 
            value is <see langword="true" /> or <see langword="false" />:
          </para>
                <list type="table">
                    <listheader>
                        <term>Returned Value</term>
                        <description>HasValue Condition</description>
                        <description>obj.HasValue Condition</description>
                    </listheader>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>The current instance and <paramref name="obj" /> have different types.</description>
                        <description>The current instance and <paramref name="obj" /> have different types.</description>
                    </item>
                    <item>
                        <term>
                            <see langword="true" />
                        </term>
                        <description>
                            <see langword="false" />
                        </description>
                        <description>
                            <paramref name="obj" /> is <see langword="null" />.
              </description>
                    </item>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>
                            <see langword="true" />
                        </description>
                        <description>
                            <paramref name="obj" /> is <see langword="null" />.
              </description>
                    </item>
                    <item>
                        <term>
                            <see langword="true" />
                        </term>
                        <description>
                            <see langword="false" />
                        </description>
                        <description>
                            <see langword="false" />
                        </description>
                    </item>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>
                            <see langword="false" />
                        </description>
                        <description>
                            <see langword="true" />
                        </description>
                    </item>
                    <item>
                        <term>
                            <see langword="false" />
                        </term>
                        <description>
                            <see langword="true" />
                        </description>
                        <description>
                            <see langword="false" />
                        </description>
                    </item>
                    <item>
                        <term>
                            <c>Value.Equals(<paramref name="obj" />.Value)</c>
                        </term>
                        <description>
                            <see langword="true" />
                        </description>
                        <description>
                            <see langword="true" />
                        </description>
                    </item>
                </list>
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
              This method overrides 
              <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.GetHashCode">
            <summary>
          Generates a hash code for the current instance.
        </summary>
            <returns>
          If <see cref="P:Cadenza.Maybe{T}.HasValue" /> is 
          <see langword="true" />, a <see cref="T:System.Int32" /> containing
          the hash code for the value of the current instance is returned; 
          otherwise, 0 is returned.
        </returns>
            <remarks>
                <para>
            The algorithm used to generate the hash code is unspecified.
          </para>
                <para>
                    <block subset="none" type="note">
              This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.GetValueOrDefault">
            <summary>
          Returns the value of the current instance, or if it has none, returns
          the default value for the type <typeparamref name="T" />.
        </summary>
            <returns>
          A value of type <typeparamref name="T" />, which is either the value 
          of the current instance, or if it has none, the default value for the
          type <typeparamref name="T" /> (i.e., all-bits-zero).
        </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
                        <see cref="M:Cadenza.Maybe{T}.GetValueOrDefault(`0)" />
              allows a value other than the default value to be returned if the 
              current instance contains no value.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.GetValueOrDefault(`0T`0)">
            <param name="defaultValue">
          A value of type <typeparamref name="T" /> to return if the current
          instance contains no value.
        </param>
            <summary>
          Returns the value of the current instance, or if it has none, returns
          <paramref name="defaultValue" />.
        </summary>
            <returns>
          A value of type <typeparamref name="T" />, which is either the value 
          of the current instance, or if it has none, the value of 
          <paramref name="defaultValue" />.
        </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
                        <see cref="M:Cadenza.Maybe{T}.GetValueOrDefault" />
              allows the default value for type <see langword="T" />  to be 
              returned if the current instance contains no value.
            </block>
                </para>
            </remarks>
        </member>
        <member name="P:Cadenza.Maybe`1.HasValue">
            <summary>
          Gets a value indicating whether the current 
          <see cref="T:Cadenza.Maybe{T}" /> instance has a value.
        </summary>
            <value>
                <see langword="true" /> if the current 
          <see cref="T:Cadenza.Maybe{T}" /> instance has a value;
          otherwise, <see langword="false" />.
        </value>
            <remarks>
          If the <see cref="P:Cadenza.Maybe{T}.HasValue" /> property is
          <see langword="true" />, the value of the current 
          <see cref="T:Cadenza.Maybe{T}" /> instance can be accessed via
          the <see cref="P:Cadenza.Maybe{T}.Value" /> property.
        </remarks>
            <altmember cref="P:Cadenza.Maybe{T}.Value" />
        </member>
        <member name="F:Cadenza.Maybe`1.Nothing">
            <summary>
          Represents a <see cref="T:Cadenza.Maybe{T}" /> containing no
          value.
        </summary>
            <remarks>
                <para>
            This value is identical to <c>new Maybe&lt;T&gt;()</c> (i.e.
            creating an instance using the default constructor).
          </para>
                <para>
            This member is for "self-documenting" purposes, so that code can
            explicitly mention that it's returning "nothing".
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.op_Equality(`0Cadenza`0.`0Maybe`0{`0T`0},`0Cadenza`0.`0Maybe`0{`0T`0})">
            <param name="a">
          The first <see cref="T:Cadenza.Maybe{T}" /> to compare.
        </param>
            <param name="b">
          The second <see cref="T:Cadenza.Maybe{T}" /> to compare.
        </param>
            <summary>
          Determines whether the specified <see cref="T:Cadenza.Maybe{T}" />
          instances are equal.
        </summary>
            <returns>
                <see langword="true" /> if 
          <c><paramref name="a" />.Equals(<paramref name="b" />)</c> 
          returns <see langword="true" />; otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <block subset="none" type="note">
            See <see cref="M:Cadenza.Maybe{T}.Equals(Cadenza.Maybe`1)" />.
          </block>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.op_Inequality(`0Cadenza`0.`0Maybe`0{`0T`0},`0Cadenza`0.`0Maybe`0{`0T`0})">
            <param name="a">
          The first <see cref="T:Cadenza.Maybe{T}" /> to compare.
        </param>
            <param name="b">
          The second <see cref="T:Cadenza.Maybe{T}" /> to compare.
        </param>
            <summary>
          Determines whether the specified <see cref="T:Cadenza.Maybe{T}" />
          instances are not equal.
        </summary>
            <returns>
                <see langword="true" /> if 
          <c><paramref name="a" />.Equals(<paramref name="b" />)</c> 
          returns <see langword="false" />; otherwise, <see langword="true" />.
        </returns>
            <remarks>
                <block subset="none" type="note">
            See <see cref="M:Cadenza.Maybe{T}.Equals(Cadenza.Maybe`1)" />.
          </block>
            </remarks>
        </member>
        <member name="M:Cadenza.Maybe`1.Select``1(`0System`0.`0Func`0{`0T`0,`0TResult`0})">
            <typeparam name="TResult">
          The type of the resulting value.
        </typeparam>
            <param name="selector">
          A <see cref="T:System.Func{T,TResult}" /> which is
          used to convert <see cref="P:Cadenza.Maybe{T}.Value" />
          into the value returned.
        </param>
            <summary>
          Projects a <see cref="T:Cadenza.Maybe{T}" /> into a
          <see cref="T:Cadenza.Maybe{TResult}" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Maybe{TResult}" /> containing
          <see cref="F:Cadenza.Maybe{TResult}.Nothing" /> if 
          <see cref="P:Cadenza.Maybe{T}.HasValue" /> is <see langword="false" />,
          or if <paramref name="selector" /> returns <see langword="null" />;
          otherwise returns
          <c><paramref name="selector" />(<see langword="this" />).ToMaybe()</c>.
        </returns>
            <remarks>
                <para>
            This method is provided to support C# query comprehension
            expressions on <see cref="T:Cadenza.Maybe{T}" /> types.
          </para>
                <block subset="none" type="behavior">
                    <para>
              If <see langword="this" /> contains no value 
              (<see cref="P:Cadenza.Maybe{T}.HasValue" /> is 
              <see langword="false" />), then
              <see cref="F:Cadenza.Maybe{TResult}.Nothing" /> is returned.
            </para>
                    <para>
              Otherwise, 
              <c><paramref name="selector" />(<see langword="this" />.Value).ToMaybe()</c>
              is returned.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#Select">Assert.AreEqual (2.Just (),
	1.Just ().Select (x =&gt; x + 1));
Assert.AreEqual (2.Just (),
	from x in 1.Just ()
	select x + 1);
</code>
            </remarks>
            <altmember cref="M:Cadenza.ObjectCoda.ToMaybe``1(``0)" />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="selector" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Maybe`1.SelectMany``2(`0System`0.`0Func`0{`0T`0,`0Cadenza`0.`0Maybe`0{`0TCollection`0}},`0System`0.`0Func`0{`0T`0,`0TCollection`0,`0TResult`0})">
            <typeparam name="TCollection">
          The type of the intermediate value within 
          <paramref name="selector" />.
        </typeparam>
            <typeparam name="TResult">
          The type of the resulting value.
        </typeparam>
            <param name="selector">
          A <see cref="T:System.Func{T,Cadenza.Maybe{TCollection}}" />
          used to generate an intermediate value.
        </param>
            <param name="resultSelector">
          A <see cref="T:System.Func{T,TCollection,TResult}" /> which is
          used to convert <see cref="P:Cadenza.Maybe{T}.Value" /> and
          <c><paramref name="selector" />(<see langword="this" />).Value</c>
          into the value returned.
        </param>
            <summary>
          Projects a <see cref="T:Cadenza.Maybe{T}" /> and
          <see cref="T:Cadenza.Maybe{TCollection}" /> into a 
          <see cref="T:Cadenza.Maybe{TResult}" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Maybe{TResult}" /> containing
          <see cref="F:Cadenza.Maybe{TResult}.Nothing" /> if either
          <see langword="this" />'s 
          <see name="P:Cadenza.Maybe{T}.HasValue" /> or
          <paramref name="selector" />(<paramref name="this" />)'s 
          <see cref="P:Cadenza.Maybe{TCollection}.HasValue" /> property 
          is <see langword="false" />; otherwise, returns
          <c><paramref name="resultSelector" />(<see langword="this" />.Value,
          <paramref name="selector" />(<see langword="this" />).Value).ToMaybe()</c>.
        </returns>
            <remarks>
                <para>
            This method is provided to support C# query comprehension
            expressions on <see cref="T:Cadenza.Maybe{T}" /> types.
            <c>SelectMany</c> acts as a "null propagation of nullables" for
            any type, as opposed to just <see cref="T:System.Nullable{T}" />
            types.
          </para>
                <block subset="none" type="behavior">
                    <para>
              If <see langword="null" /> contains no value 
              (<see cref="P:Cadenza.Maybe{TSource}.HasValue" /> is 
              <see langword="false" />), then
              <see cref="F:Cadenza.Maybe{TResult}.Nothing" /> is returned.
            </para>
                    <para>
              If <paramref name="selector" />(<see langword="this" />) 
              contains no value 
              (<see cref="P:Cadenza.Maybe{TCollection}.HasValue" /> is 
              <see langword="false" />), then
              <see cref="F:Cadenza.Maybe{TResult}.Nothing" /> is returned.
            </para>
                    <para>
              Otherwise, 
              <c><paramref name="resultSelector" />(<see langword="this" />.Value,
              <paramref name="selector" />(<see langwrod="this" />).Value).ToMaybe()</c>
              is returned.  (This means that if 
              <paramref name="resultSelector" /> returns <see langword="null" />,
              then <see cref="F:Cadenza.Maybe{TResult}.Nothing" /> is
              returned.)
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza/MaybeTest.cs#SelectMany_TCollection">Assert.AreEqual (Maybe&lt;int&gt;.Nothing, 
		5.Just().SelectMany(
			x =&gt; Maybe&lt;int&gt;.Nothing,
			(x, y) =&gt; x + y));
Assert.AreEqual (Maybe&lt;int&gt;.Nothing,
		from x in 5.Just ()
		from y in Maybe&lt;int&gt;.Nothing
		select x + y);
Assert.AreEqual (9.Just (),
		5.Just().SelectMany(
			x =&gt; 4.Just (),
			(x, y) =&gt; x + y));
Assert.AreEqual (9.Just (),
		from x in 5.Just ()
		from y in 4.Just ()
		select x + y);
</code>
            </remarks>
            <altmember cref="M:Cadenza.ObjectCoda.ToMaybe``1(``0)" />
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="selector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="resultSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.Maybe`1.ToString">
            <summary>
          Returns a <see cref="T:System.String" /> representation of the 
          value of the current instance.
        </summary>
            <returns>
          If <see cref="P:Cadenza.Maybe{T}.HasValue" /> is 
          <see langword="true" />, 
          <c><see cref="P:Cadenza.Maybe{T}.Value" />.ToString()</c> is 
          returned; otherwise, 
          <see cref="F:System.String.Empty" /> is returned.
        </returns>
            <remarks>
                <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.ToString" />.
          </block>
            </remarks>
        </member>
        <member name="P:Cadenza.Maybe`1.Value">
            <summary>
          Gets the value of the current 
          <see cref="T:Cadenza.Maybe{T}" /> instance.
        </summary>
            <value>
          If <see cref="P:Cadenza.Maybe{T}.HasValue" /> is 
          <see langword="true" />, then the value of the current
          <see cref="T:Cadenza.Maybe{T}" /> instance; otherwise,
          an exception is thrown.
        </value>
            <remarks />
            <exception cref="T:System.InvalidOperationException">
                <see cref="P:Cadenza.Maybe{T}.HasValue" /> is
          <see langword="false" />, and the current 
          <see cref="T:Cadenza.Maybe{T}" /> instance contains no value.
        </exception>
            <altmember cref="P:Cadenza.Maybe{T}.HasValue" />
        </member>
        <member name="T:Cadenza.NaturalStringComparer">
            <summary>
      Provides <see cref="T:System.Collections.IComparer" /> and 
      <see cref="T:System.Collections.Generic.IComparer{System.String}" />
      implementations to sort strings in a "natural" fashion.
    </summary>
            <remarks>
                <para>
        "Natural" string comparison compares strings as humans would compare
        them, not as computers do.  Thus the string <c>"10"</c> sorts after
        <c>"2"</c>, whereas "normally" <c>"10"</c> would sort before
        <c>"2"</c> because normal string comparison works a character at a
        time, and <c>"1"</c> is before <c>"2"</c>.
      </para>
            </remarks>
            <altmember cref="M:Cadenza.Collections.IEnumerableCoda.OrderByNatural``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})" />
            <altmember cref="M:Cadenza.Collections.IEnumerableCoda.SortNatural(System.Collections.Generic.IEnumerable{System.String})" />
        </member>
        <member name="M:Cadenza.NaturalStringComparer.Compare(System.String,System.String)">
            <param name="x">
          The first <see cref="T:System.String" /> to compare.
        </param>
            <param name="y">
          The second <see cref="T:System.String" /> to compare.
        </param>
            <summary>
          Returns the sort order of two <see cref="T:System.String" /> instances.
        </summary>
            <returns>
                <para>
            The return value is a negative number, zero, or a positive number 
            reflecting the sort order of <paramref name="a" /> as compared to 
            <paramref name="b" />. For non-zero return values, the exact value 
            returned by this method is unspecified. The following table defines 
            the return value:
          </para>
                <list type="table">
                    <listheader>
                        <term>Value</term>
                        <description>Condition</description>
                    </listheader>
                    <item>
                        <term>A negative number</term>
                        <description>
                            <paramref name="a" /> &lt; <paramref name="b" />.
              </description>
                    </item>
                    <item>
                        <term>Zero</term>
                        <description>
                            <paramref name="a" /> == <paramref name="b" />.
              </description>
                    </item>
                    <item>
                        <term>A positive number</term>
                        <description>
                            <paramref name="a" /> &gt; <paramref name="b" />.
              </description>
                    </item>
                </list>
                <block subset="none" type="note">
            A null reference is considered to compare less than any other 
            non-null object, and equal to any other null reference, 
            independent of the underlying <see cref="T:System.Type" /> of 
            either object.
          </block>
            </returns>
            <remarks>
                <para>
            This method compares <paramref name="x" /> to <paramref name="y" />
            using a "natural" string comparison algorithm, so that strings
            with embedded numeric data sort by the numeric data in conjunction
            with the surrounding string, instead of treating the numeric data
            as part of the string itself.
          </para>
                <para>
            This allows <c>"foo10"</c> to sort after <c>"foo2"</c>, as is
            usually expected when looking at sorted text, instead of having
            <c>"foo10"</c> sort before <c>"foo2"</c>, as
            <see cref="T:System.Collections.Generic.Comparer{System.String}" />
            would do.
          </para>
            </remarks>
        </member>
        <member name="P:Cadenza.NaturalStringComparer.Default">
            <summary>
          Returns the default <see cref="T:Cadenza.NaturalStringComparer" /> 
          instance to use for comparing strings.
        </summary>
            <value>
          A <see cref="T:Cadenza.NaturalStringComparer" /> 
          instance to use for comparing strings.
        </value>
            <remarks>
                <para>This field is read-only.</para>
            </remarks>
        </member>
        <member name="M:Cadenza.NaturalStringComparer.System#Collections#IComparer#Compare(System.Object,System.Object)">
            <param name="x">
          The first <see cref="T:System.Object" /> to compare.
        </param>
            <param name="y">
          The second <see cref="T:System.Object" /> to compare.
        </param>
            <summary>
          Returns the sort order of two <see cref="T:System.Object" /> instances.
        </summary>
            <returns>
                <para>
            The return value is a negative number, zero, or a positive number 
            reflecting the sort order of <paramref name="a" /> as compared to 
            <paramref name="b" />. For non-zero return values, the exact value 
            returned by this method is unspecified. The following table defines 
            the return value:
          </para>
                <list type="table">
                    <listheader>
                        <term>Value</term>
                        <description>Condition</description>
                    </listheader>
                    <item>
                        <term>A negative number</term>
                        <description>
                            <paramref name="a" /> &lt; <paramref name="b" />.
              </description>
                    </item>
                    <item>
                        <term>Zero</term>
                        <description>
                            <paramref name="a" /> == <paramref name="b" />.
              </description>
                    </item>
                    <item>
                        <term>A positive number</term>
                        <description>
                            <paramref name="a" /> &gt; <paramref name="b" />.
              </description>
                    </item>
                </list>
                <block subset="none" type="note">
            A null reference is considered to compare less than any other 
            non-null object, and equal to any other null reference, 
            independent of the underlying <see cref="T:System.Type" /> of 
            either object.
          </block>
            </returns>
            <remarks>
                <para>
            This method calls 
            <see cref="M:Cadenza.NaturalStringComparer.Compare(System.String,System.String)" />,
            passing <c><paramref name="x" />.ToString()</c> and 
            <c><paramref name="y" />.ToString()</c> as arguments.
          </para>
            </remarks>
        </member>
        <member name="T:Cadenza.NullableCoda">
            <summary>
      Extension and utility methods for <see cref="T:System.Nullable{T}" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.NullableCoda.Just``1(System.Nullable{``0})">
            <typeparam name="T">
          The type to convert into a <see cref="T:Cadenza.Maybe{T}" />.
        </typeparam>
            <param name="self">
          A value of type <see cref="T:System.Nullable{T}" /> to convert into a 
          <see cref="T:Cadenza.Maybe{T}" />.
        </param>
            <summary>
          Create a new <see cref="T:Cadenza.Maybe{T}" /> instance
          initialized to a specified value.  The returned value will not be 
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </summary>
            <returns>
                <para>
            A new <see cref="T:Cadenza.Maybe{T}" /> instance
            initialized to a specified value.
          </para>
                <para>
            The returned value will not be 
            <see cref="F:Cadenza.Maybe{T}.Nothing" />.
          </para>
            </returns>
            <remarks>
                <para>
            Use this method when you want to ensure that 
            <see cref="T:Cadenza.Maybe{T}" /> instance is created in which
						<see cref="P:Cadenza.Maybe{T}.Value" /> will not throw.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />s <see cref="P:System.Nullable{T}.HasValue" />
					property is <see langword="false" />.
        </exception>
            <altmember cref="M:Cadenza.ObjectCoda.ToMaybe``1(``0)" />
        </member>
        <member name="M:Cadenza.NullableCoda.ToMaybe``1(System.Nullable{``0})">
            <typeparam name="T">
          The type to convert into a <see cref="T:Cadenza.Maybe{T}" />.
        </typeparam>
            <param name="self">
          A value of type <see cref="T:System.Nullable{T}" /> to convert into a 
          <see cref="T:Cadenza.Maybe{T}" />.
        </param>
            <summary>
          Create a new <see cref="T:Cadenza.Maybe{T}" /> instance
          initialized to a specified value.  The returned value may be 
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </summary>
            <returns>
                <para>
            A new <see cref="T:Cadenza.Maybe{T}" /> instance
            initialized to a specified value.
          </para>
                <block subset="none" type="note">
            The value returned may be 
            <see cref="F:Cadenza.Maybe{T}.Nothing" />.
          </block>
            </returns>
            <remarks>
                <para>
            Use this method when you want to ensure that a possibly invalid
            <see cref="T:Cadenza.Maybe{T}" /> instance is created.
						if <see cref="T:System.Nullable{T}.HasValue" /> is 
						<see langword="false" />, then
            <see cref="F:Cadenza.Maybe{T}.Nothing" /> will be returned;
            otherwise, a new <see cref="T:Cadenza.Maybe{T}" /> will be
            created containing the value within <paramref name="self" />.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.NullableCoda.Just``1(``0)" />
        </member>
        <member name="T:Cadenza.ObjectCoda">
            <summary>Extension methods on <see cref="T:System.Object" />.</summary>
            <remarks />
        </member>
        <member name="M:Cadenza.ObjectCoda.Just``1(``0)">
            <typeparam name="T">
          The type to convert into a <see cref="T:Cadenza.Maybe{T}" />.
        </typeparam>
            <param name="self">
          A value of type <typeparamref name="T" /> to convert into a 
          <see cref="T:Cadenza.Maybe{T}" />.
        </param>
            <summary>
          Create a new <see cref="T:Cadenza.Maybe{T}" /> instance
          initialized to a specified value.  The returned value will not be 
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </summary>
            <returns>
                <para>
            A new <see cref="T:Cadenza.Maybe{T}" /> instance
            initialized to a specified value.
          </para>
                <para>
            The returned value will not be 
            <see cref="F:Cadenza.Maybe{T}.Nothing" />.
          </para>
            </returns>
            <remarks>
                <para>
            Use this method when you want to ensure that 
            <see cref="T:Cadenza.Maybe{T}" /> instance is created in which
            <see cref="P:Cadenza.Maybe{T}.Value" /> will not throw.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <typeparamref name="T" /> is a reference type and
          <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.ObjectCoda.ToMaybe``1(``0)" />
        </member>
        <member name="M:Cadenza.ObjectCoda.Match``2(``0,System.Func{``0,Cadenza.Maybe{``1}}[])">
            <typeparam name="TSource">The source type.</typeparam>
            <typeparam name="TResult">The result type.</typeparam>
            <param name="self">
          A value of type <typeparamref name="TSource" /> to convert to 
          <typeparamref name="TResult" />.
        </param>
            <param name="matchers">
          A <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
          array containing the conversion routines to try, in order, to
          convert <paramref name="self" /> into a 
          <typeparamref name="TResult" />.
        </param>
            <summary>
          Converts the <typeparamref name="TSource" /> instance 
          <paramref name="self" /> into a <typeparamref name="TResult" />.
        </summary>
            <returns>
          A value of type <typeparamref name="TResult" />, as returned by one
          of the conversion delegates in <paramref name="matchers" />.
        </returns>
            <remarks>
                <block subset="none" type="behaviors">
                    <para>
                        <paramref name="self" /> is converted into a 
              <typeparamref name="TResult" /> instance by trying each
              <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
              within <paramref name="matchers" />.
            </para>
                    <para>
              This method returns the value of
              where <see cref="P:Cadenza.Maybe{TResult}.Value" /> 
              for the first delegate to return a
              <see cref="T:Cadenza.Maybe{TResult}" /> instance
              where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
              is <see langword="true" />.
            </para>
                    <para>
              If no 
              <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
              returns a 
              <see cref="T:Cadenza.Maybe{TResult}" /> instance
              where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
              is <see langword="true" />, then an
              <see cref="T:System.InvalidOperationException" /> is thrown.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#Match">Assert.AreEqual ("foo",
	"foo".Match (
		s =&gt; Maybe.When (s.Length != 3, "bar!"),
		s =&gt; s.Just ()));
Assert.AreEqual ("bar!",
	5.Match (
		v =&gt; Maybe.When (v != 3, "bar!"),
		v =&gt; v.ToString ().Just()));
var m = new Func&lt;string, Maybe&lt;int&gt;&gt;[] {
	v =&gt; Maybe.When (v == "bar",    1),
	v =&gt; Maybe.When (v.Length == 5, 2),
	v =&gt; (-1).Just (),
};
Assert.AreEqual (1, "bar".Match (m));
Assert.AreEqual (2, "12345".Match (m));
Assert.AreEqual (-1, "*default*".Match (m));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="matchers" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
          None of the 
          <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
          delegates within <paramref name="matchers" /> returned a 
          <see cref="T:Cadenza.Maybe{TResult}" /> instance where
          <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> was
          <see langword="true" />.
        </exception>
            <altmember cref="M:Cadenza.Maybe.When``1(System.Boolean,``0)" />
            <altmember cref="M:Cadenza.Maybe.When``1(System.Boolean,System.Func{``0})" />
        </member>
        <member name="M:Cadenza.ObjectCoda.ToMaybe``1(``0)">
            <typeparam name="T">
          The type to convert into a <see cref="T:Cadenza.Maybe{T}" />.
        </typeparam>
            <param name="self">
          A value of type <typeparamref name="T" /> to convert into a 
          <see cref="T:Cadenza.Maybe{T}" />.
        </param>
            <summary>
          Create a new <see cref="T:Cadenza.Maybe{T}" /> instance
          initialized to a specified value.  The returned value may be 
          <see cref="F:Cadenza.Maybe{T}.Nothing" />.
        </summary>
            <returns>
                <para>
            A new <see cref="T:Cadenza.Maybe{T}" /> instance
            initialized to a specified value.
          </para>
                <block subset="none" type="note">
            The value returned may be 
            <see cref="F:Cadenza.Maybe{T}.Nothing" />.
          </block>
            </returns>
            <remarks>
                <para>
            Use this method when you want to ensure that a possibly invalid
            <see cref="T:Cadenza.Maybe{T}" /> instance is created.
            If <typeparamref name="T" /> is a reference type and 
            <paramref name="self" /> is <see langword="null" />, then
            <see cref="F:Cadenza.Maybe{T}.Nothing" /> will be returned;
            otherwise, a new <see cref="T:Cadenza.Maybe{T}" /> will be
            created containing the value <paramref name="self" />.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.ObjectCoda.Just``1(``0)" />
        </member>
        <member name="M:Cadenza.ObjectCoda.TraverseBreadthFirst``2(``0,System.Func{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of the root node and intermediate nodes of the tree.
        </typeparam>
            <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
            <param name="self">
          The root of a tree to traverse.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to 
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
            <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of <paramref name="root" />
          and all intermediate non-leaf nodes.
        </param>
            <summary>
          Traverse a tree in a breadth-first fashion, converting each 
          encountered node.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the result of applying <paramref name="valueSelector" />
          to all nodes encountered while traversing the tree 
          <paramref name="self" /> in a breadth-first fashion.
        </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is the root node of a tree, wherein each 
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via 
            <paramref name="childrenSelector" />.
          </para>
                <para>
            The tree is traversed in a breadth-first fashion, each encountered
            node is provided to <paramref name="valueSelector" />, and the
            values are returned.
          </para>
            </remarks>
            <example>
                <para>
            Given the <c>TreeNode&lt;T&gt;</c> declaration:
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#TreeNode_Declaration">class TreeNode&lt;T&gt;
{
	public TreeNode ()
	{
		Children = new TreeNode&lt;T&gt; [0];
	}

	public T Value;
	public IEnumerable&lt;TreeNode&lt;T&gt;&gt; Children;
}
</code>
                <para>
                    <c>TraverseBreadthFirst()</c> is used as:
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#TraverseBreadthFirst">TreeNode&lt;int&gt; root = new TreeNode&lt;int&gt; {
	Value = 1, Children = new [] {
		new TreeNode&lt;int&gt; { Value = 2 },
		new TreeNode&lt;int&gt; {
			Value = 3, Children = new [] {
				new TreeNode&lt;int&gt; { Value = 5 },
			}
		},
		new TreeNode&lt;int&gt; { Value = 4 },
	}
};
IEnumerable&lt;int&gt; values = root
	.TraverseBreadthFirst (x =&gt; x.Value, x =&gt; x.Children);
AssertAreSame (new[]{ 1, 2, 3, 4, 5 }, values);
</code>
            </example>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.ObjectCoda.TraverseBreadthFirstWithParent``2(``0,System.Func{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of the root node and intermediate nodes of the tree.
        </typeparam>
            <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
            <param name="self">
          The root of a tree to traverse.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to 
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
            <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of <paramref name="root" />
          and all intermediate non-leaf nodes.
        </param>
            <summary>
          Traverse a tree in a breadth-first fashion, converting each 
          encountered node.
        </summary>
            <returns>
                <para>
            A <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{TSource,TResult}}" />
            in which each returned
            <see cref="P:System.Collections.Generic.KeyValuePair{TSource,TResult}.Value" />
            is the result of applying <paramref name="valueSelector" /> to a
            node, and
            <see cref="P:System.Collections.Generic.KeyValuePair{TSource,TResult}.Key" />
            holds the parent of that node.  If the node has no parent (e.g. for
            <paramref name="self" />), then 
            <see cref="P:System.Collections.Generic.KeyValuePair{TSource,TResult}.Key" />
            will contain <c>default(TSource)</c>.
          </para>
                <para>
            Returned 
            <see cref="T:System.Collections.Generic.KeyValuePair{TSource,TResult}" />
            values come from traversing <paramref name="self" /> in a
            breadth-first order.
          </para>
            </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is the root node of a tree, wherein each 
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via 
            <paramref name="childrenSelector" />.
          </para>
                <para>
            The tree is traversed in a breadth-first fashion, each encountered
            node is provided to <paramref name="valueSelector" />, and the
            values are returned.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.ObjectCoda.TraverseDepthFirst``2(``0,System.Func{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of the root node and intermediate nodes of the tree.
        </typeparam>
            <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
            <param name="self">
          The root of a tree to traverse.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to 
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
            <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of <paramref name="root" />
          and all intermediate non-leaf nodes.
        </param>
            <summary>
          Traverse a tree in a depth-first fashion, converting each 
          encountered node.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the result of applying <paramref name="valueSelector" />
          to all nodes encountered while traversing the tree 
          <paramref name="self" /> in a depth-first fashion.
        </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is the root node of a tree, wherein each 
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via 
            <paramref name="childrenSelector" />.
          </para>
                <para>
            The tree is traversed in a depth-first fashion, each encountered
            node is provided to <paramref name="valueSelector" />, and the
            values are returned.
          </para>
            </remarks>
            <example>
                <para>
            Given the <c>TreeNode&lt;T&gt;</c> declaration:
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#TreeNode_Declaration">class TreeNode&lt;T&gt;
{
	public TreeNode ()
	{
		Children = new TreeNode&lt;T&gt; [0];
	}

	public T Value;
	public IEnumerable&lt;TreeNode&lt;T&gt;&gt; Children;
}
</code>
                <para>
                    <c>TraverseDepthFirst()</c> is used as:
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#TraverseDepthFirst">TreeNode&lt;int&gt; root = new TreeNode&lt;int&gt; {
	Value = 1, Children = new [] {
		new TreeNode&lt;int&gt; { Value = 2 },
		new TreeNode&lt;int&gt; {
			Value = 3, Children = new [] {
				new TreeNode&lt;int&gt; { Value = 5 },
			}
		},
		new TreeNode&lt;int&gt; { Value = 4 },
	}
};
IEnumerable&lt;int&gt; values = root
	.TraverseDepthFirst (x =&gt; x.Value, x =&gt; x.Children);
AssertAreSame (new[]{ 1, 2, 3, 5, 4 }, values);
</code>
            </example>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.ObjectCoda.TraverseDepthFirstWithParent``2(``0,System.Func{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of the root node and intermediate nodes of the tree.
        </typeparam>
            <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
            <param name="self">
          The root of a tree to traverse.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to 
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
            <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of <paramref name="root" />
          and all intermediate non-leaf nodes.
        </param>
            <summary>
          Traverse a tree in a depth-first fashion, converting each 
          encountered node.
        </summary>
            <returns>
                <para>
            A <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{TSource,TResult}}" />
            in which each returned
            <see cref="P:System.Collections.Generic.KeyValuePair{TSource,TResult}.Value" />
            is the result of applying <paramref name="valueSelector" /> to a
            node, and
            <see cref="P:System.Collections.Generic.KeyValuePair{TSource,TResult}.Key" />
            holds the parent of that node.  If the node has no parent (e.g. for
            <paramref name="self" />), then 
            <see cref="P:System.Collections.Generic.KeyValuePair{TSource,TResult}.Key" />
            will contain <c>default(TSource)</c>.
          </para>
                <para>
            Returned 
            <see cref="T:System.Collections.Generic.KeyValuePair{TSource,TResult}" />
            values come from traversing <paramref name="self" /> in a
            breadth-first order.
          </para>
            </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is the root node of a tree, wherein each 
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via 
            <paramref name="childrenSelector" />.
          </para>
                <para>
            The tree is traversed in a depth-first fashion, each encountered
            node is provided to <paramref name="valueSelector" />, and the
            values are returned.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.ObjectCoda.With``2(``0,System.Func{``0,``1})">
            <typeparam name="TSource">The type to operate on.</typeparam>
            <typeparam name="TResult">The type to return.</typeparam>
            <param name="self">
          A <typeparamref name="TSource" /> containing the value to manipulate.
          This value may be <see langword="null" /> (unlike most other
          extension methods).
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource,TResult}" /> which will be
          invoked with <paramref name="self" /> as a parameter.
        </param>
            <summary>
          Supports chaining otherwise temporary values.
        </summary>
            <returns>
          The value of type <typeparamref name="TResult" /> returned by
          <paramref name="selector" />.
        </returns>
            <remarks>
                <para>
                    <c>With</c> is useful for easily using an intermediate value within
            an expression "chain" without requiring an explicit variable
            declaration (which is useful for reducing in-scope variables, as no
            variable is explicitly declared).
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#With">// sorts the array, then returns the 
// element in the middle of the array.
Assert.AreEqual (3,
	new[]{5, 4, 3, 2, 1}.Sort ()
	.With (c =&gt; c.ElementAt (c.Count()/2)));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="selector" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="T:Cadenza.RectangularArrayCoda">
            <summary>Extension methods on rectangular arrays.</summary>
            <remarks>
      A rectangular array is a type like <c>double[,]</c>.
    </remarks>
        </member>
        <member name="M:Cadenza.RectangularArrayCoda.Rows``1(``0[,])">
            <typeparam name="TSource">
          The array element type.
        </typeparam>
            <param name="self">
          A rectangular array of <typeparamref name="TSource" /> elements.
        </param>
            <summary>
          Converts a rectangular array into an 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />.
        </summary>
            <returns>
          An <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          of each element within <paramref name="self" /> in row-major order.
        </returns>
            <remarks>
                <para>
            This is particularly useful for transposing rectangular arrays, as
            it can be used with
            <see cref="M:Cadenza.IEnumerableCoda.Transpose``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/RectangularArrayCodaTest.cs#Rows">int[,] s = new int[,] {
	{1, 2, 3},
	{4, 5, 6},
	{7, 8, 9},
};
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; r = s.Rows();
Assert.AreEqual (3, r.Count ());

Assert.IsTrue (new[]{1,2,3}.SequenceEqual (r.ElementAt (0)));
Assert.IsTrue (new[]{4,5,6}.SequenceEqual (r.ElementAt (1)));
Assert.IsTrue (new[]{7,8,9}.SequenceEqual (r.ElementAt (2)));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="T:Cadenza.Sequence">
            <summary>
      Provides a set of static methods for creating sequences.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Sequence.Expand(System.Object)">
            <param name="o">
          A <see cref="T:System.Object" /> containing the object graph to traverse.
        </param>
            <summary>Depth-first object graph traversal.</summary>
            <returns>
          An <see cref="T:System.Collections.IEnumerable" /> containing all 
          non-<see cref="T:System.String" />, non-<see cref="T:System.Collections.IEnumerable" />
          values found while traversing <paramref name="o" /></returns>
            <remarks>
                <para>
            This is to simplify supporting 
            <see cref="M:System.Xml.Linq.XContainer.Add(System.Object)" />-style 
            enumerable traversal.
          </para>
                <para>
            If <paramref name="o" /> does not implement 
            <see cref="T:System.Collections.IEnumerable" />, then an enumerator
            which will yield <paramref name="o" /> is returned.
          </para>
                <para>
            If <paramref name="o" /> implements <c>IEnumerable</c>, then it is 
            enumerated over, and if an enumerated element implements 
            <c>IEnumerable</c>, it too is enumerated, repeatedly, until
            the enumerated element doesn't implement <c>IEnumerable</c> or
            the element is a <see cref="T:System.String" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/SequenceTest.cs#Expand">Assert.AreEqual (
	"1,2,3,4",
	Sequence.Expand (new object[]{
		Enumerable.Range (1, 2),
		"3",
		4
	}).Cast&lt;object&gt;().Implode (","));
</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Sequence.Expand(System.Object,System.Collections.Generic.IEnumerable{System.Type})">
            <param name="o">
          A <see cref="T:System.Object" /> containing the object graph to traverse.
        </param>
            <param name="except">
          A <see cref="T:System.Collections.Generic.IEnumerable{System.Type}" /> containing
          the types that, while implementing <see cref="T:System.Collections.IEnumerable" />,
          should not be traversed.  An inheritance match is used.
        </param>
            <summary>Depth-first object graph traversal.</summary>
            <returns>
          An <see cref="T:System.Collections.IEnumerable" /> containing only 
          values with types present within <paramref name="except" /> or values
          with types that do not implement <see cref="T:System.Collections.IEnumerable" />.
        </returns>
            <remarks>
                <para>
            This is to simplify supporting 
            <see cref="M:System.Xml.Linq.XContainer.Add(System.Object)" />-style 
            enumerable traversal.
          </para>
                <para>
            If <paramref name="o" /> does not implement 
            <see cref="T:System.Collections.IEnumerable" />, then an enumerator
            which will yield <paramref name="o" /> is returned.
          </para>
                <para>
            If <paramref name="o" /> implements <c>IEnumerable</c>, then it is 
            enumerated over, and if an enumerated element implements 
            <c>IEnumerable</c>, it too is enumerated, repeatedly, until either
            the enumerated element doesn't implement <c>IEnumerable</c> or
            the element's type is present within <paramref name="except" />.
            <paramref name="except" /> type matching is based on 
            <see cref="M:System.Type.IsAssignableFrom(System.Type)" />; 
            consequently, exact type matching is not performed, and inheritance
            relationships are taken into consideration.
          </para>
                <para>
            For example, if <paramref name="except" /> contains 
            <c>typeof(<see cref="T:System.Collections.ICollection" />)</c>,
            then if <paramref name="o" /> were a
            <see cref="T:System.Collections.Generic.List{System.Int32}" />
            (which implements <c>ICollection</c>), then the embedded list
            will not be further enumerated.
          </para>
                <code lang="C#" src="../../Test/Cadenza/SequenceTest.cs#Expand(IEnumerable)">IEnumerable seq = Sequence.Expand (new List&lt;int&gt; { 1, 2, 3 }, typeof (ICollection));
foreach (object v in seq)
	Assert.IsTrue (v is List&lt;int&gt;);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="except" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Sequence.Expand(System.Object,System.Type[])">
            <param name="o">
          A <see cref="T:System.Object" /> containing the object graph to traverse.
        </param>
            <param name="except">
          A <see cref="T:System.Type" /> array containing
          the types that, while implementing <see cref="T:System.Collections.IEnumerable" />,
          should not be traversed.  An inheritance match is used.
        </param>
            <summary>Depth-first object graph traversal.</summary>
            <returns>
          An <see cref="T:System.Collections.IEnumerable" /> containing only 
          values with types present within <paramref name="except" /> or values
          with types that do not implement <see cref="T:System.Collections.IEnumerable" />.
        </returns>
            <remarks>
                <para>
            This is to simplify supporting 
            <see cref="M:System.Xml.Linq.XContainer.Add(System.Object)" />-style 
            enumerable traversal.
          </para>
                <para>
            If <paramref name="o" /> does not implement 
            <see cref="T:System.Collections.IEnumerable" />, then an enumerator
            which will yield <paramref name="o" /> is returned.
          </para>
                <para>
            If <paramref name="o" /> implements <c>IEnumerable</c>, then it is 
            enumerated over, and if an enumerated element implements 
            <c>IEnumerable</c>, it too is enumerated, repeatedly, until either
            the enumerated element doesn't implement <c>IEnumerable</c> or
            the element's type is present within <paramref name="except" />.
            <paramref name="except" /> type matching is based on 
            <see cref="M:System.Type.IsAssignableFrom(System.Type)" />; 
            consequently, exact type matching is not performed, and inheritance
            relationships are taken into consideration.
          </para>
                <para>
            For example, if <paramref name="except" /> contains 
            <c>typeof(<see cref="T:System.Collections.ICollection" />)</c>,
            then if <paramref name="o" /> were a
            <see cref="T:System.Collections.Generic.List{System.Int32}" />
            (which implements <c>ICollection</c>), then the embedded list
            will not be further enumerated.
          </para>
                <code lang="C#" src="../../Test/Cadenza/SequenceTest.cs#Expand(IEnumerable)">IEnumerable seq = Sequence.Expand (new List&lt;int&gt; { 1, 2, 3 }, typeof (ICollection));
foreach (object v in seq)
	Assert.IsTrue (v is List&lt;int&gt;);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="except" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Sequence.GenerateReverse``2(``0,System.Func{``0,Cadenza.Maybe{Cadenza.Tuple{``1,``0}}})">
            <typeparam name="TSource">
          The type of the seed value.
        </typeparam>
            <typeparam name="TResult">
          The type to create a sequence of.
        </typeparam>
            <param name="value">
          A <typeparamref name="TSource" /> containing the initial value to
          pass to <paramref name="selector" />.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource,Cadenza.Maybe{Cadenza.Tuple{TResult,TSource}}}" />
          which is invoked to generate the sequence.
        </param>
            <summary>
          Creates a <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the values returned by <paramref name="selector" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the values returned by <paramref name="selector" />.
        </returns>
            <remarks>
                <para>
                    <c>GenerateReverse</c> acts as a "dual" to 
            <see cref="M:Cadenza.Collections.IEnumerableCoda.AggregateReverse``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />:
            while <c>AggregateReverse</c> reduces a list to a summary value
            (evaluating the list starting from the end),
            <c>GenerateReverse</c> builds a list from a seed value.
          </para>
                <block subset="none" type="behaviors">
                    <para>
                        <paramref name="selector" /> is first invoked with 
              <paramref name="value" />, and returns a
              <see cref="T:Cadenza.Maybe{Cadenza.Tuple{TResult,TSource}}" />.
              If the returned 
              <see cref="T:Cadenza.Maybe{Cadenza.Tuple{TResult,TSource}}" />.
              contains a value 
              (<see cref="M:Cadenza.Maybe{Cadenza.Tuple{TResult,TSource}}.HasValue" />
              is <see langword="true" />),
              then <see cref="P:Cadenza.Tuple{TResult,TSource}._1" /> will
              be returned from the generator, and 
              <see cref="P:Cadenza.Tuple{TResult,TSource}._2" /> will be
              used as the value for subsequent <paramref name="selector" />
              invocations.
            </para>
                    <para>
              When <paramref name="selector" /> returns 
              <see cref="F:Cadenza.Maybe{Cadenza.Tuple{TResult,TSource}}.Nothing" />,
              the sequence is terminated.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza/SequenceTest.cs#GenerateReverse">Assert.AreEqual ("10,9,8,7,6,5,4,3,2,1",
	Sequence.GenerateReverse (10, 
		b =&gt; Maybe.When (b &gt; 0, Tuple.Create (b, b-1)))
	.Implode (","));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="selector" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.IEnumerableCoda.AggregateReverse``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
            <altmember cref="M:Cadenza.Maybe.When``1(System.Boolean,``0)" />
            <altmember cref="M:Cadenza.Maybe.When``1(System.Boolean,System.Func{``0})" />
            <altmember cref="T:Cadenza.Tuple{TResult,TSource}" />
        </member>
        <member name="M:Cadenza.Sequence.Iterate``1(``0,System.Func{``0,``0})">
            <typeparam name="TSource">
          The type of the seed value <paramref name="value" /> and 
          the element type of the generated sequence.
        </typeparam>
            <param name="value">
          The initial value to provide to <paramref name="selector" />.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource,TSource}" /> which is used to
          generate the next value in the sequence.
        </param>
            <summary>
          Creates an infinite 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          sequence determined by <paramref name="value" />
          and <paramref name="selector" />.
        </summary>
            <returns>
          An infinite 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          sequence determined by <paramref name="value" />
          and <paramref name="selector" />.
        </returns>
            <remarks>
                <block subset="none" type="behaviors">
                    <para>
              On the first <paramref name="selector" /> invocation, 
              <paramref name="value" /> is provided as the parameter value.
            </para>
                    <para>
              For all subsequent <paramref name="selector" /> invocations, the
              parameter value is the result of the previous 
              <paramref name="selector" /> invocation.
            </para>
                    <para>
              Thus, the generated sequence is equivalent to:
              <c>new[]{ <paramref name="selector" />(<paramref name="value" />),
              <paramref name="selector" />(<paramref name="selector" />(<paramref name="value" />)),
              <paramref name="selector" />(<paramref name="selector" />(<paramref name="selector" />(<paramref name="value" />))),
              ... }</c>.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza/SequenceTest.cs#Iterate">Assert.AreEqual ("16,8,4,2,1",
		Sequence.Iterate (16, v =&gt; v / 2).Take (5).Implode (","));
Assert.AreEqual ("1,2,3,4,5",
		Sequence.Iterate (1, v =&gt; v+1).Take (5).Implode (","));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="selector" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Sequence.Repeat``1(``0)">
            <typeparam name="TSource">
          The type of the value to repeat.
        </typeparam>
            <param name="value">
          A <typeparamref name="TSource" /> containing the value to repeat.
        </param>
            <summary>
          Creates an infinite 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          seqeuence where each element value is <paramref name="value" />.
        </summary>
            <returns>
          An infinite 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          seqeuence where each element value is <paramref name="value" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/SequenceTest.cs#Repeat">Assert.AreEqual ("1,1,1,1,1",
		Sequence.Repeat (1).Take (5).Implode (","));
</code>
            </remarks>
        </member>
        <member name="T:Cadenza.StringCoda">
            <summary>
      Extension methods for <see cref="T:System.String" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.StringCoda.CaptureNamedGroups(System.String,System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <summary>
          Create a <see cref="T:System.Linq.ILookup{System.String,System.String}" />
          containing all named groups within <paramref name="regex" /> and
          the associated captured values within <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Linq.ILookup{System.String,System.String}" />
          containing all named groups within <paramref name="regex" /> and
          the associated captured values within <paramref name="self" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#CaptureNamedGroups">Assert.AreEqual ("flag=--; name=foo; value=bar",
		"--foo=bar"
		.CaptureNamedGroups (@"^(?&lt;flag&gt;--|-|/)(?&lt;name&gt;[^:=]+)((?&lt;sep&gt;[:=])(?&lt;value&gt;.*))?$")
		.With (r =&gt; "flag=" + r ["flag"].Implode () + 
			"; name=" + r ["name"].Implode () +
			"; value=" + r ["value"].Implode ()));
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:Cadenza.StringCoda.CaptureNamedGroups(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <param name="options">
          A <see cref="T:System.Text.RegularExpressions.RegexOptions" />
          containing options to control the regular expression.
        </param>
            <summary>
          Create a <see cref="T:System.Linq.ILookup{System.String,System.String}" />
          containing all named groups within <paramref name="regex" /> and
          the associated captured values within <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Linq.ILookup{System.String,System.String}" />
          containing all named groups within <paramref name="regex" /> and
          the associated captured values within <paramref name="self" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#CaptureNamedGroups">Assert.AreEqual ("flag=--; name=foo; value=bar",
		"--foo=bar"
		.CaptureNamedGroups (@"^(?&lt;flag&gt;--|-|/)(?&lt;name&gt;[^:=]+)((?&lt;sep&gt;[:=])(?&lt;value&gt;.*))?$")
		.With (r =&gt; "flag=" + r ["flag"].Implode () + 
			"; name=" + r ["name"].Implode () +
			"; value=" + r ["value"].Implode ()));
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="options" /> contains an invalid flag.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Captures(System.String,System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <summary>
          Create a <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all captured values within <paramref name="self" /> that 
          match the regular expression <paramref name="regex" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all captured values within <paramref name="self" /> that 
          match the regular expression <paramref name="regex" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Captures">Assert.IsTrue (
		new[]{"a", "b", "c", "d"}.SequenceEqual (
			"a - b - c - d".Captures (@"(\w+)")));
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Captures(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <param name="options">
          A <see cref="T:System.Text.RegularExpressions.RegexOptions" />
          containing options to control the regular expression.
        </param>
            <summary>
          Create a <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all captured values within <paramref name="self" /> that 
          match the regular expression <paramref name="regex" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all captured values within <paramref name="self" /> that 
          match the regular expression <paramref name="regex" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Captures">Assert.IsTrue (
		new[]{"a", "b", "c", "d"}.SequenceEqual (
			"a - b - c - d".Captures (@"(\w+)")));
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="options" /> contains an invalid flag.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.IsNullOrWhitespace(System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to check to see if it is
          <see langword="null" /> or contains only whitespace characters.
        </param>
            <summary>
          Indicates whether <paramref name="self" /> is a
          <see langword="null" /> or contains only whitespace.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="self" />
          is <see langword="null" /> or contains only
          whitespace; otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#IsNullOrWhitespace">string s = null;
Assert.IsTrue (s.IsNullOrWhitespace());
Assert.IsTrue ("".IsNullOrWhitespace());
Assert.IsTrue ("    ".IsNullOrWhitespace());
Assert.IsFalse ("foo".IsNullOrWhitespace());
</code>
            </remarks>
            <altmember cref="M:System.String.Trim" />
        </member>
        <member name="M:Cadenza.StringCoda.Lines(System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to read lines from.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all lines of text from <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all lines of text from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <block subset="none" type="note">
            A "line of text" is the same as that used by 
            <see cref="M:Cadenza.TextReaderCoda.Lines(System.IO.TextReader)" />.
          </block>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Lines">Assert.IsTrue (new[]{"one", "two", "three"}
		.SequenceEqual ("one\ntwo\nthree".Lines ()));
</code>
            </remarks>
            <altmember cref="M:Cadenza.TextReaderCoda.Lines(System.IO.TextReader)" />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Matches(System.String,System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <summary>
          Create a <see cref="T:System.Collections.Generic.IEnumerable{System.Text.RegularExpressions.Match}" />
          containing all <see cref="T:System.Text.RegularExpressions.Match" />ed
          text within <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{System.Text.RegularExpressions.Match}" />
          containing all <see cref="T:System.Text.RegularExpressions.Match" />ed
          text within <paramref name="self" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Matches">string match = @"a - b
c - d
e - f";

Match[] matches = match.Matches (@"\w+ - \w+").ToArray();
Assert.AreEqual (3, matches.Length);
Assert.AreEqual ("a - b", matches [0].Value);
Assert.AreEqual ("c - d", matches [1].Value);
Assert.AreEqual ("e - f", matches [2].Value);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Matches(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <param name="options">
          A <see cref="T:System.Text.RegularExpressions.RegexOptions" />
          containing options to control the regular expression.
        </param>
            <summary>
          Create a <see cref="T:System.Collections.Generic.IEnumerable{System.Text.RegularExpressions.Match}" />
          containing all <see cref="T:System.Text.RegularExpressions.Match" />ed
          text within <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{System.Text.RegularExpressions.Match}" />
          containing all <see cref="T:System.Text.RegularExpressions.Match" />ed
          text within <paramref name="self" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Matches">string match = @"a - b
c - d
e - f";

Match[] matches = match.Matches (@"\w+ - \w+").ToArray();
Assert.AreEqual (3, matches.Length);
Assert.AreEqual ("a - b", matches [0].Value);
Assert.AreEqual ("c - d", matches [1].Value);
Assert.AreEqual ("e - f", matches [2].Value);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="options" /> contains an invalid flag.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.MatchValues(System.String,System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <summary>
          Create a <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all text within <paramref name="self" /> that matches
          <paramref name="regex" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all text within <paramref name="self" /> that matches
          <paramref name="regex" />.
        </returns>
            <remarks>
                <para>
            This differs from
            <see cref="M:Cadenza.StringCoda.Captures(System.String,System.String)" />
            in that no captures (parenthesis) are required within 
            <paramref name="regex" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#MatchValues">string match = @"a - b
c - d
e - f";

string[] expected = {"a - b", "c - d", "e - f"};
string[] actual = match.MatchValues(@"\w+ - \w+").ToArray();

AssertAreSame (expected, actual);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
        </member>
        <member name="M:Cadenza.StringCoda.MatchValues(System.String,System.String,System.Text.RegularExpressions.RegexOptions)">
            <param name="self">
          A <see cref="T:System.String" /> to apply a regular expression to.
        </param>
            <param name="regex">
          A <see cref="T:System.String" /> containing the regular expression
          to match <paramref name="self" /> against.
        </param>
            <param name="options">
          A <see cref="T:System.Text.RegularExpressions.RegexOptions" />
          containing options to control the regular expression.
        </param>
            <summary>
          Create a <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all text within <paramref name="self" /> that matches
          <paramref name="regex" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing all text within <paramref name="self" /> that matches
          <paramref name="regex" />.
        </returns>
            <remarks>
                <para>
            This differs from
            <see cref="M:Cadenza.StringCoda.Captures(System.String,System.String)" />
            in that no captures (parenthesis) are required within 
            <paramref name="regex" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#MatchValues">string match = @"a - b
c - d
e - f";

string[] expected = {"a - b", "c - d", "e - f"};
string[] actual = match.MatchValues(@"\w+ - \w+").ToArray();

AssertAreSame (expected, actual);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          Regular expression parsing error.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" /></para>
                <para>
            -or-
          </para>
                <para>
                    <paramref name="regex" /> is <see langword="null" /></para>
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="options" /> contains an invalid flag.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Remove(System.String,System.String[])">
            <param name="self">
          A <see cref="T:System.String" /> to remove all occurrences of all
          elements within <paramref name="targets" />.
        </param>
            <param name="targets">
          A <see cref="T:System.String" /> array containing the strings to
          remove from <paramref name="self " />.
        </param>
            <summary>
          Deletes all strings within <paramref name="targets" /> from
          <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.String" /> instance in which all strings
          within <paramref name="targets " /> have been removed.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Remove">Assert.AreEqual (" Bar ", "Foo Bar Monkeys".Remove ("Foo", "Monkeys"));
Assert.AreEqual (" Bar ", "Foo Bar Foo".Remove ("Foo"));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="targets" /> is
          <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Slice(System.String,System.Int32,System.Int32)">
            <param name="self">
          A <see cref="T:System.String" /> containing the string to 
          substring.
        </param>
            <param name="start">
          A <see cref="T:System.Int32" /> containing the start index of the
          new <see cref="T:System.String" /> to create.
        </param>
            <param name="end">
          A <see cref="T:System.Int32" /> containing the end index of the
          new <see cref="T:System.String" /> to create.
        </param>
            <summary>
          Creates a new <see cref="T:System.String" /> of 
          <paramref name="self" /> using indexes of the start and end
          position.
        </summary>
            <returns>
          A new <see cref="T:System.String" /> of <paramref name="self" /> 
          using indexes of the start and end position.
        </returns>
            <remarks>
                <para>
            This differs from 
            <see cref="T:System.String.Substring(System.Int32,System.Int32)" />
            in that <paramref name="start" /> and <paramref name="end" /> are
            both string indexes, while the <paramref name="length" />
            parameter in <c>Substring</c> is not an index.
          </para>
                <para>
            If <paramref name="end" /> is negative, then it is taken as a 
            value from the end of the string.
          </para>
                <para>
            When <paramref name="end" /> is positive, this is equivalent to
            <c>self.Substring (start, end - start)</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Slice">var data = "0123456789";

Assert.AreEqual ("0",       data.Slice (0, 1));
Assert.AreEqual ("89",      data.Slice (8, 10));
Assert.AreEqual ("456789",  data.Slice (4, -1));
Assert.AreEqual ("8",       data.Slice (8, -2));
Assert.AreEqual ("",        data.Slice (data.Length, data.Length));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <para>
                    <paramref name="start" /> is negative
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="start" /> is greater than or equal to 
            <c><paramref name="self" />.Length</c>.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="end" /> is greater than or equal to 
            <c><paramref name="self" />.Length</c>.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.StringCoda.ToEnum``1(System.String)">
            <typeparam name="TEnum">
          An enumeration type containing the member stored in 
          <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.String" /> containing an enumeration value to
          convert into that enumeration value.
        </param>
            <summary>
          Converts a <see cref="T:System.String" /> into an enumeration value
          of type <typeparamref name="TEnum" />.
        </summary>
            <returns>
          A <typeparamref name="TEnum" /> value containing the value named by
          <paramref name="self" />.
        </returns>
            <remarks>
                <block subset="none" type="note">
            This probabably doesn't properly support
            <see cref="T:System.FlagsAttribute" /> enums...
          </block>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#ToEnum">Assert.AreEqual (Foo.Gazonk, "Gazonk".ToEnum&lt;Foo&gt; ());
Assert.AreEqual (Foo.Bar,    "Bar".ToEnum&lt;Foo&gt; ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Tokens(System.String,System.Func{System.Nullable{System.Char},System.Char,System.Boolean}[])">
            <param name="self">
          A <see cref="T:System.String" /> to extract tokens from.
        </param>
            <param name="categories">
          A
					<see cref="T:System.Func{System.Nullable{System.Char},System.Char,System.Boolean}" />
					array containing the different categories of characters that 
					determines what makes up a "token."  If the 
					<see cref="T:System.Nullable{System.Char}" /> parameter is 
					<see langword="null" />, then the <see cref="T:System.Char" /> is
					the first character within the token; otherwise, the
					<see cref="T:System.Nullable{System.Char}" /> parameter contains the
					character preceding the <see cref="T:System.Char" />.
					The delegate should return <see langword="true" /> if the
					<see cref="T:System.Char" /> is a supported character; otherwise,
					<see langword="false" /> should be returned.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all tokens from <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all tokens from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <block subset="none" type="note">
                    <para>
              A "token" is determined by <paramref name="categories" />, and
							is any contiguous sequence of characters for which the
              same <paramref name="categories" /> index returns 
              <see langword="true" />, starting from the first delegate.  This
              allows a "some characters are more important than others"
              philosphy, allowing e.g. parenthesis to be returned separately
              from alphanumeric characters, even if no whitespace separates
              them.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Tokens">string[] expected = {"(", "hello", ",", "world", "!)"};
string[] actual = "(hello, world!)"
	.Tokens (
			(p, c) =&gt; char.IsLetterOrDigit (c), // words
			(p, c) =&gt; !char.IsWhiteSpace (c)    // non-space
	).ToArray ();
AssertAreSame (expected, actual);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="categories" /> is empty.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />, or
          <paramref name="categories" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.Words(System.String)">
            <param name="self">
          A <see cref="T:System.String" /> to extract words from.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <block subset="none" type="note">
            A "word" any contiguous series of characters for which
            <see cref="M:System.Char.IsWhiteSpace(System.Char)" />
            returns <see langword="false" />.
          </block>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#Words">string[] expected = {"skip", "leading", "and", "trailing", "whitespace"};
string[] actual = 
	"   skip  leading\r\n\tand trailing\vwhitespace   "
	.Words ().ToArray ();
AssertAreSame (expected, actual);
</code>
            </remarks>
            <altmember cref="M:Cadenza.TextReaderCoda.Words(System.IO.TextReader)" />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.WrappedLines(System.String,System.Collections.Generic.IEnumerable{System.Int32})">
            <param name="self">
          A <see cref="T:System.String" /> to split into segments no longer
          than lenghts in the <paramref name="widths" /> sequence.
        </param>
            <param name="widths">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing the maximum lengths
          to use for corresponding returned segments.  The last value in this
          array is used for all remaining segments.
        </param>
            <summary>
          Splits a string into line segments with a maximum length constrained
          by <paramref name="widths" />.
        </summary>
            <returns>
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing segments from <paramref name="self" /> with a length
          no longer than entries from <paramref name="widths" />.
        </returns>
            <remarks>
                <para>
            This is a "DWIM"-style interface for line wrapping.
          </para>
                <para>
                    <c>WrappedLines()</c> is oriented toward
            <see cref="T:System.Console" />-style output in which line widths
            are controlled by the number of characters (i.e. fixed-width fonts,
            not proportional fonts).  <paramref name="widths" /> is used
            to constrain the length of each corresponding segment within the
            returned
            <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />.
            For example, the first string segment returned will have a length
            no longer than the first element in <paramref name="widths" />,
            the second string segment returned will have a length no longer
            than the second element in <paramref name="widths" />, etc.
            The last element in <paramref name="widths" /> is used to constrain
            the lenghts of all remaining string segments; thus, if
            <paramref name="widths" /> has only one element, that value is
            used to constrain all returned string segments.
          </para>
                <para>
            Note that <paramref name="widths" /> constrains the width of
            segments; a segment may be shorter, and may be empty.
          </para>
                <para>
            String splitting is done as follows:
          </para>
                <list type="number">
                    <item>
                        <term>
                Determine the <c>width</c>to use for the current segment by
                getting a value from <paramref name="widths" />.  If
                <paramref name="widths" /> is empty, then the maximum
                segment length is <see cref="F:System.Int32.MaxValue" />.
                If there is no remaining value in <paramref name="widths" />,
                use the last width value found.
              </term>
                    </item>
                    <item>
                        <term>
                Beginning at index <c>i</c> within <paramref name="self" />
                (starting at index <c>0</c>), look for all "end-of-line
                characters" -- characters for which
                <see cref="M:System.Char.IsLetterOrDigit(System.Char)" />
                returns <see langword="false" />, thus including punctuation,
                whitespace, etc. --
                from <c>self[i]</c> until <c>self[i+width]</c>.
                If a newline is found, return the segment starting from index
                <c>i</c> until the first newline position.  If no newline
                is found but an end-of-line character is is found, return a
                segment starting from index <c>i</c> until the last end-of-line
                character. If no end-of-line character is found within
                <c>self[i]</c> until <c>self[i+width]</c>, create a segment from
                <c>self[i]</c> until <c>self[i+width-1]</c>, and append
                <c>'-'</c> to the segment as a line-continuation character.
              </term>
                    </item>
                    <item>
                        <term>
                Repeat steps 1-2 until the end of the string is encountered.
              </term>
                    </item>
                </list>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#WrappedLines">// Notice that the first width is 50, but the actual returned length is 17.
// This is because the newline is encountered first.
// The width of 48 is used to constrain all remaining lines, causing
// the 4th line to require line-wrapping.
//
// Notice also that all embedded '\n's are removed.
IEnumerable&lt;string&gt; wrappedLines =
		("This has a really\n" +
		 "long, multi-line description that also\n" +
		 "tests\n" +
		 "the-builtin-supercalifragilisticexpialidicious-break-on-hyphen.  " +
		 "Also, a list:\n" +
		 "  item 1\n" +
		 "  item 2")
		.WrappedLines (50, 48);
Assert.IsTrue (new[]{
		"This has a really",
		"long, multi-line description that also",
		"tests",
		"the-builtin-supercalifragilisticexpialidicious-",
		"break-on-hyphen.  Also, a list:",
		"  item 1",
		"  item 2",
}.SequenceEqual (wrappedLines));

// Another example where the text has no whitespace before the
// constrained width.
wrappedLines =
	"IWantThisDescriptionToBreakInsideAWordGeneratingAutoWordHyphenation."
	.WrappedLines (50, 4, 5, 12);
Assert.IsTrue (new[]{
		"IWantThisDescriptionToBreakInsideAWordGeneratingA-", // length=50
		"uto-",                                               // length=4
		"Word-",                                              // length=5
		"Hyphenation.",                                       // length=12
}.SequenceEqual (wrappedLines));

// Notice that '.' is treated as an end-of-line character
wrappedLines =
	"OnlyOnePeriod.AndNoWhitespaceShouldBeSupportedEvenWithLongDescriptions"
	.WrappedLines (50, 48);
Assert.IsTrue (new[]{
		"OnlyOnePeriod.",
		"AndNoWhitespaceShouldBeSupportedEvenWithLongDes-",
		"criptions",
}.SequenceEqual (wrappedLines));

wrappedLines =
	"Lots of spaces in the middle 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 and more until the end."
	.WrappedLines (50, 48);
Assert.IsTrue (new []{
		"Lots of spaces in the middle 1 2 3 4 5 6 7 8 9 0",
		"1 2 3 4 5 and more until the end.",
}.SequenceEqual (wrappedLines));

wrappedLines =
	"Lots of spaces in the middle - . - . - . - . - . - . - . - and more until the end."
	.WrappedLines (50, 48);
Assert.IsTrue (new[]{
		"Lots of spaces in the middle - . - . - . - . - . -",
		" . - . - and more until the end.",
}.SequenceEqual (wrappedLines));

// An ~infinite sequence of widths
wrappedLines =
	"1121231234123451234561234567123456781234567891234567890"
	.WrappedLines (Sequence.Iterate(2, v =&gt; v + 1));
Assert.IsTrue (new[]{
		"1-",
		"12-",
		"123-",
		"1234-",
		"12345-",
		"123456-",
		"1234567-",
		"12345678-",
		"123456789-",
		"1234567890",
}.SequenceEqual (wrappedLines));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="widths" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="widths" /> contains a value that is less than 2.
        </exception>
        </member>
        <member name="M:Cadenza.StringCoda.WrappedLines(System.String,System.Int32[])">
            <param name="self">
          A <see cref="T:System.String" /> to split into segments no longer
          than lenghts in the <paramref name="widths" /> sequence.
        </param>
            <param name="widths">
          A <see cref="T:System.Int32" /> array containing the maximum lengths
          to use for corresponding returned segments.  The last value in this
          array is used for all remaining segments.
        </param>
            <summary>
          Splits a string into line segments with a maximum length constrained
          by <paramref name="widths" />.
        </summary>
            <returns>
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing segments from <paramref name="self" /> with a length
          no longer than entries from <paramref name="widths" />.
        </returns>
            <remarks>
                <para>
            This is a "DWIM"-style interface for line wrapping.
          </para>
                <para>
                    <c>WrappedLines()</c> is oriented toward
            <see cref="T:System.Console" />-style output in which line widths
            are controlled by the number of characters (i.e. fixed-width fonts,
            not proportional fonts).  <paramref name="widths" /> is used
            to constrain the length of each corresponding segment within the
            returned
            <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />.
            For example, the first string segment returned will have a length
            no longer than the first element in <paramref name="widths" />,
            the second string segment returned will have a length no longer
            than the second element in <paramref name="widths" />, etc.
            The last element in <paramref name="widths" /> is used to constrain
            the lenghts of all remaining string segments; thus, if
            <paramref name="widths" /> has only one element, that value is
            used to constrain all returned string segments.
          </para>
                <para>
            Note that <paramref name="widths" /> constrains the width of
            segments; a segment may be shorter, and may be empty.
          </para>
                <para>
            String splitting is done as follows:
          </para>
                <list type="number">
                    <item>
                        <term>
                Determine the <c>width</c>to use for the current segment by
                getting a value from <paramref name="widths" />.  If
                <paramref name="widths" /> is empty, then the maximum
                segment length is <see cref="F:System.Int32.MaxValue" />.
                If there is no remaining value in <paramref name="widths" />,
                use the last width value found.
              </term>
                    </item>
                    <item>
                        <term>
                Beginning at index <c>i</c> within <paramref name="self" />
                (starting at index <c>0</c>), look for all "end-of-line
                characters" -- characters for which
                <see cref="M:System.Char.IsLetterOrDigit(System.Char)" />
                returns <see langword="false" />, thus including punctuation,
                whitespace, etc. --
                from <c>self[i]</c> until <c>self[i+width]</c>.
                If a newline is found, return the segment starting from index
                <c>i</c> until the first newline position.  If no newline
                is found but an end-of-line character is is found, return a
                segment starting from index <c>i</c> until the last end-of-line
                character. If no end-of-line character is found within
                <c>self[i]</c> until <c>self[i+width]</c>, create a segment from
                <c>self[i]</c> until <c>self[i+width-1]</c>, and append
                <c>'-'</c> to the segment as a line-continuation character.
              </term>
                    </item>
                    <item>
                        <term>
                Repeat steps 1-2 until the end of the string is encountered.
              </term>
                    </item>
                </list>
                <code lang="C#" src="../../Test/Cadenza/StringCodaTest.cs#WrappedLines">// Notice that the first width is 50, but the actual returned length is 17.
// This is because the newline is encountered first.
// The width of 48 is used to constrain all remaining lines, causing
// the 4th line to require line-wrapping.
//
// Notice also that all embedded '\n's are removed.
IEnumerable&lt;string&gt; wrappedLines =
		("This has a really\n" +
		 "long, multi-line description that also\n" +
		 "tests\n" +
		 "the-builtin-supercalifragilisticexpialidicious-break-on-hyphen.  " +
		 "Also, a list:\n" +
		 "  item 1\n" +
		 "  item 2")
		.WrappedLines (50, 48);
Assert.IsTrue (new[]{
		"This has a really",
		"long, multi-line description that also",
		"tests",
		"the-builtin-supercalifragilisticexpialidicious-",
		"break-on-hyphen.  Also, a list:",
		"  item 1",
		"  item 2",
}.SequenceEqual (wrappedLines));

// Another example where the text has no whitespace before the
// constrained width.
wrappedLines =
	"IWantThisDescriptionToBreakInsideAWordGeneratingAutoWordHyphenation."
	.WrappedLines (50, 4, 5, 12);
Assert.IsTrue (new[]{
		"IWantThisDescriptionToBreakInsideAWordGeneratingA-", // length=50
		"uto-",                                               // length=4
		"Word-",                                              // length=5
		"Hyphenation.",                                       // length=12
}.SequenceEqual (wrappedLines));

// Notice that '.' is treated as an end-of-line character
wrappedLines =
	"OnlyOnePeriod.AndNoWhitespaceShouldBeSupportedEvenWithLongDescriptions"
	.WrappedLines (50, 48);
Assert.IsTrue (new[]{
		"OnlyOnePeriod.",
		"AndNoWhitespaceShouldBeSupportedEvenWithLongDes-",
		"criptions",
}.SequenceEqual (wrappedLines));

wrappedLines =
	"Lots of spaces in the middle 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 and more until the end."
	.WrappedLines (50, 48);
Assert.IsTrue (new []{
		"Lots of spaces in the middle 1 2 3 4 5 6 7 8 9 0",
		"1 2 3 4 5 and more until the end.",
}.SequenceEqual (wrappedLines));

wrappedLines =
	"Lots of spaces in the middle - . - . - . - . - . - . - . - and more until the end."
	.WrappedLines (50, 48);
Assert.IsTrue (new[]{
		"Lots of spaces in the middle - . - . - . - . - . -",
		" . - . - and more until the end.",
}.SequenceEqual (wrappedLines));

// An ~infinite sequence of widths
wrappedLines =
	"1121231234123451234561234567123456781234567891234567890"
	.WrappedLines (Sequence.Iterate(2, v =&gt; v + 1));
Assert.IsTrue (new[]{
		"1-",
		"12-",
		"123-",
		"1234-",
		"12345-",
		"123456-",
		"1234567-",
		"12345678-",
		"123456789-",
		"1234567890",
}.SequenceEqual (wrappedLines));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="widths" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="widths" /> contains a value that is less than 2.
        </exception>
        </member>
        <member name="T:Cadenza.Tuple">
            <summary>
            Utility methods to create Tuple instances.
            </summary>
            <remarks>
                <para>
            Provides a set of <see cref="M:Cadenza.Tuple.Create" /> methods so that
            C# type inferencing can easily be used with tuples.  For example,
            instead of:
            </para>
                <code lang="C#">
            Tuple&lt;int, long&gt; a = new Tuple&lt;int, long&gt; (1, 2L);</code>
                <para>You can instead write:</para>
                <code lang="C#">
            Tuple&lt;int, long&gt; b = Tuple.Create (1, 2L);
            // or
            var              c = Tuple.Create (1, 2L);</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple.Create``1(``0)">
            <typeparam name="T">
            The first <see cref="T:Cadenza.Tuple{T}" /> value type.
            </typeparam>
            <param name="item1">
            The first <see cref="T:Cadenza.Tuple{T}" /> value.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Tuple{T}" />.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Tuple{T}" /> initialized with the parameter values.
            </returns>
            <remarks>To be added.</remarks>
            <altmember cref="C:Cadenza.Tuple{T}(`0)" />
        </member>
        <member name="M:Cadenza.Tuple.Create``2(``0,``1)">
            <typeparam name="T1">
            The first <see cref="T:Cadenza.Tuple{T1,T2}" /> value type.
            </typeparam>
            <typeparam name="T2">
            The second <see cref="T:Cadenza.Tuple{T1,T2}" /> value type.
            </typeparam>
            <param name="item1">
            The first <see cref="T:Cadenza.Tuple{T1,T2}" /> value.
            </param>
            <param name="item2">
            The second <see cref="T:Cadenza.Tuple{T1,T2}" /> value.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Tuple{T1,T2}" />.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Tuple{T1,T2}" /> initialized with the parameter values.
            </returns>
            <remarks>To be added.</remarks>
            <altmember cref="C:Cadenza.Tuple{T1,T2}(`0,`1)" />
        </member>
        <member name="M:Cadenza.Tuple.Create``3(``0,``1,``2)">
            <typeparam name="T1">
            The first <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> value type.
            </typeparam>
            <typeparam name="T2">
            The second <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> value type.
            </typeparam>
            <typeparam name="T3">
            The third <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> value type.
            </typeparam>
            <param name="item1">
            The first <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> value.
            </param>
            <param name="item2">
            The second <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> value.
            </param>
            <param name="item3">
            The third <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> value.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Tuple{T1,T2,T3}" />.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> initialized with the parameter values.
            </returns>
            <remarks>To be added.</remarks>
            <altmember cref="C:Cadenza.Tuple{T1,T2,T3}(`0,`1,`2)" />
        </member>
        <member name="M:Cadenza.Tuple.Create``4(``0,``1,``2,``3)">
            <typeparam name="T1">
            The first <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value type.
            </typeparam>
            <typeparam name="T2">
            The second <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value type.
            </typeparam>
            <typeparam name="T3">
            The third <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value type.
            </typeparam>
            <typeparam name="T4">
            The fourth <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value type.
            </typeparam>
            <param name="item1">
            The first <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value.
            </param>
            <param name="item2">
            The second <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value.
            </param>
            <param name="item3">
            The third <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value.
            </param>
            <param name="item4">
            The fourth <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> value.
            </param>
            <summary>
            Creates a <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" />.
            </summary>
            <returns>
            A <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> initialized with the parameter values.
            </returns>
            <remarks>To be added.</remarks>
            <altmember cref="C:Cadenza.Tuple{T1,T2,T3,T4}(`0,`1,`2,`3)" />
        </member>
        <member name="P:Cadenza.Tuple.MaxValues">
            <summary>
            The maximum number of Tuple types provided.
            </summary>
            <value>
            The maximum number of Tuple types provided.
            </value>
            <remarks>
                <para>
            Only tuples up to a certain "arity" are supported; for example,
            a <c>Tuple&lt;T1, T2, ..., T100&gt;</c> isn't supported (and won't
            likely ever be).
            </para>
                <para>
                    <see cref="P:Cadenza.Tuple.MaxValues" /> is the maximum number of
            values that the Tuple types support.  If you need to support
            more values, then you need to either live with potential boxing
            and use a e.g. <see cref="T:System.Collections.Generic.List{System.Object}" />
            or nest Tuple instantiations, e.g.
            <c>Tuple&lt;int, Tuple&lt;int, Tuple&lt;int, Tuple&lt;int, int&gt;&gt;&gt;&gt;</c>.
            The problem with such nesting is that it becomes "unnatural" to access
            later elements -- <c>t._2._2._2._2</c> to access the fifth value for
            the previous example.
            </para>
            </remarks>
        </member>
        <member name="T:Cadenza.Tuple`1">
            <typeparam name="T">
            The first value type.
            </typeparam>
            <summary>
            A strongly-typed sequence of 1 variously typed values.
            </summary>
            <remarks>
                <para>
            A <c>Tuple</c> is an immutable, strongly typed sequence of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position.
            </para>
            </remarks>
        </member>
        <member name="C:Cadenza.Tuple`1(`0T`0)">
            <param name="item1">
            A <typeparamref name="T" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T}.Item1" /> property.
            </param>
            <summary>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T}" /> instance.
            </summary>
            <remarks>
                <para>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T}" /> instance.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`1.Equals(`0System`0.`0Object`0)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Tuple{T}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`1.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`1.Item1">
            <summary>
            The first tuple value.
            </summary>
            <value>
            A <typeparamref name="T" /> which is the first tuple value.
            </value>
            <remarks>
            The first tuple value.
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> representation of the value of the current instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> representation of the value of the current instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Returns <c>(</c>, followed by a comma-separated list of the result of
            calling <see cref="M:System.Object.ToString" /> on
            <see cref="P:Cadenza.Tuple{T}.Item1" />,
            followed by <c>)</c>.
            </block>
                </para>
            </remarks>
        </member>
        <member name="T:Cadenza.Tuple`2">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <summary>
            A strongly-typed sequence of 2 variously typed values.
            </summary>
            <remarks>
                <para>
            A <c>Tuple</c> is an immutable, strongly typed sequence of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position.
            </para>
            </remarks>
        </member>
        <member name="C:Cadenza.Tuple`2(``10T1`1``10`1,``10T2`1``10`1)">
            <param name="item1">
            A <typeparamref name="T1" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2}.Item1" /> property.
            </param>
            <param name="item2">
            A <typeparamref name="T2" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2}.Item2" /> property.
            </param>
            <summary>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T1,T2}" /> instance.
            </summary>
            <remarks>
                <para>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T1,T2}" /> instance.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`2.Equals(``10System`1``10`1.``10Object`1``10`1)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Tuple{T1,T2}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`2.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`2.Item1">
            <summary>
            The first tuple value.
            </summary>
            <value>
            A <typeparamref name="T1" /> which is the first tuple value.
            </value>
            <remarks>
            The first tuple value.
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`2.Item2">
            <summary>
            The second tuple value.
            </summary>
            <value>
            A <typeparamref name="T2" /> which is the second tuple value.
            </value>
            <remarks>
            The second tuple value.
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`2.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> representation of the value of the current instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> representation of the value of the current instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Returns <c>(</c>, followed by a comma-separated list of the result of
            calling <see cref="M:System.Object.ToString" /> on
            <see cref="P:Cadenza.Tuple{T1,T2}.Item1" />,
            <see cref="P:Cadenza.Tuple{T1,T2}.Item2" />,
            followed by <c>)</c>.
            </block>
                </para>
            </remarks>
        </member>
        <member name="T:Cadenza.Tuple`3">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <summary>
            A strongly-typed sequence of 3 variously typed values.
            </summary>
            <remarks>
                <para>
            A <c>Tuple</c> is an immutable, strongly typed sequence of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position.
            </para>
            </remarks>
        </member>
        <member name="C:Cadenza.Tuple`3(```210T1`2``21`2```210`2``21`2,```210T2`2``21`2```210`2``21`2,```210T3`2``21`2```210`2``21`2)">
            <param name="item1">
            A <typeparamref name="T1" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3}.Item1" /> property.
            </param>
            <param name="item2">
            A <typeparamref name="T2" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3}.Item2" /> property.
            </param>
            <param name="item3">
            A <typeparamref name="T3" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3}.Item3" /> property.
            </param>
            <summary>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> instance.
            </summary>
            <remarks>
                <para>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> instance.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`3.Equals(```210System`2``21`2```210`2``21`2.```210Object`2``21`2```210`2``21`2)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`3.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`3.Item1">
            <summary>
            The first tuple value.
            </summary>
            <value>
            A <typeparamref name="T1" /> which is the first tuple value.
            </value>
            <remarks>
            The first tuple value.
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`3.Item2">
            <summary>
            The second tuple value.
            </summary>
            <value>
            A <typeparamref name="T2" /> which is the second tuple value.
            </value>
            <remarks>
            The second tuple value.
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`3.Item3">
            <summary>
            The third tuple value.
            </summary>
            <value>
            A <typeparamref name="T3" /> which is the third tuple value.
            </value>
            <remarks>
            The third tuple value.
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`3.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> representation of the value of the current instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> representation of the value of the current instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Returns <c>(</c>, followed by a comma-separated list of the result of
            calling <see cref="M:System.Object.ToString" /> on
            <see cref="P:Cadenza.Tuple{T1,T2,T3}.Item1" />,
            <see cref="P:Cadenza.Tuple{T1,T2,T3}.Item2" />,
            <see cref="P:Cadenza.Tuple{T1,T2,T3}.Item3" />,
            followed by <c>)</c>.
            </block>
                </para>
            </remarks>
        </member>
        <member name="T:Cadenza.Tuple`4">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="T4">
            The fourth value type.
            </typeparam>
            <summary>
            A strongly-typed sequence of 4 variously typed values.
            </summary>
            <remarks>
                <para>
            A <c>Tuple</c> is an immutable, strongly typed sequence of variously
            typed values with each value lacking an otherwise meaningful name aside
            from its position.
            </para>
            </remarks>
        </member>
        <member name="C:Cadenza.Tuple`4(````3210T1`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T2`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T3`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3,````3210T4`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="item1">
            A <typeparamref name="T1" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item1" /> property.
            </param>
            <param name="item2">
            A <typeparamref name="T2" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item2" /> property.
            </param>
            <param name="item3">
            A <typeparamref name="T3" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item3" /> property.
            </param>
            <param name="item4">
            A <typeparamref name="T4" /> which is used to initialize the <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item4" /> property.
            </param>
            <summary>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> instance.
            </summary>
            <remarks>
                <para>
            Constructs and initializes a new <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> instance.
            </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`4.Equals(````3210System`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3.````3210Object`3``32`3```321`3``32`3````3210`3``32`3```321`3``32`3)">
            <param name="obj">
            A <see cref="T:System.Object" /> to compare this instance against.
            </param>
            <summary>
            Determines whether the current instance and the specified object have the same value.
            </summary>
            <returns>
                <para>
                    <see langword="true" /> if <paramref name="obj" /> is a
            <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> and each member of <paramref name="obj" />
            and the current instance have the same value (according to
            <see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />); otherwise
            <see langword="false" /> is returned.
            </para>
            </returns>
            <remarks>
                <para>
            This method checks for value equality
            (<see cref="M:System.Collections.Generic.EqualityComparer{T}.Equals(`0,`0)" />), as defined by each
            value type.
            </para>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.Equals(System.Object)" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`4.GetHashCode">
            <summary>
            Generates a hash code for the current instance.
            </summary>
            <returns>
            A <see cref="T:System.Int32" /> containing the hash code for this instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="note">
            This method overrides <see cref="M:System.Object.GetHashCode" />.
            </block>
                </para>
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`4.Item1">
            <summary>
            The first tuple value.
            </summary>
            <value>
            A <typeparamref name="T1" /> which is the first tuple value.
            </value>
            <remarks>
            The first tuple value.
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`4.Item2">
            <summary>
            The second tuple value.
            </summary>
            <value>
            A <typeparamref name="T2" /> which is the second tuple value.
            </value>
            <remarks>
            The second tuple value.
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`4.Item3">
            <summary>
            The third tuple value.
            </summary>
            <value>
            A <typeparamref name="T3" /> which is the third tuple value.
            </value>
            <remarks>
            The third tuple value.
            </remarks>
        </member>
        <member name="P:Cadenza.Tuple`4.Item4">
            <summary>
            The fourth tuple value.
            </summary>
            <value>
            A <typeparamref name="T4" /> which is the fourth tuple value.
            </value>
            <remarks>
            The fourth tuple value.
            </remarks>
        </member>
        <member name="M:Cadenza.Tuple`4.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> representation of the value of the current instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> representation of the value of the current instance.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Returns <c>(</c>, followed by a comma-separated list of the result of
            calling <see cref="M:System.Object.ToString" /> on
            <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item1" />,
            <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item2" />,
            <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item3" />,
            <see cref="P:Cadenza.Tuple{T1,T2,T3,T4}.Item4" />,
            followed by <c>)</c>.
            </block>
                </para>
            </remarks>
        </member>
        <member name="T:Cadenza.TupleCoda">
            <summary>
            Extension methods on <c>Tuple</c> types.
            </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.TupleCoda.Aggregate``2(Cadenza.Tuple{``0},System.Func{``0,``1})">
            <typeparam name="T">
            The first value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T}" /> to aggregate the values of.
            </param>
            <param name="func">
            A <see cref="T:System.Func{T,TResult}" /> which will be invoked, providing the values
            <see cref="P:Cadenza.Tuple`1.Item1" />
            to <paramref name="func" /> and
            returning the value returned by <paramref name="func" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T}" /> into a <typeparamref name="TResult" />.
            </summary>
            <returns>
            The <typeparamref name="TResult" /> returned by <paramref name="func" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`1.Item1" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="func" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Aggregate``3(Cadenza.Tuple{``0,``1},System.Func{``0,``1,``2})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T1,T2}" /> to aggregate the values of.
            </param>
            <param name="func">
            A <see cref="T:System.Func{T1,T2,TResult}" /> which will be invoked, providing the values
            <see cref="P:Cadenza.Tuple`2.Item1" />, <see cref="P:Cadenza.Tuple`2.Item2" />
            to <paramref name="func" /> and
            returning the value returned by <paramref name="func" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T1,T2}" /> into a <typeparamref name="TResult" />.
            </summary>
            <returns>
            The <typeparamref name="TResult" /> returned by <paramref name="func" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`2.Item1" />, <see cref="P:Cadenza.Tuple`2.Item2" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="func" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Aggregate``4(Cadenza.Tuple{``0,``1,``2},System.Func{``0,``1,``2,``3})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> to aggregate the values of.
            </param>
            <param name="func">
            A <see cref="T:System.Func{T1,T2,T3,TResult}" /> which will be invoked, providing the values
            <see cref="P:Cadenza.Tuple`3.Item1" />, <see cref="P:Cadenza.Tuple`3.Item2" />, <see cref="P:Cadenza.Tuple`3.Item3" />
            to <paramref name="func" /> and
            returning the value returned by <paramref name="func" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> into a <typeparamref name="TResult" />.
            </summary>
            <returns>
            The <typeparamref name="TResult" /> returned by <paramref name="func" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`3.Item1" />, <see cref="P:Cadenza.Tuple`3.Item2" />, <see cref="P:Cadenza.Tuple`3.Item3" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="func" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Aggregate``5(Cadenza.Tuple{``0,``1,``2,``3},System.Func{``0,``1,``2,``3,``4})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="T4">
            The fourth value type.
            </typeparam>
            <typeparam name="TResult">
            The return value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> to aggregate the values of.
            </param>
            <param name="func">
            A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> which will be invoked, providing the values
            <see cref="P:Cadenza.Tuple`4.Item1" />, <see cref="P:Cadenza.Tuple`4.Item2" />, <see cref="P:Cadenza.Tuple`4.Item3" />, <see cref="P:Cadenza.Tuple`4.Item4" />
            to <paramref name="func" /> and
            returning the value returned by <paramref name="func" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> into a <typeparamref name="TResult" />.
            </summary>
            <returns>
            The <typeparamref name="TResult" /> returned by <paramref name="func" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`4.Item1" />, <see cref="P:Cadenza.Tuple`4.Item2" />, <see cref="P:Cadenza.Tuple`4.Item3" />, <see cref="P:Cadenza.Tuple`4.Item4" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
            </para>
                <para>-or-</para>
                <para>
                    <paramref name="func" /> is <see langword="null" />.
            </para>
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Match``2(Cadenza.Tuple{``0},System.Func{``0,Cadenza.Maybe{``1}}[])">
            <typeparam name="T">
          The first value type.
        </typeparam>
            <typeparam name="TResult">
          The return value type.
        </typeparam>
            <param name="self">
          A <see cref="T:Cadenza.Tuple{T}" /> to match against.
        </param>
            <param name="matchers">
          A <see cref="T:System.Func{T,Cadenza.Maybe{TResult}}" />
          array containing the conversion routines to use to convert 
          the current <see cref="T:Cadenza.Tuple{T}" /> instance into a 
          <typeparamref name="TResult" /> value.
        </param>
            <summary>
          Converts the current <see cref="T:Cadenza.Tuple{T}" /> instance into a <typeparamref name="TResult" />.
        </summary>
            <returns>
          The <typeparamref name="TResult" /> returned by one of the <paramref name="matchers" />.
        </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
                        <para>
             The current <see cref="T:Cadenza.Tuple{T}" /> instance is converted into a 
             <typeparamref name="TResult" /> instance by trying each
             <see cref="T:System.Func{T,Cadenza.Maybe{TResult}}" />
             within <paramref name="matchers" />.
            </para>
                        <para>
             This method returns 
             <see cref="P:Cadenza.Maybe{TResult}.Value" /> 
             for the first delegate to return a
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />.
            </para>
                        <para>
             If no <see cref="T:System.Func{T,Cadenza.Maybe{TResult}}" />
             returns a 
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />, then an
             <see cref="T:System.InvalidOperationException" /> is thrown.
            </para>
                    </block>
                    <code lang="C#">
          var    a = Tuple.Create (1, 2);
          string b = a.Match (
              (t, v) =&gt; Match.When ( t + v == 3, "foo!"),
              (t, v) =&gt; "*default*".Just ());
          Console.WriteLine (b);  // prints "foo!"</code>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="matchers" /> is <see langword="null" />.
          </para>
            </exception>
            <exception cref="T:System.InvalidOperationException">
          None of the 
          <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
          delegates within <paramref name="matchers" /> returned a 
          <see cref="T:Cadenza.Maybe{TResult}" /> instance where
          <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> was
          <see langword="true" />.
        </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Match``3(Cadenza.Tuple{``0,``1},System.Func{``0,``1,Cadenza.Maybe{``2}}[])">
            <typeparam name="T1">
          The first value type.
        </typeparam>
            <typeparam name="T2">
          The second value type.
        </typeparam>
            <typeparam name="TResult">
          The return value type.
        </typeparam>
            <param name="self">
          A <see cref="T:Cadenza.Tuple{T1,T2}" /> to match against.
        </param>
            <param name="matchers">
          A <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
          array containing the conversion routines to use to convert 
          the current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance into a 
          <typeparamref name="TResult" /> value.
        </param>
            <summary>
          Converts the current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance into a <typeparamref name="TResult" />.
        </summary>
            <returns>
          The <typeparamref name="TResult" /> returned by one of the <paramref name="matchers" />.
        </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
                        <para>
             The current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance is converted into a 
             <typeparamref name="TResult" /> instance by trying each
             <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
             within <paramref name="matchers" />.
            </para>
                        <para>
             This method returns 
             <see cref="P:Cadenza.Maybe{TResult}.Value" /> 
             for the first delegate to return a
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />.
            </para>
                        <para>
             If no <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
             returns a 
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />, then an
             <see cref="T:System.InvalidOperationException" /> is thrown.
            </para>
                    </block>
                    <code lang="C#">
          var    a = Tuple.Create (1, 2);
          string b = a.Match (
              (t, v) =&gt; Match.When ( t + v == 3, "foo!"),
              (t, v) =&gt; "*default*".Just ());
          Console.WriteLine (b);  // prints "foo!"</code>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="matchers" /> is <see langword="null" />.
          </para>
            </exception>
            <exception cref="T:System.InvalidOperationException">
          None of the 
          <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
          delegates within <paramref name="matchers" /> returned a 
          <see cref="T:Cadenza.Maybe{TResult}" /> instance where
          <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> was
          <see langword="true" />.
        </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Match``4(Cadenza.Tuple{``0,``1,``2},System.Func{``0,``1,``2,Cadenza.Maybe{``3}}[])">
            <typeparam name="T1">
          The first value type.
        </typeparam>
            <typeparam name="T2">
          The second value type.
        </typeparam>
            <typeparam name="T3">To be added.</typeparam>
            <typeparam name="TResult">
          The return value type.
        </typeparam>
            <param name="self">
          A <see cref="T:Cadenza.Tuple{T1,T2}" /> to match against.
        </param>
            <param name="matchers">
          A <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
          array containing the conversion routines to use to convert 
          the current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance into a 
          <typeparamref name="TResult" /> value.
        </param>
            <summary>
          Converts the current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance into a <typeparamref name="TResult" />.
        </summary>
            <returns>
          The <typeparamref name="TResult" /> returned by one of the <paramref name="matchers" />.
        </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
                        <para>
             The current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance is converted into a 
             <typeparamref name="TResult" /> instance by trying each
             <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
             within <paramref name="matchers" />.
            </para>
                        <para>
             This method returns 
             <see cref="P:Cadenza.Maybe{TResult}.Value" /> 
             for the first delegate to return a
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />.
            </para>
                        <para>
             If no <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
             returns a 
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />, then an
             <see cref="T:System.InvalidOperationException" /> is thrown.
            </para>
                    </block>
                    <code lang="C#">
          var    a = Tuple.Create (1, 2);
          string b = a.Match (
              (t, v) =&gt; Match.When ( t + v == 3, "foo!"),
              (t, v) =&gt; "*default*".Just ());
          Console.WriteLine (b);  // prints "foo!"</code>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="matchers" /> is <see langword="null" />.
          </para>
            </exception>
            <exception cref="T:System.InvalidOperationException">
          None of the 
          <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
          delegates within <paramref name="matchers" /> returned a 
          <see cref="T:Cadenza.Maybe{TResult}" /> instance where
          <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> was
          <see langword="true" />.
        </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.Match``5(Cadenza.Tuple{``0,``1,``2,``3},System.Func{``0,``1,``2,``3,Cadenza.Maybe{``4}}[])">
            <typeparam name="T1">
          The first value type.
        </typeparam>
            <typeparam name="T2">
          The second value type.
        </typeparam>
            <typeparam name="T3">To be added.</typeparam>
            <typeparam name="T4">To be added.</typeparam>
            <typeparam name="TResult">
          The return value type.
        </typeparam>
            <param name="self">
          A <see cref="T:Cadenza.Tuple{T1,T2}" /> to match against.
        </param>
            <param name="matchers">
          A <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
          array containing the conversion routines to use to convert 
          the current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance into a 
          <typeparamref name="TResult" /> value.
        </param>
            <summary>
          Converts the current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance into a <typeparamref name="TResult" />.
        </summary>
            <returns>
          The <typeparamref name="TResult" /> returned by one of the <paramref name="matchers" />.
        </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
                        <para>
             The current <see cref="T:Cadenza.Tuple{T1,T2}" /> instance is converted into a 
             <typeparamref name="TResult" /> instance by trying each
             <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
             within <paramref name="matchers" />.
            </para>
                        <para>
             This method returns 
             <see cref="P:Cadenza.Maybe{TResult}.Value" /> 
             for the first delegate to return a
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />.
            </para>
                        <para>
             If no <see cref="T:System.Func{T1,T2,Cadenza.Maybe{TResult}}" />
             returns a 
             <see cref="T:Cadenza.Maybe{TResult}" /> instance
             where <see cref="P:Cadenza.Maybe{TResult}.HasValue" />
             is <see langword="true" />, then an
             <see cref="T:System.InvalidOperationException" /> is thrown.
            </para>
                    </block>
                    <code lang="C#">
          var    a = Tuple.Create (1, 2);
          string b = a.Match (
              (t, v) =&gt; Match.When ( t + v == 3, "foo!"),
              (t, v) =&gt; "*default*".Just ());
          Console.WriteLine (b);  // prints "foo!"</code>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="matchers" /> is <see langword="null" />.
          </para>
            </exception>
            <exception cref="T:System.InvalidOperationException">
          None of the 
          <see cref="T:System.Func{TSource,Cadenza.Maybe{TResult}}" />
          delegates within <paramref name="matchers" /> returned a 
          <see cref="T:Cadenza.Maybe{TResult}" /> instance where
          <see cref="P:Cadenza.Maybe{TResult}.HasValue" /> was
          <see langword="true" />.
        </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.ToEnumerable``1(Cadenza.Tuple{``0})">
            <typeparam name="T">
            The first value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T}" /> to convert into an <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T}" /> into a <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`1.Item1" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.ToEnumerable``2(Cadenza.Tuple{``0,``1})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T1,T2}" /> to convert into an <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T1,T2}" /> into a <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`2.Item1" />, <see cref="P:Cadenza.Tuple`2.Item2" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.ToEnumerable``3(Cadenza.Tuple{``0,``1,``2})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> to convert into an <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T1,T2,T3}" /> into a <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`3.Item1" />, <see cref="P:Cadenza.Tuple`3.Item2" />, <see cref="P:Cadenza.Tuple`3.Item3" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.ToEnumerable``4(Cadenza.Tuple{``0,``1,``2,``3})">
            <typeparam name="T1">
            The first value type.
            </typeparam>
            <typeparam name="T2">
            The second value type.
            </typeparam>
            <typeparam name="T3">
            The third value type.
            </typeparam>
            <typeparam name="T4">
            The fourth value type.
            </typeparam>
            <param name="self">
            A <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> to convert into an <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </param>
            <summary>
            Converts the <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" /> into a <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable{System.Object}" />.
            </returns>
            <remarks>
                <para>
                    <block subset="none" type="behaviors">
            Passes the values <see cref="P:Cadenza.Tuple`4.Item1" />, <see cref="P:Cadenza.Tuple`4.Item2" />, <see cref="P:Cadenza.Tuple`4.Item3" />, <see cref="P:Cadenza.Tuple`4.Item4" /> to
            <paramref name="func" />, returning the value produced by
            <paramref name="func" />.
            </block>
                </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            if <paramref name="self" /> is <see langword="null" />.
            </exception>
        </member>
        <member name="M:Cadenza.TupleCoda.ToKeyValuePair``2(Cadenza.Tuple{``0,``1})">
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="self">
          A 
          <see cref="T:Cadenza.Tuple{TKey,TValue}" />
          to convert into a
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />.
        </param>
            <summary>
          Converts a 
          <see cref="T:Cadenza.Tuple{TKey,TValue}" />
          into a
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />.
        </summary>
            <returns>
          A 
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />
          structure.
        </returns>
            <remarks>
                <para>
            The value of the returned 
            <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" />
            property is copied from 
            <see cref="P:Cadenza.Tuple`2._1" />
            and the value of the returned 
            <see cref="P:System.Collections.Generic.KeyValuePair`2.Value" />
            is copied from 
            <see cref="P:Cadenza.Tuple`2._2" />.
          </para>
                <code lang="C#">
var                       tuple = Tuple.Create ("s", 1);
KeyValuePair&lt;string, int&gt; kvp   = tuple.ToKeyValuePair ();
    // kvp.Key == "s", kvp.Value == 1</code>
            </remarks>
            <altmember cref="M:Cadenza.TupleCoda.ToKeyValuePair``2(Cadenza.Tuple{``0,``1})" />
        </member>
        <member name="T:Cadenza.TypeCoda">
            <summary>
      Extension methods for <see cref="T:System.Type" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.TypeCoda.IsAssignableTo(System.Type,System.Type)">
            <param name="self">
          A <see cref="T:System.Type" /> which is used to check that
          instances of type <paramref name="self" /> can be stored
          into references of type <paramref name="type" />.
        </param>
            <param name="type">
          A <see cref="T:System.Type" /> which is the type of the
          reference to store an instance of type <paramref name="self" />.
        </param>
            <summary>
          Determines whether an instance of <paramref name="self" /> can be
          stored in a reference of a type <paramref name="type" />.
        </summary>
            <returns>
                <see langword="true" /> if an instance of type <paramref name="self" />
          can be stored into a reference of type <paramref name="type" />;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            This is equivalent to
            <c><paramref name="type" />.IsAssignableFrom(<paramref name="self" />)</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza/TypeCodaTest.cs#IsAssignableTo">// Can string be implicitly converted to object?  Yes.
Assert.IsTrue (typeof(string).IsAssignableTo (typeof (object)));
// Can object be implicitly converted to string?  No.
Assert.IsFalse (typeof(object).IsAssignableTo (typeof (string)));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:System.Type.IsAssignableFrom(System.Type)" />
        </member>
        <member name="M:Cadenza.TypeCoda.IsNullable(System.Type)">
            <param name="self">
          A <see cref="T:System.Type" /> containing the type to check.
        </param>
            <summary>
          Gets a value indicating whether the type is a nullable type.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="self" /> is a
          <see cref="T:System.Nullable{T}" /> type; otherwise,
          <see langword="false" />.
        </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is considered to a nullable type if:
          </para>
                <list type="bullet">
                    <item>
                        <term>
                            <paramref name="self" /> is not <c>typeof(Nullable&lt;&gt;).</c></term>
                    </item>
                    <item>
                        <term>
                            <c>
                                <paramref name="self" />.GetGenericTypeDefinition()</c> is
              <c>typeof(Nullable&lt;&gt;)</c>.
            </term>
                    </item>
                </list>
                <code lang="C#" src="../../Test/Cadenza/TypeCodaTest.cs#IsNullable">Assert.IsTrue (typeof (int?).IsNullable ());
Assert.IsFalse (typeof (int).IsNullable ());
Assert.IsFalse (typeof (string).IsNullable ());
Assert.IsFalse (typeof (Nullable&lt;&gt;).IsNullable ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="T:Cadenza.UInt16Coda">
            <summary>
      Extension methods for <see cref="T:System.UInt16" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.UInt16Coda.IsEven(System.UInt16)">
            <param name="value">
          A <see cref="T:System.UInt16" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an even number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an even number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.UInt16Coda.IsOdd(System.UInt16)" />
        </member>
        <member name="M:Cadenza.UInt16Coda.IsOdd(System.UInt16)">
            <param name="value">
          A <see cref="T:System.UInt16" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an odd number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an odd number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.UInt16Coda.IsEven(System.UInt16)" />
        </member>
        <member name="T:Cadenza.UInt32Coda">
            <summary>
      Extension methods for <see cref="T:System.UInt32" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.UInt32Coda.IsEven(System.UInt32)">
            <param name="value">
          A <see cref="T:System.UInt32" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an even number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an even number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.UInt32Coda.IsOdd(System.UInt32)" />
        </member>
        <member name="M:Cadenza.UInt32Coda.IsOdd(System.UInt32)">
            <param name="value">
          A <see cref="T:System.UInt32" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an odd number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an odd number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.UInt32Coda.IsEven(System.UInt32)" />
        </member>
        <member name="T:Cadenza.UInt64Coda">
            <summary>
      Extension methods for <see cref="T:System.UInt64" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.UInt64Coda.IsEven(System.UInt64)">
            <param name="value">
          A <see cref="T:System.UInt64" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an even number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an even number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.UInt64Coda.IsOdd(System.UInt64)" />
        </member>
        <member name="M:Cadenza.UInt64Coda.IsOdd(System.UInt64)">
            <param name="value">
          A <see cref="T:System.UInt64" /> containing the value to check.
        </param>
            <summary>
          Gets a value indicating whether <paramref name="value" /> is an odd number.
        </summary>
            <returns>
                <see langword="true" /> if <paramref name="value" /> is an odd number;
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <para>
            For purposes of this method, an even value is a number
            evenly divisible by 2 and the number 0; all other numbers
            are odd.
          </para>
            </remarks>
            <altmember cref="M:Cadenza.UInt64Coda.IsEven(System.UInt64)" />
        </member>
        <member name="T:Cadenza.WeakReference`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.WeakReference`1(T)">
            <param name="target">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.WeakReference`1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <param name="info">To be added.</param>
            <param name="context">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.WeakReference`1(T,System.Boolean)">
            <param name="target">To be added.</param>
            <param name="trackResurrection">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.WeakReference`1.Target">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.WeakReferenceChecker`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.WeakReferenceChecker`1(T)">
            <param name="target">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.WeakReferenceChecker`1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <param name="info">To be added.</param>
            <param name="context">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.WeakReferenceChecker`1(T,System.Boolean)">
            <param name="target">To be added.</param>
            <param name="trackResurrection">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.WeakReferenceChecker`1.Target">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.WeakReferenceChecker`1.set_Target(System.Object)" /></exception>
        </member>
        <member name="T:Cadenza.Collections.BidirectionalDictionary`2">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.BidirectionalDictionary`2">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.BidirectionalDictionary`2(``10System`1``10`1.``10Int32`1``10`1)">
            <param name="capacity">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.BidirectionalDictionary`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1},``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TValue`1``10`1})">
            <param name="keyComparer">To be added.</param>
            <param name="valueComparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.BidirectionalDictionary`2(``10System`1``10`1.``10Int32`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1},``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TValue`1``10`1})">
            <param name="capacity">To be added.</param>
            <param name="keyComparer">To be added.</param>
            <param name="valueComparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.Add(``10TKey`1``10`1,``10TValue`1``10`1)">
            <param name="key">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Add(`0,`1)" />, <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Add(`0,`1)" /></exception>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Add(`0,`1)" />, <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Add(`0,`1)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.Clear">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.ContainsKey(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.ContainsValue(``10TValue`1``10`1)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalDictionary`2.Count">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalDictionary`2.Inverse">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalDictionary`2.Item(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.set_Item(`0,`1)" /></exception>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.set_Item(`0,`1)" />, <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.set_Item(`0,`1)" /></exception>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalDictionary`2.Keys">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.Remove(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Remove(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.Replace(``10TKey`1``10`1,``10TValue`1``10`1)">
            <param name="key">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Replace(`0,`1)" />, <see cref="M:Cadenza.Collections.BidirectionalDictionary`2.Replace(`0,`1)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1}[],``10System`1``10`1.``10Int32`1``10`1)">
            <param name="array">To be added.</param>
            <param name="arrayIndex">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.TryGetKey(``10TValue`1``10`1,``10TKey`1``10`1@)">
            <param name="value">To be added.</param>
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalDictionary`2.TryGetValue(``10TKey`1``10`1,``10TValue`1``10`1@)">
            <param name="key">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalDictionary`2.Values">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.BidirectionalLookup`2">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TElement">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.BidirectionalLookup`2">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.BidirectionalLookup`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1},``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TElement`1``10`1})">
            <param name="keyComparer">To be added.</param>
            <param name="valueComparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalLookup`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})" />, <see cref="M:Cadenza.Collections.BidirectionalLookup`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},System.Collections.Generic.IEqualityComparer{`1})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.Add(``10TKey`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEnumerable`1``10`1{``10TElement`1``10`1})">
            <param name="key">To be added.</param>
            <param name="elements">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.BidirectionalLookup`2.Add(`0,System.Collections.Generic.IEnumerable{`1})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.Add(``10TKey`1``10`1,``10TElement`1``10`1)">
            <param name="key">To be added.</param>
            <param name="element">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.Clear">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.Contains(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalLookup`2.Count">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalLookup`2.Inverse">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.BidirectionalLookup`2.Item(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.Remove(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.Remove(``10TKey`1``10`1,``10TElement`1``10`1)">
            <param name="key">To be added.</param>
            <param name="element">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.BidirectionalLookup`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.CachedSequence`1">
            <typeparam name="T">
      The type of the value to store in the sequence.
    </typeparam>
            <summary>
      An immutable, thread-safe, singly-linked list.
    </summary>
            <remarks>
                <para>
                    <c>CachedSequence&lt;T&gt;</c> is useful for caching the current values
        within a <see cref="T:System.Collections.Generic.IEnumerable{T}" />
        which come from a generator that will generate different values
        from each invocation.  Consider the following generator:
      </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#CachedSequence_RandomValuesGenerator">internal static IEnumerable&lt;int&gt; RandomValues (Random r, int max)
{
	while (true)
		yield return r.Next (max);
}
</code>
                <para>
        The above generator does two things: it generates an infinite sequence,
        and each time
        <see cref="T:System.Collections.Generic.IEnumerable{T}.GetEnumerator" />
        is called on the
        <see cref="T:System.Collections.Generic.IEnumerable{T}" /> that
        <c>RandomValues()</c> returns, it may return a different sequence:
      </para>
                <code>var r = new Random();

// prints e.g.: 6, 2, 8
foreach (var v in RandomValues (r, 10).Take(3))
    Console.WriteLine (v);

// prints e.g.: 1, 4, 3
foreach (var v in RandomValues (r, 10).Take(3))
    Console.WriteLine (v);</code>
                <para>
        This is potentially fine if you're aware of the problem, but it
        can potentially break some algorithms if the generator is
        referenced multiple times (under the assumption that the
        sequence won't change):
      </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#NoCache">var randSeq = RandomValues (new Random (), 100);
// this could pass, but that's highly improbable
Assert.IsFalse (
		randSeq.Take (10).SelectFromEach (randSeq.Take (10),
			(l, r) =&gt; l + r)
		.All (x =&gt; x % 2 == 0));
</code>
                <para>
        The above algorithm attempts to say: give me two sets of 10 random
        numbers, add them together, and assert that the results are always
        even (as any number added to itself will be even).  This algorithm
        fails because the generator returns a different sequence on the
        second <c>randSeq.Take(10)</c> call.
      </para>
                <para>
        A fix is to "memoize" the sequence.  <c>CachedSequence&lt;T&gt;</c>
        will record the input sequence, so that subsequent iterations
        will return the same values as the first iteration.  This allows
        the same algorithm to work:
      </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/CachedSequenceTest.cs#RandomValues">var values = new Random ();
// Note: wrapping an infinite sequence
var randSeq = new CachedSequence&lt;int&gt; (EnumerableTest.RandomValues (values, 10));
Assert.IsTrue (
		randSeq.Take (20).SelectFromEach (randSeq.Take (10),
			(l, r) =&gt; l + r)
		.All (x =&gt; x % 2 == 0));
</code>
                <para>
                    <c>CachedSequence&lt;T&gt;</c> has two modes of operation: as a
        "fully realized" singly-linked list constructed one node at a time,
        and (as seen above) as a caching wrapper over an
        <see cref="T:System.Collections.Generic.IEnumerable{T}" /> sequence.
      </para>
                <para>
        Node at a time construction is performed with the
        <see cref="C:Cadenza.Collections.CachedSequence{T}(`0)" /> and
        <see cref="C:Cadenza.Collections.CachedSequence{T}(`0,Cadenza.Collections.CachedSequence{`0})" />
        constructors.  For both, the <typeparamref name="T" /> parameter then
        becomes accessible via
        <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />,
        while
        <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" /> is either
        <see langword="null" /> (for the first constructor) or the specified
        <c>CachedSequence&lt;T&gt;</c> value.  The second constructor
        thus allows creating sequences of arbitrary length.
      </para>
                <para>
        When wrapping
        <see cref="T:System.Collections.Generic.IEnumerable{T}" /> sequences
        via the
        <see cref="C:Cadenza.Collections.CachedSequence{T}(System.Collections.Generic.IEnumerable{`0})" />
        constructor, an alternate mode is used.  The sequence is not
        immediately executed; instead, the sequence is evaluated on-demand
        when the
        <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />
        and
        <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />
        properties are accessed.  This allows infinite sequences to be
        wrapped without requiring infinite memory, as seen above with the
        random sequence generator.
      </para>
            </remarks>
        </member>
        <member name="C:Cadenza.Collections.CachedSequence`1(`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0})">
            <param name="collection">
          A <see cref="T:System.Collections.Generic.IEnumerable{T}" />
          which is the sequence to wrap.  <paramref name="collection" />
          may refer to an infinite sequence.
        </param>
            <summary>
          Constructs and initializes a new instance of the
          <see cref="T:Cadenza.Collections.CachedSequence{T}" /> class
          which wraps the specified <paramref name="collection" />.
        </summary>
            <remarks>
                <para>
            This constructor invokes
            <see cref="M:System.Collections.Generic.IEnumerable{T}.GetEnumerator" />
            on <paramref name="collection" /> to obtain a
            <see cref="T:System.Collections.Generic.IEnumerator{T}" />.  This is
            referred to as the "underlying enumerator".
            <see cref="M:System.Collections.IEnumerator.MoveNext" /> is invoked
            on the underlying enumerator; if <see langword="false" /> is
            returned, then <see cref="T:System.InvalidOperationException" />
            is thrown; otherwise,
            <see cref="P:System.Collections.Generic.IEnumerator{T}.Current" />
            is used to initialize the
            <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />
            property.
          </para>
                <para>
            The value of the
            <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />
            property is determined lazily, depending upon the state of the
            underlying enumerator.
          </para>
                <para>
            The underlying enumerator is
            <see cref="M:System.IDisposable.Dispose" />d
            when one of two circumstances occurs:
          </para>
                <list type="number">
                    <item>
                        <term>
                The sequence has been completely evaluated (causing
                <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />
                to return <see langword="null" />).  This can't happen
                with infinite sequences.
              </term>
                    </item>
                    <item>
                        <term>
                            <see cref="M:Cadenza.Collections.CachedSequence{T}.GetEnumerator" />
                is invoked, and the returned enumerator is disposed.  This
                will cause the underlying enumerator to also be disposed.
              </term>
                    </item>
                </list>
                <para>
            Note that disposing the underlying enumerator effectively
            terminates the sequence.  Thus, <paramref name="collection" />
            is an infinite sequence, if the <c>CachedSequence&lt;T&gt;</c>
            is enumerated and the enumerator is disposed, the infinite
            sequence is also disposed, and no additional elements will be
            accessible.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="collection" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
                <paramref name="collection" /> contains no elements.
        </exception>
        </member>
        <member name="C:Cadenza.Collections.CachedSequence`1(`0T`0)">
            <param name="head">
          A <typeparamref name="T" /> containing the value to hold.
        </param>
            <summary>
          Constructs and initializes a new instance of the
          <see cref="T:Cadenza.Collections.CachedSequence{T}" /> class
          using the specified <paramref name="head" />.
        </summary>
            <remarks>
                <para>
            This constructor initializes the
            <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />
            property of the new instance using <paramref name="head" />.
            The <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />
            property of the new sequence will be <see langword="null" />.
          </para>
            </remarks>
        </member>
        <member name="C:Cadenza.Collections.CachedSequence`1(`0T`0,`0Cadenza`0.`0Collections`0.`0CachedSequence`0{`0T`0})">
            <param name="head">
          A <typeparamref name="T" /> containing the value to hold.
        </param>
            <param name="tail">
          A <see cref="T:Cadenza.Collections.CachedSequence{T}" />
          which is used to initialize the
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />
          property of the created instance.
        </param>
            <summary>
          Constructs and initializes a new instance of the
          <see cref="T:Cadenza.Collections.CachedSequence{T}" /> class
          using the specified <paramref name="head" /> and
          <paramref name="tail" />.
        </summary>
            <remarks>
                <para>
            This constructor initializes the
            <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />
            property of the new instance using <paramref name="head" />,
            and initializes the
            <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />
            property of the new instance using <paramref name="tail" />.
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.Append(`0T`0)">
            <param name="value">
          A <typeparamref name="T" /> containing the value to append
          to the sequence.
        </param>
            <summary>Clones the current sequence with <paramref name="value" /> appended.</summary>
            <returns>
          A new <see cref="T:Cadenza.Collections.CachedSequence{T}" />
          which has <paramref name="value" /> as the last value in the sequence.
        </returns>
            <remarks>
                <para>
            This is an O(n) operation.  Do not use when wrapping infinite sequences.
          </para>
                <para>
            This creates a new, cloned sequence which is identical to the
            current sequence except that <paramref name="value" /> is
            the last element in the sequence.  This sequence is unchanged.
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.Count">
            <summary>Returns the number of elements in the sequence.</summary>
            <returns>
          A <see cref="T:System.Int32" /> containing the number of elements
          in the sequence.
        </returns>
            <remarks>
                <para>
            This is an O(n) operation, and will immediately evaluate the entire
            sequence.  Do not use when wrapping infinite sequences.
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.ElementAt(`0System`0.`0Int32`0)">
            <param name="index">
          An <see cref="T:System.Int32" /> which is the in
        </param>
            <summary>Returns the value at a specified index in the sequence.</summary>
            <returns>
          A <typeparamref name="T" /> which is the value at the
          <paramref name="index" /> index in the sequence.
        </returns>
            <remarks>
                <para>
            This is an O(<paramref name="index" />) operation.
          </para>
                <para>
            If this element or a preceding element was constructed via the
            <see cref="C:Cadenza.Collections.CachedSequence{T}(System.Collections.Generic.IEnumerable{`0})" />
            constructor, then this may evaluate <paramref name="index" />
            values.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is negative or is larger than
          <see cref="M:Cadenza.Collections.CachedSequence{T}.LongCount" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.First">
            <summary>
          Returns <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />.
        </summary>
            <returns>
          A <typeparamref name="T" /> which is the value held by
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />.
        </returns>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.FirstOrDefault">
            <summary>
          Returns <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />.
        </summary>
            <returns>
          A <typeparamref name="T" /> which is the value held by
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />.
        </returns>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.GetEnumerator">
            <summary>Returns an enumerator that iterates through the linked list.</summary>
            <returns>
          An <see cref="T:System.Collections.Generic.IEnumerator{T}" />
          that can be used to iterate through the linked list as a collection.
        </returns>
            <remarks />
        </member>
        <member name="P:Cadenza.Collections.CachedSequence`1.Head">
            <summary>Returns the value held by this instance.</summary>
            <value>
          A <typeparamref name="T" /> which is the value held by this instance.
        </value>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.LongCount">
            <summary>Returns the number of elements in the sequence.</summary>
            <returns>
          A <see cref="T:System.Int64" /> containing the number of elements
          in the sequence.
        </returns>
            <remarks>
                <para>
            This is an O(n) operation, and will immediately evaluate the entire
            sequence.  Do not use when wrapping infinite sequences.
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.Prepend(`0T`0)">
            <param name="value">
          A <typeparamref name="T" /> value which should be inserted
          before the current sequence.
        </param>
            <summary>
          Returns a new <see cref="T:Cadenza.Collections.CachedSequence{T}" />
          with <paramref name="value" /> as the
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" /> and
          the current sequence as the
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />.
        </summary>
            <returns>
          A new <see cref="T:Cadenza.Collections.CachedSequence{T}" />
          with <paramref name="value" /> as the
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" /> and
          the current sequence as the
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />.
        </returns>
            <remarks>
                <para>
            This is an O(1) operation.
          </para>
                <para>
            This is equivalent to: <c>new CachedSequence&lt;T&gt;(value, this)</c>.
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.Reverse">
            <summary>Reverse the sequence that the current instance is the start of.</summary>
            <returns>
          A new <see cref="T:Cadenza.Collections.CachedSequence{T}" />
          in which
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />
          is the last value in the returned sequence,
          <c><see cref="P:Cadenza.Collections.CachedSequence{T}.Tail" />.Head</c>
          is the second to last value in the returned sequence, etc.
        </returns>
            <remarks>
                <para>
            This is an O(n) operation.
          </para>
                <para>
            This immediately evaluates the entire sequence.  Do not use
            when wrapping infinite sequences.
          </para>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.CachedSequence`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the linked list.</summary>
            <returns>
          An <see cref="T:System.Collections.IEnumerator" /> that can be used
          to iterate through the linked list as a collection.
        </returns>
            <remarks />
        </member>
        <member name="P:Cadenza.Collections.CachedSequence`1.Tail">
            <summary>
          Obtains the items in the sequence following the current item,
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />.
        </summary>
            <value>
          A <see cref="T:Cadenza.Collections.CachedSequence{T}" />
          containing the items in the sequence following
          <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />.
          If there are no more items, then <see langword="null" />
          is returned.
        </value>
            <remarks>
                <block subset="none" type="behaviors">
                    <para>
              If this instance was constructed via the
              <see cref="C:Cadenza.Collections.CachedSequence{T}(`0)" />
              constructor, <see langword="null" /> is returned.
            </para>
                    <para>
              If this instance was constructed via the
              <see cref="C:Cadenza.Collections.CachedSequence{T}(`0,Cadenza.Collections.CachedSequence{`0})" />
              constructor, then the <c>tail</c> parameter is
              returned (which may be <see langword="null" />).
            </para>
                    <para>
              If this instance or an instance preceding this instance was
              constructed via the
              <see cref="C:Cadenza.Collections.CachedSequence{T}(System.Collections.Generic.IEnumerable{`0})" />
              constructor, then a lock is taken and
              <see cref="M:System.Collections.IEnumerator.MoveNext" />
              is invoked on the underlying enumerator.  If
              <see langword="false" /> is returned from <c>MoveNext()</c>,
              then <see langword="null" /> will be returned.  Otherwise,
              a new <see cref="T:Cadenza.Collections.CachedSequence{T}" />
              will be returned in which
              <see cref="P:Cadenza.Collections.CachedSequence{T}.Head" />
              will contain the
              <see cref="P:System.Collections.Generic.IEnumerator{T}.Current" />.
              value and will gain "ownership" of the underlying
              <see cref="T:System.Collections.Generic.IEnumerator{T}" />.
            </para>
                </block>
            </remarks>
        </member>
        <member name="T:Cadenza.Collections.CollectionCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.CollectionCoda.RemoveAll``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <typeparam name="T">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="predicate">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.CollectionCoda.RemoveAll``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})" />, <see cref="M:Cadenza.Collections.CollectionCoda.RemoveAll``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})" /></exception>
        </member>
        <member name="T:Cadenza.Collections.DelegatedEqualityComparer`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.DelegatedEqualityComparer`1(`0System`0.`0Func`0{`0T`0,`0T`0,`0System`0.`0Boolean`0},`0System`0.`0Func`0{`0T`0,`0System`0.`0Int32`0})">
            <param name="equalsGetter">To be added.</param>
            <param name="hashCodeGetter">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.DelegatedEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})" />, <see cref="M:Cadenza.Collections.DelegatedEqualityComparer`1.#ctor(System.Func{`0,`0,System.Boolean},System.Func{`0,System.Int32})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.DelegatedEqualityComparer`1.Equals(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DelegatedEqualityComparer`1.GetHashCode(`0T`0)">
            <param name="obj">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.DelegatedEqualityComparer`2">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.DelegatedEqualityComparer`2(``10System`1``10`1.``10Func`1``10`1{``10TSource`1``10`1,``10T`1``10`1})">
            <param name="selector">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.DelegatedEqualityComparer`2.#ctor(System.Func{`0,`1})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.DelegatedEqualityComparer`2.Equals(``10TSource`1``10`1,``10TSource`1``10`1)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DelegatedEqualityComparer`2.GetHashCode(``10TSource`1``10`1)">
            <param name="obj">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.DictionaryCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.GetValueOrCreate``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.GetValueOrCreate``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="key">To be added.</param>
            <param name="creator">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.GetValueOrDefault``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="key">To be added.</param>
            <param name="defaultValue">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.SequenceEqual``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="other">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.SequenceEqual``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="other">To be added.</param>
            <param name="comparer">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.DictionaryCoda.SequenceEqual``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.DictionaryCoda.UpdateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1,``1})">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="key">To be added.</param>
            <param name="valueSelector">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.EnumerableCoda">
            <summary>
      Extension methods on
      <see cref="T:System.Collections.Generic.IEnumerable{T}" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateHistory``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateHistory``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TAccumulate">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="seed">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateHistory``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TAccumulate">To be added.</typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="seed">To be added.</param>
            <param name="func">To be added.</param>
            <param name="resultSelector">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateHistory``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TAccumulate">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="seed">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TAccumulate">To be added.</typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="seed">To be added.</param>
            <param name="func">To be added.</param>
            <param name="resultSelector">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateReverseHistory``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateReverseHistory``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TAccumulate">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="seed">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AggregateReverseHistory``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TAccumulate">To be added.</typeparam>
            <typeparam name="TResult">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="seed">To be added.</param>
            <param name="func">To be added.</param>
            <param name="resultSelector">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverseHistory``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.And(System.Collections.Generic.IEnumerable{System.Boolean})">
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{System.Boolean}" />
          containing the values to boolean-OR together.
        </param>
            <summary>Boolean-ANDs a sequence together.</summary>
            <returns>
                <see langword="false" /> if any of the elements in the sequence is
          <see langword="false" />; otherwise, <paramref name="self" /> is a
          sequence of finite length and all of the elements are
          <see langword="true" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#And">Assert.AreEqual (false,
		new[]{true, false, true, true}.And ());
Assert.AreEqual (false,
		new[]{false, false, false, false}.And ());
Assert.AreEqual (true,
		new[]{true, true, true, true}.And ());
Assert.AreEqual (false,
		new[]{true, true, true, true}.Concat (Sequence.Repeat (false)).And ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Apply``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ApplyPairs``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0}[])">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="actions">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ApplyPairs``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0}[])" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.AsIList``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Break``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Cache``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="T">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.CompareWith``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="T">The type of the elements within <paramref name="self" /> and <paramref name="update" /></typeparam>
            <param name="self">The original enumeration of elements.</param>
            <param name="update">The updated enumeration of elements to compare against.</param>
            <summary>Compares two enumerations retrieving added, removed and unchanged elements.</summary>
            <returns>An <see cref="T:Cadenza.Collections.SequenceComparison{T}" /> containing the added, removed and unchanged elements.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="update" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.CompareWith``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <typeparam name="T">The type of the elements within <paramref name="self" /> and <paramref name="update" /></typeparam>
            <param name="self">The original enumeration of elements.</param>
            <param name="update">The updated enumeration of elements to compare against.</param>
            <param name="comparer">The <see cref="System.Collections.Generic.IEqualityComparer{T}" /> used to compare equality.</param>
            <summary>Compares two enumerations retrieving added, removed and unchanged elements.</summary>
            <returns>An <see cref="T:Cadenza.Collections.SequenceComparison{T}" /> containing the added, removed and unchanged elements.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="update" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="selfs">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0}[])">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="selfs">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ContiguousSubsequences``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="windowSize">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.CopyTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="destination">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.CopyTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.ICollection{``0})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="array">To be added.</param>
            <param name="arrayIndex">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)" /></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Cycle``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="action">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="action">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Each``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /></exception>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="count">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.Collections.EnumerableCoda.ExceptLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" /></exception>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.FindIndex``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="predicate">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.FindIndices``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="predicate">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="action">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="action">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.HaskellGroup``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.HaskellGroupBy``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to turn into groups.
        </param>
            <param name="func">
          A <see cref="T:System.Func{TSource,TSource,System.Boolean}" /> which is
          used to determine whether the <typeparamref name="TSource" /> 
          elements belong to the same group.
        </param>
            <summary>
          Split <paramref name="self" /> into a sequence of groups.
        </summary>
            <returns>
          An <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          of groups.
        </returns>
            <remarks>
                <para>
            A group is a continguence sequence of elements from 
            <paramref name="self" /> for which
            <c><paramref name="func" />(firstItemInTheGroup, currentItemInTheGroup)</c>
            returns <see langword="true" />.  Once <paramref name="func" /> 
            returns <see langword="false" />, a new group is created (and the 
            next element within <paramref name="self" /> is the first element
            of the new group).
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#HaskellGroupBy">// Split a string into pairs
string s = "123456789";
int c = 0;
List&lt;List&lt;char&gt;&gt; pairs = s.HaskellGroupBy(delegate {
	++c;
	if (c &lt; 2)
		return true;
	c = 0;
	return false;
}).ToList();
Assert.AreEqual(5, pairs.Count);
Assert.IsTrue(new[]{'1', '2'}.SequenceEqual (pairs [0]));
Assert.IsTrue(new[]{'3', '4'}.SequenceEqual (pairs [1]));
Assert.IsTrue(new[]{'5', '6'}.SequenceEqual (pairs [2]));
Assert.IsTrue(new[]{'7', '8'}.SequenceEqual (pairs [3]));
Assert.IsTrue(new[]{'9'}.SequenceEqual (pairs [4]));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="func" /> is 
          <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Implode``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Selector(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Implode``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="separator">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Selector(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Implode``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="separator">To be added.</param>
            <param name="selector">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Selector(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.IndexOfAny``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.IndexOfAny``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.IndicesOf``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.IndicesOfAny``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.IndicesOfAny``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Values(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Predicate(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.InitialSegments``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence for which to return the initial segments.
        </param>
            <summary>
          Creates a 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all leading segments of <paramref name="self" />,
          shortest first.
        </summary>
            <returns>
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all leading segments of <paramref name="self" />,
          shortest first.
        </returns>
            <remarks>
                <para>
            A "leading segment" is the list of <typeparamref name="TSource" />
            values preceding the "current" index, in which the current index
            starts at the start of <paramref name="self" /> and increments
            until the end of <paramref name="self" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#InitialSegments">IEnumerable&lt;IEnumerable&lt;char&gt;&gt; e = "abc".InitialSegments ();
var l = e.ToList ();
Assert.AreEqual (4, l.Count);
AssertAreSame (new char[]{},          l [0]);
AssertAreSame (new[]{'a'},            l [1]);
AssertAreSame (new[]{'a', 'b'},       l [2]);
AssertAreSame (new[]{'a', 'b', 'c'},  l [3]);
</code>
            </remarks>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.TrailingSegments``1(System.Collections.Generic.IEnumerable{``0})" />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Insert``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Insert``1(System.Collections.Generic.IEnumerable{``0},``0,System.Func{``0,``0,System.Int32})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Func(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Intersperse``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="between">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Intersperse``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}},System.Collections.Generic.IEnumerable{``0})" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Collections.EnumerableCoda.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Intersperse``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to intersperse <paramref name="value" /> into.
        </param>
            <param name="value">
          A <typeparamref name="TSource" /> to insert between each element of
          <paramref name="self" />.
        </param>
            <summary>
          Returns a sequence in which <paramref name="value" /> is inserted
          between each element of <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence <paramref name="self" /> with
          <paramref name="value" /> interspersed between each element.
        </returns>
            <remarks>
                <para>
            This is conceptually like <see cref="M:System.String.Join" /> and
            <see cref="M:Cadenza.Collections.EnumerableCoda.Implode" />, but
            usable for non-<see cref="T:System.String" /> values.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Intersperse">Assert.AreEqual ("1929394", new[]{1,2,3,4}.Intersperse (9).Implode ());
Assert.AreEqual ("a.z",     new[]{'a','z'}.Intersperse ('.').Implode ());
IEnumerable&lt;IEnumerable&lt;char&gt;&gt; e = new char[][]{ 
	new char[]{'b', 'c', 'd'}, 
	new char[]{'e', 'f', 'g'},
};
IEnumerable&lt;char&gt; x = new char[]{'a', 'a'};
Assert.AreEqual ("bcdaaefg", e.Intersperse (x).Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <typeparam name="TValue">
          The type of the value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to find the maximum value from.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource, TValue}" /> used to produce a
          value for comparison.
        </param>
            <summary>
          Gets the max element of <paramref name="self" />, based on the result 
          of using the default comparer on the result of 
          <paramref name="selector" />.
        </summary>
            <returns>
          The element from <paramref name="self" /> which has the largest
          value from <paramref name="selector" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#MaxBy">Assert.AreEqual ("forty-three",
		new[] {
			new {A = "forty-two",    B = 42},
			new {A = "forty-three",  B = 43},
		}.MaxBy (i =&gt; i.B).A);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="selector" /> is 
          <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
                <paramref name="self" /> contained no elements.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <typeparam name="TValue">
          The type of the value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to find the maximum value from.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource, TValue}" /> used to produce a
          value for comparison.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IComparer{TValue}" />
          to use to compare values to determine the maximum value.
        </param>
            <summary>
          Gets the max element of <paramref name="self" />, based on the result 
          of using the specified <paramref name="comparer" /> on the result of 
          <paramref name="selector" />.
        </summary>
            <returns>
          The element from <paramref name="self" /> which has the largest
          value from <paramref name="selector" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#MinBy">Assert.AreEqual ("forty-two",
		new[] {
			new {A = "forty-two",   B = 42},
			new {A = "forty-three", B = 43},
		}.MinBy (i =&gt; i.B).A);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="selector" /> is 
          <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
                <paramref name="self" /> contained no elements.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <typeparam name="TValue">
          The type of the value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to find the minimum value from.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource, TValue}" /> used to produce a
          value for comparison.
        </param>
            <summary>
          Gets the min element of <paramref name="self" />, based on the result 
          of using the default comparer on the result of 
          <paramref name="selector" />.
        </summary>
            <returns>
          The element from <paramref name="self" /> which has the smallest
          value from <paramref name="selector" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#MinBy">Assert.AreEqual ("forty-two",
		new[] {
			new {A = "forty-two",   B = 42},
			new {A = "forty-three", B = 43},
		}.MinBy (i =&gt; i.B).A);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="selector" /> is 
          <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
                <paramref name="self" /> contained no elements.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <typeparam name="TValue">
          The type of the value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to find the minimum value from.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{TSource, TValue}" /> used to produce a
          value for comparison.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IComparer{TValue}" />
          to use to compare values to determine the minimum value.
        </param>
            <summary>
          Gets the min element of <paramref name="self" />, based on the result 
          of using the specified <paramref name="comparer" /> on the result of 
          <paramref name="selector" />.
        </summary>
            <returns>
          The element from <paramref name="self" /> which has the smallest
          value from <paramref name="selector" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#MinBy">Assert.AreEqual ("forty-two",
		new[] {
			new {A = "forty-two",   B = 42},
			new {A = "forty-three", B = 43},
		}.MinBy (i =&gt; i.B).A);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="selector" /> is 
          <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
                <paramref name="self" /> contained no elements.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.NotNull``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{System.Nullable{TSource}}" />
          containing the sequence to retrieve the non-<see langword="null" />
          elements from.
        </param>
            <summary>
          Retrieves the non-<see langword="null" /> elements from the sequence.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the non-<see langword="null" /> elements from
          <paramref name="self" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#NotNull">IEnumerable&lt;int?&gt; s = new int?[]{
	null,
	2,
	null,
	4
};
Assert.IsTrue (new []{
		2, 4
}.SequenceEqual (s.NotNull ()));
</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Or(System.Collections.Generic.IEnumerable{System.Boolean})">
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{System.Boolean}" />
          containing the values to boolean-OR together.
        </param>
            <summary>Boolean-ORs a sequence together.</summary>
            <returns>
                <see langword="true" /> if any of the elements in the sequence is
          <see langword="true" />; otherwise, <paramref name="self" /> is a
          sequence of finite length and all of the elements are
          <see langword="false" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Or">Assert.AreEqual (true,
		new[]{true, false, true, true}.Or ());
Assert.AreEqual (false,
		new[]{false, false, false, false}.Or ());
Assert.AreEqual (true,
		new[]{true, true, true, true}.Or ());
Assert.AreEqual (true,
		new[]{false, false, true}.Concat (Sequence.Repeat (false)).Or ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.OrderByNatural``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to order naturally.
        </param>
            <param name="func">
          A <see cref="T:System.Func{TSource,System.String}" /> to use to
          convert an element into a <see cref="T:System.String" />, as natural
          ordering is done in terms of strings.
        </param>
            <summary>
          Orders the elements of a sequence in natural order.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          in which the elements have been sorted in natural order.
        </returns>
            <remarks>
                <para>
            "Natural Ordering" orders embedded numeric data as humans would
            sort, not as computers would sort. For example, "2" comes before
            "10", not afterward as is typically the case.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#OrderByNatural">string[] expected = {
	"a.1.b.2.c.3.d.4.e.5.f.6.g.7.h.8.i.9.j.10.k.11",
	"a.1.b.2.c.3.d.4.e.5.f.6.g.7.h.8.i.9.j.10.k.12",
	"bar",
	"foo",
	"foo",
	"foo1",
	"foo2",
	"foo3",
	"foo4",
	"foo5",
	"foo6",
	"foo7",
	"foo8",
	"foo9",
	"foo10",
};
IEnumerable&lt;string&gt; actual = new[]{
	"foo",
	"foo",
	"foo10",
	"foo1",
	"foo4",
	"foo2",
	"foo3",
	"foo9",
	"foo5",
	"foo7",
	"foo8",
	"foo6",
	"bar",
	"a.1.b.2.c.3.d.4.e.5.f.6.g.7.h.8.i.9.j.10.k.12",
	"a.1.b.2.c.3.d.4.e.5.f.6.g.7.h.8.i.9.j.10.k.11",
}.OrderByNatural (s =&gt; s);

AssertAreSame (expected, actual);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="func" />
          is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to partition into elements which match
          <paramref name="predicate" /> and those which do not.
        </param>
            <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> which is used
          to partition <paramref name="self" /> into the set of elements for
          which <paramref name="predicate" /> returns <see langword="true" />
          and those for which <paramref name="predicate" /> returns
          <see langword="false" />.
        </param>
            <summary>
          Partitions <paramref name="self" /> into two sequences, those which
          contain elements satisfying <paramref name="predicate" /> and those
          which do not.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />
          in which
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}.Item1" />
          contains the elements from <paramref name="self" /> which satisfy
          <paramref name="predicate" />, and
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}.Item2" />
          contains the elements which do not satisfy <paramref name="predicate" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Partition">Tuple&lt;IEnumerable&lt;int&gt;, IEnumerable&lt;int&gt;&gt; r =
	Enumerable.Range (1,6).Partition (x =&gt; x % 2 == 0);
Assert.IsTrue (new[]{2, 4, 6}.SequenceEqual (r.Item1));
Assert.IsTrue (new[]{1, 3, 5}.SequenceEqual (r.Item2));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="predicate" /> are <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.PathCombine(System.Collections.Generic.IEnumerable{System.String})">
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the values to combine into a path name.
        </param>
            <summary>
          Creates a path string by concatenating the elements of
          <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.String" /> which is the result of combining
          all the elements within <paramref name="self" /> into a path name.
        </returns>
            <remarks>
                <block subset="none" type="behaviors">
            For each element within <paramref name="self" />, if the
            current element is rooted
            (<see cref="M:System.IO.Path.IsPathRooted(System.String)" />),
            then the current path string is dropped and the current element
            becomes the new path root.  Otherwise,
            <see cref="F:System.IO.Path.DirectorySeparatorChar" /> is
            appended to the current path string and the current element
            is appended.
          </block>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#PathCombine">var data = new [] {"a", "b", "c"};
var result = string.Format ("a{0}b{0}c", Path.DirectorySeparatorChar);
Assert.AreEqual (result, data.PathCombine ());

data = new [] { "a", String.Empty, "b", "c" };
Assert.AreEqual (result, data.PathCombine (), "empty elemetns");

string rooted = Path.DirectorySeparatorChar + "d";
data = new [] { "a", rooted };
Assert.AreEqual (rooted, data.PathCombine (), "rooted path2");

data = new [] { "a", "b", rooted, "c" };
string expected = Path.Combine (Path.Combine (Path.Combine ("a", "b"), rooted), "c");
Assert.AreEqual (expected, data.PathCombine (), "rooted path2 (complex)");

string end1 = "d" + Path.DirectorySeparatorChar;
data = new [] { rooted, end1, "e" };
expected = Path.Combine (Path.Combine (rooted, end1), "e");
Assert.AreEqual (expected, data.PathCombine (), "DirectorySeparatorChar");

string end2 = "d" + Path.AltDirectorySeparatorChar;
data = new [] { rooted, end2, "f" };
expected = Path.Combine (Path.Combine (rooted, end2), "f");
Assert.AreEqual (expected, data.PathCombine (), "AltDirectorySeparatorChar");

data = new [] { "a" };
Assert.AreEqual (Path.Combine ("a", String.Empty), data.PathCombine (), "single string");

data = new [] { String.Empty };
Assert.AreEqual (Path.Combine (String.Empty, String.Empty), data.PathCombine (), "single empty string");
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
          An element of <paramref name="self" /> contains an invalid path
          character; see <see cref="M:System.IO.Path.GetInvalidPathChars" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
            An element within <paramref name="self" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrence``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the first element
          equal to <paramref name="value" />.
        </param>
            <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove once from <paramref name="self" />.
        </param>
            <summary>
          Removes the first occurrence of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first occurrence of
          <paramref name="value" /> has been removed.
        </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <c><paramref name="self" />.RemoveFirstOccurrence(<paramref name="value" />,
            <see langword="null" />)</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#RemoveFirstOccurrence">Assert.AreEqual ("bnana",
		"banana".RemoveFirstOccurrence ('a').Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrence``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrence``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the first element
          equal to <paramref name="value" />.
        </param>
            <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove once from <paramref name="self" />.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IEqualityComparer{TSource}" />
          to use when comparing elements from <paramref name="self" />
          to <paramref name="value" />. If <see langword="null" /> then
          <see cref="P:System.Collections.Generic.EqualityComparer{TSource}.Default" />
          is used.
        </param>
            <summary>
          Removes the first occurrence of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first occurrence of
          <paramref name="value" /> has been removed.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#RemoveFirstOccurrence">Assert.AreEqual ("bnana",
		"banana".RemoveFirstOccurrence ('a').Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrences``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32)">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the leading elements
          equal to <paramref name="value" /> from.
        </param>
            <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove from the start of <paramref name="self" />.
        </param>
            <param name="count">
          A <see cref="T:System.Int32" /> containing the number
          of <paramref name="value" /> elements to remove from
          <paramref name="self" />.
        </param>
            <summary>
          Removes the first <paramref name="count" /> occurrences of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first <paramref name="count" /> occurrences of
          <paramref name="value" /> have been removed.
        </returns>
            <remarks>
                <para>
            This is equivalent to calling
            <c><paramref name="self" />.RemoveFirstOccurrences(<paramref name="value" />,
            <paramref name="count" />, <see langword="null" />)</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#RemoveFirstOccurrences">Assert.AreEqual ("bnna",
		"banana".RemoveFirstOccurrences ('a', 2).Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="count" /> is negative.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrences``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32,System.Collections.Generic.IEqualityComparer{``0})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.RemoveFirstOccurrences``1(System.Collections.Generic.IEnumerable{``0},``0,System.Int32,System.Collections.Generic.IEqualityComparer{``0})">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence from which to remove the leading elements
          equal to <paramref name="value" /> from.
        </param>
            <param name="value">
          A <typeparamref name="TSource" /> which is the value
          to remove from the start of <paramref name="self" />.
        </param>
            <param name="count">
          A <see cref="T:System.Int32" /> containing the number
          of <paramref name="value" /> elements to remove from
          <paramref name="self" />.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IEqualityComparer{TSource}" />
          to use when comparing elements from <paramref name="self" />
          and <paramref name="value" />. If <see langword="null" /> then
          <see cref="P:System.Collections.Generic.EqualityComparer{TSource}.Default" />
          is used.
        </param>
            <summary>
          Removes the first <paramref name="count" /> occurrences of
          <paramref name="value" /> from the sequence <paramref name="self" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which is a copy of <paramref name="self" />
          in which the first <paramref name="count" /> occurrences of
          <paramref name="value" /> have been removed.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#RemoveFirstOccurrences">Assert.AreEqual ("bnna",
		"banana".RemoveFirstOccurrences ('a', 2).Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="count" /> is negative.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Repeat``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <typeparam name="TSource">
          The type of the elements in <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to repeat.
        </param>
            <param name="number">
          The number of times to repeat <paramref name="self" />.
        </param>
            <summary>
          Repeats the sequence <paramref name="self" /> for
          <paramref name="number" /> repetitions.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          sequence containing
          <c><paramref name="count" /> * <paramref name="self" />.Count()</c>
          elements, consisting of the sequence <paramref name="self" />,
          followed by the sequence <paramref name="self" />, etc.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Repeat">Assert.AreEqual ("foofoofoo", new [] {"foo"}.Repeat (3).Implode ());
Assert.AreEqual ("foobarfoobar", new [] {"foo", "bar"}.Repeat (2).Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectAggregated``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,Cadenza.Tuple{``1,``2}})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <typeparam name="TAccumulate">
          The type of the accumulator value.
        </typeparam>
            <typeparam name="TResult">
          The type of the return value.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to return the values of successive
          <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
          and
          <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
          calls from.
        </param>
            <param name="seed">
          The first <typeparamref name="TAccumulate" /> value to pass to
          <paramref name="func" />.
        </param>
            <param name="func">
          A
          <see cref="T:System.Func{TAccumulate,TSource,Cadenza.Tuple{TAccumulate,TResult}}" />
          which is applied against each element within <paramref name="self" />
          and the current <paramref name="TAccumulate" />
          value (initially using <paramref name="seed" />), generating the
          next accumulated value and the (partial) result value.
        </param>
            <summary>
          Applies <paramref name="func" /> to each element within
          <paramref name="self" />, returning the final
          value of the accumulator and the list of intermediate values.
        </summary>
            <returns>
          A
          <see cref="T:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}" />
          which contains the final accumulated value in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item1" />
          and the list of intermediate results in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item2" />.
        </returns>
            <remarks>
                <para>This is Haskell's <c>mapAccumL</c>.</para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectAggregated">IEnumerable&lt;int&gt; s = new []{2, 3, 4, 5};
Tuple&lt;int, List&lt;string&gt;&gt; r = s.SelectAggregated (1,
		(a,b) =&gt; Tuple.Create (a-b, "s" + (a-b)));
Assert.AreEqual (-13, r.Item1);
Assert.IsTrue (new[]{
		"s-1",
		"s-4",
		"s-8",
		"s-13",
}.SequenceEqual (r.Item2));

r = new int[]{}.SelectAggregated (42,
		(a,b) =&gt; Tuple.Create (a-b, b.ToString ()));
Assert.AreEqual (42, r.Item1);
Assert.AreEqual (0, r.Item2.Count);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="func" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectBreadthFirst``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of the root nodes and intermediate nodes of the tree.
        </typeparam>
            <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to perform a breadth-first traversal on.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
            <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of <paramref name="root" />
          and all intermediate non-leaf nodes.
        </param>
            <summary>
          Traverse a sequence of nodes in a breadth-first fashion, converting each
          encountered node.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the result of applying <paramref name="valueSelector" />
          to all nodes encountered while traversing the forest
          <paramref name="self" /> in a breadth-first fashion.
        </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is a "forest", a sequence of tree roots
            (siblings), wherein each
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via
            <paramref name="childrenSelector" />.
          </para>
                <para>
            Each node is traversed in a breadth-first fashion, with each
            encountered node is provided to <paramref name="valueSelector" />,
            and the values are returned.
          </para>
            </remarks>
            <example>
                <para>
            Given the <c>TreeNode&lt;T&gt;</c> declaration:
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#TreeNode_Declaration">class TreeNode&lt;T&gt;
{
	public TreeNode ()
	{
		Children = new TreeNode&lt;T&gt; [0];
	}

	public T Value;
	public IEnumerable&lt;TreeNode&lt;T&gt;&gt; Children;
}
</code>
                <para>
                    <c>SelectBreadthFirst()</c> is used as:
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectBreadthFirst">TreeNode&lt;int&gt;[] root = new TreeNode&lt;int&gt;[] {
	new TreeNode&lt;int&gt; {
		Value = 1, Children = new [] {
			new TreeNode&lt;int&gt; { Value = 2 },
			new TreeNode&lt;int&gt; {
				Value = 3, Children = new [] {
					new TreeNode&lt;int&gt; { Value = 5 },
				}
			},
			new TreeNode&lt;int&gt; { Value = 4 },
		}
	},
	new TreeNode&lt;int&gt; { Value = -1 },
};
IEnumerable&lt;int&gt; values = root
	.SelectBreadthFirst (x =&gt; x.Value, x =&gt; x.Children);
AssertAreSame (new[]{ 1, 2, 3, 4, 5, -1 }, values);
</code>
            </example>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectDepthFirst``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of the root nodes and intermediate nodes of the tree.
        </typeparam>
            <typeparam name="TResult">
          The type of the object to return.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to perform a depth-first traversal on.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TResult}" /> which is used to
          convert tree nodes into <typeparamref name="TResult" /> instances.
        </param>
            <param name="childrenSelector">
          A <see cref="T:System.Func{TSource,System.Collections.Generic.IEnumerable{TSource}}" />
          which returns the child nodes of an element in
          <paramref name="self" /> (and grand-children, and
          great-grandchildren, and...).
        </param>
            <summary>
          Traverse a sequence of nodes in a depth-first fashion, converting each
          encountered node.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the result of applying <paramref name="valueSelector" />
          to all nodes encountered while traversing the forest
          <paramref name="self" /> in a depth-first fashion.
        </returns>
            <remarks>
                <para>
                    <paramref name="self" /> is a "forest", a sequence of tree roots
            (siblings), wherein each
            node is a data structure containing a value and child nodes.
            The value is retrieved via <paramref name="valueSelector" />,
            and the children are obtained via
            <paramref name="childrenSelector" />.
          </para>
                <para>
            The tree is traversed in a depth-first fashion, each encountered
            node is provided to <paramref name="valueSelector" />, and the
            values are returned.
          </para>
            </remarks>
            <example>
                <para>
            Given the <c>TreeNode&lt;T&gt;</c> declaration:
          </para>
                <code lang="C#" src="../../Test/Cadenza/ObjectCodaTest.cs#TreeNode_Declaration">class TreeNode&lt;T&gt;
{
	public TreeNode ()
	{
		Children = new TreeNode&lt;T&gt; [0];
	}

	public T Value;
	public IEnumerable&lt;TreeNode&lt;T&gt;&gt; Children;
}
</code>
                <para>
                    <c>SelectDepthFirst()</c> is used as:
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectDepthFirst">TreeNode&lt;int&gt;[] root = new TreeNode&lt;int&gt;[] {
	new TreeNode&lt;int&gt; {
		Value = 1, Children = new [] {
			new TreeNode&lt;int&gt; { Value = 2 },
			new TreeNode&lt;int&gt; {
				Value = 3, Children = new [] {
					new TreeNode&lt;int&gt; { Value = 5 },
				}
			},
			new TreeNode&lt;int&gt; { Value = 4 },
		}
	},
	new TreeNode&lt;int&gt; { Value = -1 },
};
IEnumerable&lt;int&gt; values = root
	.SelectDepthFirst (x =&gt; x.Value, x =&gt; x.Children);
AssertAreSame (new[]{ 1, 2, 3, 5, 4, -1 }, values);
</code>
            </example>
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="childrenSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
            <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
            <typeparam name="TResult">
          The type of value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
            <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{T1,T2,TResult}" /> which is used to
          transform the corresponding elements from lists
          <paramref name="self" /> and <paramref name="source2" />
          into the returned value.
        </param>
            <summary>
          Projects each corresponding element from multiple sequences into a 
          new form.
        </summary>
            <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          whose elements are the resulting of invoking
          <paramref name="selector" /> on each corresponding element of 
          <paramref name="self" /> and <paramref name="source2" />.
        </returns>
            <remarks>
                <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
            where each <typeparamref name="TResult" /> value is the result of
            applying <paramref name="selector" /> to an element from each of
            <paramref name="self" />, and <paramref name="source2" />
            with the same element index.
          </para>
                <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" /> and <paramref name="source2" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectFromEach2">List&lt;int&gt;  a = new List&lt;int&gt; {1, 2, 3, 4};
List&lt;char&gt; b = new List&lt;char&gt; {'a', 'b', 'c', 'd', 'e'};
var c = a.SelectFromEach (b, (x, y) =&gt; new { First = x, Second = y }).ToList ();
Assert.AreEqual (4, c.Count);
Assert.AreEqual (1,   c [0].First);
Assert.AreEqual ('a', c [0].Second);
Assert.AreEqual (2,   c [1].First);
Assert.AreEqual ('b', c [1].Second);
Assert.AreEqual (3,   c [2].First);
Assert.AreEqual ('c', c [2].Second);
Assert.AreEqual (4,   c [3].First);
Assert.AreEqual ('d', c [3].Second);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />, <paramref name="source2" />, or
          <paramref name="selector" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
            <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
            <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
            <typeparam name="TResult">
          The type of value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
            <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
            <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{T1,T2,T3,TResult}" /> which is used to
          transform the corresponding elements from lists
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />
          into the returned value.
        </param>
            <summary>
          Projects each corresponding element from multiple sequences into a 
          new form.
        </summary>
            <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          whose elements are the resulting of invoking
          <paramref name="selector" /> on each corresponding element of 
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
        </returns>
            <remarks>
                <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
            where each <typeparamref name="TResult" /> value is the result of
            applying <paramref name="selector" /> to an element from each of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />
            with the same element index.
          </para>
                <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectFromEach3">Assert.AreEqual ("123",
		new[]{1}.SelectFromEach (new[]{2}, new[]{3}, 
			(x,y,z) =&gt; x.ToString () + y.ToString () + z.ToString ()).Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, or
          <paramref name="selector" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})">
            <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
            <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
            <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
            <typeparam name="T4">
          The type of elements in the fourth list.
        </typeparam>
            <typeparam name="TResult">
          The type of value returned by <paramref name="selector" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
            <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
            <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
            <param name="source4">
          A <see cref="T:System.Collections.Generic.IEnumerable{T4}" />
          containing elements from the fourth list.
        </param>
            <param name="selector">
          A <see cref="T:System.Func{T1,T2,T3,T4,TResult}" /> which is used to
          transform the corresponding elements from lists
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />
          into the returned value.
        </param>
            <summary>
          Projects each corresponding element from multiple sequences into a 
          new form.
        </summary>
            <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          whose elements are the resulting of invoking
          <paramref name="selector" /> on each corresponding element of 
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
        </returns>
            <remarks>
                <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
            where each <typeparamref name="TResult" /> value is the result of
            applying <paramref name="selector" /> to an element from each of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />
            with the same element index.
          </para>
                <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectFromEach4">Assert.AreEqual ("1234",
		new[]{1}.SelectFromEach (new[]{2}, new[]{3}, new[]{4},
			(w,x,y,z) =&gt; w.ToString () + x.ToString () + y.ToString () + z.ToString ()).Implode ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, <paramref name="source4" />, or
          <paramref name="selector" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SelectReverseAggregated``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,Cadenza.Tuple{``1,``2}})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <typeparam name="TAccumulate">
          The type of the accumulator value.
        </typeparam>
            <typeparam name="TResult">
          The type of the return value.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to return the values of successive
          <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
          and
          <see cref="M:Cadenza.Collections.EnumerableCoda.AggregateReverse``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
          calls from.
        </param>
            <param name="seed">
          The first <typeparamref name="TAccumulate" /> value to pass to
          <paramref name="func" />.
        </param>
            <param name="func">
          A
          <see cref="T:System.Func{TAccumulate,TSource,Cadenza.Tuple{TAccumulate,TResult}}" />
          which is applied against each element within <paramref name="self" />
          in reverse order and the current <paramref name="TAccumulate" />
          value (initially using <paramref name="seed" />), generating the
          next accumulated value and the (partial) result value.
        </param>
            <summary>
          Applies <paramref name="func" /> to each element within
          <paramref name="self" /> in reverse order, returning the final
          value of the accumulator and the list of intermediate values.
        </summary>
            <returns>
          A
          <see cref="T:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}" />
          which contains the final accumulated value in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item1" />
          and the list of intermediate results in
          <see cref="P:Cadenza.Tuple{TAccumulate,System.Collections.Generic.List{TResult}}.Item2" />.
        </returns>
            <remarks>
                <para>This is Haskell's <c>mapAccumR</c>.</para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SelectReverseAggregated">IEnumerable&lt;int&gt; s = new []{1, 2, 3, 4};
Tuple&lt;int, List&lt;string&gt;&gt; r = s.SelectReverseAggregated (5,
		(a,b) =&gt; Tuple.Create (a-b, "s" + (a-b)));
Assert.AreEqual (-5, r.Item1);
Assert.IsTrue (new[]{
	"s1",
	"s-2",
	"s-4",
	"s-5",
}.SequenceEqual (r.Item2));

r = new int[]{}.SelectReverseAggregated (42,
		(a,b) =&gt; Tuple.Create (a-b, b.ToString ()));
Assert.AreEqual (42, r.Item1);
Assert.AreEqual (0, r.Item2.Count);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="func" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SequenceCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="list" />.
        </param>
            <param name="list">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="self" />.
        </param>
            <summary>
          Compares the elements of two sequences by using the default
          comparer for their type.
        </summary>
            <returns>
          An <see cref="T:System.Int32" /> which is:
          <list type="table"><listheader><term>Value</term><description>Condition</description></listheader><item><term>Less than zero</term><description>
                The default comparer
                returned less than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="self" /> had more elements than
                <paramref name="list" /> (and all elements in
                <paramref name="list" /> were equal to their corresponding
                elements within <paramref name="self" />).
              </description></item><item><term>Zero</term><description>
                The default comparer
                returned zero for all elements whe comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                and <paramref name="self" /> and <paramref name="list" />
                have the same number of elements.
              </description></item><item><term>Greater than zero</term><description>
                The default comparer
                returned greater than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="list" /> had more elements than
                <paramref name="self" /> (and all elements in
                <paramref name="self" /> were equal to their corresponding
                elements within <paramref name="list" />).
              </description></item></list></returns>
            <remarks>
                <para>
            This is the
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />
            analog to
            <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />.
          </para>
                <para>
            This method enumerates <paramref name="self" /> and
            <paramref name="list" /> in parallel and compares corresponding
            elements by using the default
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />.
            It returns non-zero the first time the default comparer
            returns non-zero.  If it runs out of elements, then it will return
            less than zero if <paramref name="self" /> still contains elements,
            will return zero if neither <paramref name="self" /> nor
            <paramref name="list" /> contain elements, and will return greater
            than zero if <paramref name="list" /> still contains elements.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SequenceCompare">Assert.AreEqual (0,
		new[]{1, 2}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 1}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (1,
		new[]{1, 3}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 2}.SequenceCompare (new[]{1}));
Assert.AreEqual (1,
		new[]{1}.SequenceCompare (new[]{1, 2}));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="list" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.SequenceCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SequenceCompare``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="list" />.
        </param>
            <param name="list">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to compare against <paramref name="self" />.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IComparer{TSource}" />
          which is used to compare elements from <paramref name="self" />
          and <paramref name="list" /> are to each other.  If
          <see langword="null" />, then
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          is used.
        </param>
            <summary>
          Compares the elements of two sequences by using a specified
          <see cref="T:System.Collections.Generic.IComparer{TSource}" />.
        </summary>
            <returns>
          An <see cref="T:System.Int32" /> which is:
          <list type="table"><listheader><term>Value</term><description>Condition</description></listheader><item><term>Less than zero</term><description><c><paramref name="comparer" />.Compare(x, y)</c>
                returned less than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="self" /> had more elements than
                <paramref name="list" /> (and all elements in
                <paramref name="list" /> were equal to their corresponding
                elements within <paramref name="self" />).
              </description></item><item><term>Zero</term><description><c><paramref name="comparer" />.Compare(x, y)</c>
                returned zero for all elements whe comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                and <paramref name="self" /> and <paramref name="list" />
                have the same number of elements.
              </description></item><item><term>Greater than zero</term><description><c><paramref name="comparer" />.Compare(x, y)</c>
                returned greater than zero when comparing element
                <c>x</c> at index <c>i</c> from sequence <paramref name="self" />
                against element
                <c>y</c> at index <c>i</c> from sequence <paramref name="list" />,
                or <paramref name="list" /> had more elements than
                <paramref name="self" /> (and all elements in
                <paramref name="self" /> were equal to their corresponding
                elements within <paramref name="list" />).
              </description></item></list></returns>
            <remarks>
                <para>
            This is the
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />
            analog to
            <see cref="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />.
          </para>
                <para>
            This method enumerates <paramref name="self" /> and
            <paramref name="list" /> in parallel and compares corresponding
            elements by using the specified
            <see cref="T:System.Collections.Generic.IComparer{TSource}" />.
            It returns non-zero the first time <paramref name="comparer" />
            returns non-zero.  If it runs out of elements, then it will return
            less than zero if <paramref name="self" /> still contains elements,
            will return zero if neither <paramref name="self" /> nor
            <paramref name="list" /> contain elements, and will return greater
            than zero if <paramref name="list" /> still contains elements.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SequenceCompare">Assert.AreEqual (0,
		new[]{1, 2}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 1}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (1,
		new[]{1, 3}.SequenceCompare (new[]{1, 2}));
Assert.AreEqual (-1,
		new[]{1, 2}.SequenceCompare (new[]{1}));
Assert.AreEqual (1,
		new[]{1}.SequenceCompare (new[]{1, 2}));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="list" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Shuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
            <summary>
          Randomizes the ordering of items within <paramref name="self" />.
        </summary>
            <returns>
          A new <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          with the same number of elements as <paramref name="self" /> except
          that the elements returned may be in a different order.  The order of
          the elements returned is controlled by <paramref name="random" />.
        </returns>
            <remarks>
                <para>
            This is equivalent to calling <c>Shuffle(self, null)</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Shuffle">IEnumerable&lt;int&gt; r = new[]{1,2,3,4,5}.Shuffle ();
Assert.AreEqual (5, r.Count());
Assert.IsTrue (r.Contains (1));
Assert.IsTrue (r.Contains (2));
Assert.IsTrue (r.Contains (3));
Assert.IsTrue (r.Contains (4));
Assert.IsTrue (r.Contains (5));

Assert.IsFalse (r.Contains (0));
Assert.IsFalse (r.Contains (6));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Random)">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
            <param name="random">
          A <see cref="T:System.Random" /> instance to get random numbers from.
        </param>
            <summary>
          Randomizes the ordering of items within <paramref name="self" />.
        </summary>
            <returns>
          A new <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          with the same number of elements as <paramref name="self" /> except
          that the elements returned may be in a different order.  The order of
          the elements returned is controlled by <paramref name="random" />.
        </returns>
            <remarks>
                <block subset="none" type="behaviors">
            Calls <see cref="M:System.Random.Next(System.Int32)" />
            once for each element within <paramref name="self" /> to partially
            determine the element's position within the returned sequence, then
            creates a new sequence based on the random element ordering.
          </block>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Shuffle">IEnumerable&lt;int&gt; r = new[]{1,2,3,4,5}.Shuffle ();
Assert.AreEqual (5, r.Count());
Assert.IsTrue (r.Contains (1));
Assert.IsTrue (r.Contains (2));
Assert.IsTrue (r.Contains (3));
Assert.IsTrue (r.Contains (4));
Assert.IsTrue (r.Contains (5));

Assert.IsFalse (r.Contains (0));
Assert.IsFalse (r.Contains (6));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SkipPrefix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
            <param name="prefix">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove from the start of
          <paramref name="self" />.
        </param>
            <summary>
          Skips over <paramref name="prefix" />, returning the elements following
          <paramref name="prefix" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          if <paramref name="self" /> begins with <paramref name="prefix" />
          which contains the elements within <paramref name="self" /> following
          the sequence within <paramref name="prefix" />.
          If <paramref name="self" /> does not start with
          <paramref name="prefix" />, then <see langword="null" /> is returned.
        </returns>
            <remarks>
                <para>
            This is equivalent to calling <c>SkipPrefix(self, prefix, null).</c></para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SkipPrefix">Assert.AreEqual ("bar",
		"foobar".SkipPrefix ("foo").Implode ());
Assert.AreEqual ("",
		"foo".SkipPrefix ("foo").Implode ());
Assert.AreEqual (null,
		"barfoo".SkipPrefix ("foo"));
Assert.AreEqual (null,
		"barfoobaz".SkipPrefix ("foo"));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="prefix" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.SkipPrefix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SkipPrefix``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove <paramref name="prefix" /> from.
        </param>
            <param name="prefix">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to remove from the start of
          <paramref name="self" />.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IEqualityComparer{TSource}" />
          to use to compare elements between the <paramref name="self" />
          and <paramref name="prefix" /> sequences.  If <see langword="null" />
          then
          <see cref="P:System.Collections.Generic.EqualityComparer{TSource}.Default" />
          is used.
        </param>
            <summary>
          Skips over <paramref name="prefix" />, returning the elements following
          <paramref name="prefix" />.
        </summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          if <paramref name="self" /> begins with <paramref name="prefix" />
          which contains the elements within <paramref name="self" /> following
          the sequence within <paramref name="prefix" />.
          If <paramref name="self" /> does not start with
          <paramref name="prefix" />, then <see langword="null" /> is returned.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SkipPrefix">Assert.AreEqual ("bar",
		"foobar".SkipPrefix ("foo").Implode ());
Assert.AreEqual ("",
		"foo".SkipPrefix ("foo").Implode ());
Assert.AreEqual (null,
		"barfoo".SkipPrefix ("foo"));
Assert.AreEqual (null,
		"barfoobaz".SkipPrefix ("foo"));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="prefix" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Sort``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the sequence to sort by the default comparer.
        </param>
            <summary>Sorts the elements in the sequence <paramref name="self" /> using the default comparer.</summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the elements within <paramref name="self" /> sorted by
          the default comparer.
        </returns>
            <remarks>
                <para>
            Use this method instead of the
            <see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            method when you don't need to do anything "fancy," as this can
            result in faster execution.  For example, when sorting 20 million
            integers, the <c>Sort()</c> extension method can be upwards of 4x
            faster than the equivalent <c>OrderBy(e =&gt; e)</c> extension method call.
          </para>
                <block subset="none" type="behaviors">
            This method creates a
            <see cref="T:System.Collections.Generic.List{TSource} " />
            over <paramref name="self" />, invokes
            <see cref="M:System.Collections.Generic.List{TSource}.Sort" />
            and returns the list.
          </block>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
          The default comparer
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          cannot find ain implementation of the
          <see cref="T:System.Collections.Generic.IComparer{TSource}" />
          generic interface or the
          <see cref="T:System.Collections.IComparer" />
          interface for the type <typeparamref name="TSource" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IComparer{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the sequence to sort by the default comparer.
        </param>
            <param name="comparer">
          A <see cref="T:System.Collections.Generic.IComparer{TSource} " />
          instance which is used to sort the elements within
          <paramref name="self" />.
          If <see langword="null" />, then
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          is used.
        </param>
            <summary>Sorts the elements in the sequence <paramref name="self" /> using the specified comparer.</summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the elements within <paramref name="self" /> sorted by
          the default comparer.
        </returns>
            <remarks>
                <para>
            Use this method instead of the
            <see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
            method when you don't need to do anything "fancy," as this can
            result in faster execution.  For example, when sorting 20 million
            integers, the <c>Sort()</c> extension method can be upwards of 4x
            faster than the equivalent <c>OrderBy(e =&gt; e)</c> extension method call.
          </para>
                <block subset="none" type="behaviors">
            This method creates a
            <see cref="T:System.Collections.Generic.List{TSource} " />
            over <paramref name="self" />, invokes
            <see cref="M:System.Collections.Generic.List{TSource}.Sort(System.Collections.Generic.IComparer{`0})" />
            and returns the list.
          </block>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.InvalidOperationException">
                <paramref name="comparer" /> is <see langword="null" />
          and the default comparer
          <see cref="P:System.Collections.Generic.Comparer{TSource}.Default" />
          cannot find ain implementation of the
          <see cref="T:System.Collections.Generic.IComparer{TSource}" />
          generic interface or the
          <see cref="T:System.Collections.IComparer" />
          interface for the type <typeparamref name="TSource" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Sort``1(System.Collections.Generic.IEnumerable{``0},System.Comparison{``0})">
            <typeparam name="TSource">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the sequence to sort by the default comparer.
        </param>
            <param name="comparison">
          A <see cref="T:System.Comparison{TSource} " />
          instance which is used to sort the elements within
          <paramref name="self" />.
        </param>
            <summary>Sorts the elements in the sequence <paramref name="self" /> using the specified comparer.</summary>
            <returns>
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource} " />
          containing the elements within <paramref name="self" /> sorted by
          the default comparer.
        </returns>
            <remarks>
                <para>
            Use this method instead of the
            <see cref="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            method when you don't need to do anything "fancy," as this can
            result in faster execution.  For example, when sorting 20 million
            integers, the <c>Sort()</c> extension method can be upwards of 4x
            faster than the equivalent <c>OrderBy(e =&gt; e)</c> extension method call.
          </para>
                <block subset="none" type="behaviors">
            This method creates a
            <see cref="T:System.Collections.Generic.List{TSource} " />
            over <paramref name="self" />, invokes
            <see cref="M:System.Collections.Generic.List{TSource}.Sort(System.Comparer{`0})" />
            and returns the list.
          </block>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="comparison" />
          is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentException">
          The implementation of <paramref name="comparison" /> caused an error
          during the sort.  For example, <paramref name="comparison" /> might
          not return <c>0</c> when comparing an item with itself.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SortNatural(System.Collections.Generic.IEnumerable{System.String})">
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the elements to sort.
        </param>
            <summary>
          Returns a new 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which contains the elements within <paramref name="self" /> sorted 
          using the
          <see cref="F:Cadenza.NaturalStringComparer.Default" /> comparer.
        </summary>
            <returns>
          A new 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          which contains the elements within <paramref name="self" /> sorted 
          using the
          <see cref="F:Cadenza.NaturalStringComparer.Default" /> comparer.
        </returns>
            <remarks>
                <para>
            This method does not modify <paramref name="self" />.
          </para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Span``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to create a span of.
        </param>
            <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> which
          controls which elements from <paramref name="self" /> are present
          within the returned 
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._1" />.
          sequence.
        </param>
            <summary>
          Creates a 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />
          of the contiguous elements at the start of <paramref name="self" /> 
          which satisfy <paramref name="predicate" />.
        </summary>
            <returns>
          Creates a 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />;
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._1" />
          contains the (possibly empty) sequence of elements at the start of
          <paramref name="self" /> which satisfy <paramref name="predicate" />,
          and
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._2" />
          contains all remaining elements from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This is equivalent to: 
            <c>Tuple.Create (self.TakeWhile (predicate), 
            self.SkipWhile (predicate));</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Span">Assert.AreEqual ("12|341234",
		new[]{1,2,3,4,1,2,3,4}.Span (e =&gt; e &lt; 3)
		.Aggregate ((x, y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|",
		new[]{1,2,3}.Span (e =&gt; e &lt; 9)
		.Aggregate ((x, y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("|123",
		new[]{1,2,3}.Span (e =&gt; e &lt; 0)
		.Aggregate ((x, y) =&gt; x.Implode () + "|" + y.Implode ()));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="predicate" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.SplitAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to split.
        </param>
            <param name="firstLength">
          The number of elements to return in the first created sequence.
        </param>
            <summary>
          Splits <paramref name="self" /> at <paramref name="firstLength" />,
          creating a 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />.
        </summary>
            <returns>
          A 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}" />,
          where 
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._1" />
          contains the first <paramref name="firstLength" /> elements from
          <paramref name="self" />, and 
          <see cref="P:Cadenza.Tuple{System.Collections.Generic.IEnumerable{TSource},System.Collections.Generic.IEnumerable{TSource}}._2" />
          contains the remaining elements from the sequence.
        </returns>
            <remarks>
                <para>
            This is equivalent to 
            <c>Tuple.Create (self.Take (firstLength), 
            self.Skip (firstLength));</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#SplitAt">Assert.AreEqual ("Hello |World!",
		"Hello World!".SplitAt (6)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|45",
		new[]{1,2,3,4,5}.SplitAt (3)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("1|23",
		new[]{1,2,3}.SplitAt (1)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|",
		new[]{1,2,3}.SplitAt (3)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("123|",
		new[]{1,2,3}.SplitAt (4)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
Assert.AreEqual ("|123",
		new[]{1,2,3}.SplitAt (0)
		.Aggregate ((x,y) =&gt; x.Implode () + "|" + y.Implode ()));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="firstLength" /> is negative.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Subsets``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence to create subsets from.
        </param>
            <summary>
          Creates all subsets of a given input sequence.
        </summary>
            <returns>
          An unordered <see cref="T:System.Collections.IEnumerable{System.Collections.IEnumerable{TSource}}" />
          that contains all subsets of <paramref name="source" /> including the set <paramref name="self" /> itself.
        </returns>
            <remarks>
                <para>This creates all subsets from the sequence <paramref name="self" />.</para>
                <para>Sequences greater than 63 items are not supported and will throw a <see cref="T:System.InvalidOperationException" /> when you try to enumerate the results.</para>
                <code>Given the input sequence, [a, b, c] the result would be:
[a]
[b]
[a,b]
[c]
[a,c]
[b,c]
[a,b,c]</code>
                <para>
            Note: This method does not remove duplicates from <paramref name="self" />. If <paramref name="self" /> may contain duplicates and you want true subsets use
            <see cref="T:System.Linq.Enumerable.Distinct{TSource}" /> first, e.g. <c>source.Distinct().Subsets()</c>.
          </para>
                <para>
            Note: This method does not guarantee any order to the results so future implementations may return the results in a different order.
          </para>
                <para>
            Note: This keep the input sizes small, as the result set will contain <c>(n ^ 2) - 1</c> results, eg for 20 items there are 1,048,575 subsets.
          </para>
            </remarks>
            <example>
                <code lang="C#"><![CDATA[List<string> source = new List<string> { "a", "b", "c" };
IEnumerable<IEnumerable<string>> results = source.Subsets ();

foreach (IEnumerable<string> subset in results) {

  foreach (string value in subset) {
    Console.Write (value);
    Console.Write (" ");
  }

  Console.WriteLine ();
}
]]></code>
                <code lang="VB">Dim source As New List (Of String) (New String () { "a", "b", "c" })
Dim results As IEnumerable (Of IEnumerable (Of String)) = source.Subsets ()

For Each subset As IEnumerable (Of String) In results

  For Each value As String In subset
    Console.Write (value)
    Console.Write (" ")
  Next
  
  Console.WriteLine ()
Next
</code>
            </example>
            <exception cref="T:System.ArgumentNullException">
          If <paramref name="self" /> is null (Nothing in VB).
        </exception>
            <exception cref="T:System.InvalidOperationException">
          If <paramref name="self" /> contains more than 63 items. Important, this will only be thrown when you start enumerating the results.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Subsets``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerable{``0},System.Boolean})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> containing the sequence to create subsets from.
        </param>
            <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> used to filter .
        </param>
            <summary>
          Creates all subsets that match <paramref name="predicate" />.
        </summary>
            <returns>
          An unordered <see cref="T:System.Collections.IEnumerable{System.Collections.IEnumerable{TSource}}" /> that contains
          all subsets of <paramref name="source" /> including the set <paramref name="self" /> itself, excluding any sets and
          all their supersets that did not match the <paramref name="predicate" />.
        </returns>
            <remarks>
                <para>
            This creates all subsets from the sequence <paramref name="self" />, excluding any sets and their supersets that were
            filtered out by <paramref name="predicate" />.
          </para>
                <code>Given the input sequence, [a, b, c] and filtering out anything containing the subset [a, b] the result would be:
[a]
[b]
[c]
[a,c]
[b,c]</code>
                <para>
            Note: This method does not remove duplicates from <paramref name="self" />. If <paramref name="self" /> may contain
            duplicates and you want true subsets use <see cref="T:System.Linq.Enumerable.Distinct{TSource}" /> first, e.g.
            <c>source.Distinct().Subsets(predicate)</c>.
          </para>
                <para>
            Note: This method does not guarantee any order to the results so future implementations may return the results in a different order.
          </para>
            </remarks>
            <example>
                <code lang="C#"><![CDATA[List<string> source = new List<string> { "a", "b", "c" };
IEnumerable<IEnumerable<string>> results = source.Subsets (x => !(x.Contains ("a") && x.Contains ("b")));

foreach (IEnumerable<string> subset in results) {

  foreach (string value in subset) {
    Console.Write (value);
    Console.Write (" ");
  }

  Console.WriteLine ();
}
]]></code>
                <code lang="VB">Dim source As New List (Of String) (New String () { "a", "b", "c" })
Dim results As IEnumerable (Of IEnumerable (Of String)) = source.Subsets (Function (x) Not (x.Contains ("a") AndAlso x.Contains ("b")))

For Each subset As IEnumerable (Of String) In results

  For Each value As String In subset
    Console.Write (value)
    Console.Write (" ")
  Next

  Console.WriteLine ()
Next
</code>
            </example>
            <exception cref="T:System.ArgumentNullException">
          If <paramref name="self" /> is null (Nothing in VB).
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Sum``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the values to sum.
        </param>
            <summary>Sums the values in a sequence.</summary>
            <returns>
          A <typeparamref name="TSource" /> containing the summation of the
          values within <paramref name="source" />.
        </returns>
            <remarks>
                <para>
            This is equivalent to calling <c>Sum(self, null)</c>.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Sum">IEnumerable&lt;uint&gt; s = null;
Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; s.Sum ());

s = new []{1U, 2U, 3U};
Assert.AreEqual (6U, s.Sum ());
Assert.AreEqual (6U, s.Sum (null));

IEnumerable&lt;SimpleNumber&gt; s2 = new[]{
	new SimpleNumber (1),
	new SimpleNumber (2),
	new SimpleNumber (3),
};
Assert.AreEqual (new SimpleNumber (6), s2.Sum (new SimpleNumberMath ()));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.NotSupportedException">
                <see cref="P:Cadenza.Numerics.Math{TSource}.Default" />
          could not be loaded.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Sum``1(System.Collections.Generic.IEnumerable{``0},Cadenza.Numerics.Math{``0})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the values to sum.
        </param>
            <param name="m">
          A <see cref="T:Cadenza.Numerics.Math{TSource}" /> to use for summing
          the values within <paramref name="self" />.
          If <see langword="null" />, then
          <see cref="P:Cadenza.Numerics.Math{TSource}.Default" /> is used.
        </param>
            <summary>Sums the values in a sequence.</summary>
            <returns>
          A <typeparamref name="TSource" /> containing the summation of the
          values within <paramref name="source" />.
        </returns>
            <remarks>
                <para>
            This is the "fallback" provider for
            <see cref="M:System.Linq.Enumerable.Sum" />, allowing summation
            over types that LINQ doens't support, such as unsigned types and
            user-defined types which provide appropriate arithmetic operators.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Sum">IEnumerable&lt;uint&gt; s = null;
Assert.Throws&lt;ArgumentNullException&gt;(() =&gt; s.Sum ());

s = new []{1U, 2U, 3U};
Assert.AreEqual (6U, s.Sum ());
Assert.AreEqual (6U, s.Sum (null));

IEnumerable&lt;SimpleNumber&gt; s2 = new[]{
	new SimpleNumber (1),
	new SimpleNumber (2),
	new SimpleNumber (3),
};
Assert.AreEqual (new SimpleNumber (6), s2.Sum (new SimpleNumberMath ()));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.NotSupportedException">
                <paramref name="m" /> is <see langword="null" /> and 
          <see cref="P:Cadenza.Numerics.Math{TSource}.Default" />
          could not be loaded.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Tokens``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,Cadenza.Tuple{``2,``1}},System.Func{``1,``0,System.Boolean}[])">
            <typeparam name="TSource">
          The type of elements within <paramref name="self" />.
        </typeparam>
            <typeparam name="TAccumulate">
          The type of the accumulator value.
        </typeparam>
            <typeparam name="TResult">
          The type of the resulting sequence of values.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the values to aggregate and convert.
        </param>
            <param name="seed">
          The initial accumulator value.
        </param>
            <param name="accumulate">
          A <see cref="T:System.Func{TAccumulate,TSource,TAccumulate}" />
          which is used to accumulate values from <paramref name="self" />
          into one of the values returned.
        </param>
            <param name="resultSelector">
          A <see cref="T:System.Func{TAccumulate,Cadenza.Tuple{TResult,TAccumulate}}" />
          which is used to do two things: convert the accumulated value into a
          return value, and reset the accumulator.
          The <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item1" /> property
          contains the value to return, while
          the <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item2" /> property
          contains the new accumulator seed value.
        </param>
            <param name="categories">
          A <see cref="T:System.Func{TAccumulate,TSource,System.Boolean}" />
          array which contains "categories." A "category" is how
          <c>Tokens</c> knows when to call <paramref name="accumulate" />
          or <paramref name="resultSelector" />.
          If a category returns <see langword="true" /> on an element
          from <paramref name="self" />, then
          <paramref name="accumulate" /> will be invoked; otherwise,
          <paramref name="resultSelector" /> is invoked.
        </param>
            <summary>
          A simple lexer to convert an
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          into a
          <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />,
          where the resulting sequence may have a different number of elements
          than the source sequence.
        </summary>
            <returns>
          An <see cref="T:System.Collections.Generic.IEnumerable{TResult}" />
          containing the resulting "tokens" that
          <paramref name="accumulator" /> and
          <paramref name="resultSelector" /> produced.
        </returns>
            <remarks>
                <para>
            This is either a very simple lexer, or the unholy combination of
            <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
            and
            <see cref="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />.
            You decide.
          </para>
                <para>
                    <c>Tokens</c> allows converting the source sequence
            <paramref name="self" /> of length <c>N</c> into a
            resulting sequence of length <c>M</c>, where <c>N</c>
            can differ from <c>M</c>, and <c>M</c> can be greater than one.
            (This differs from <c>Enumerable.Select()</c>, where the
            resulting sequence has the same number of elements as the source
            sequence, and it differs from <c>Enumerable.Aggregate()</c>,
            where only a single value is returned.)
          </para>
                <block subset="none" type="behaviors">
                    <para>
              For each element in <paramref name="self" />, get the "category index"
              for the element.  The "category index" is the first index into the
              <paramref name="categories" /> array for which a
              <see cref="T:System.Func{TAccumulate,TSource,System.Boolean}" />
              returns <see langword="true" />.  Then one of three things happens:
            </para>
                    <list type="number">
                        <item>
                            <term>
                If the category index is the same as the previous element's
                category index, then <paramref name="accumulate" /> is invoked
                with the current accumulated value and the current element.
              </term>
                        </item>
                        <item>
                            <term>
                If the category index differs from the previous element's
                category index, then <paramref name="resultSelector" />
                is invoked to obtain a
                <see cref="T:Cadenza.Tuple{TResult,TAccumulate}" />.
                The
                <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item1" />
                value is yielded from <c>Tokens</c> as one of the return
                values, and
                <see cref="P:Cadenza.Tuple{TResult,TAccumulate}.Item2" />
                is used as the new seed value for the next
                <paramref name="accumulate" /> call.
              </term>
                        </item>
                        <item>
                            <term>
                If no matching category is found (i.e. all entries in
                <paramref name="categories" />
                return <see langword="false" />),
                then the element is ignored.
              </term>
                        </item>
                    </list>
                    <para>
              This use of "categories" and matching indexes allows for
              implementing precedence rules in a straightforward manner:
              if the category index differs, the accumulated token
              must have a different precedence, and thus should be returned
              and the accumulation process restarted.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Tokens">// Turn a sequence of numbers into a new sequence of numbers
// for which the sum is less than 10.
IEnumerable&lt;int&gt;  numbers         = new[]{1, 1, 3, 5, 8, 13};
IEnumerable&lt;int&gt;  sumsLessThan10  = numbers.Tokens (0,
		// accumulate: add the values together.
		// p=previous value, c=current value
		(p, c) =&gt; p + c,
		// resultSelector: return the current sum and reset count to 0.
		r =&gt; Tuple.Create (r, 0),
		// category: sum is less than 10.
		(p, c) =&gt; p + c &lt; 10
);
// Notice that the input value of 13 is missing, as it didn't match
// any category.
Assert.IsTrue (new[]{5, 5, 8}.SequenceEqual (sumsLessThan10));

// More "traditional" lexing, with categories as precedence rules
string expression = " function(value1+value2)  ";
IEnumerable&lt;string&gt; exprTokens = expression.Tokens ("",
		// accumulate: concatenate the characters together
		(p, c) =&gt; p + c,
		r =&gt; Tuple.Create (r, ""),
		// category: identifiers: [A-Za-z_][A-Za-z0-9_]*
		(p, c) =&gt; p.Length == 0
			? char.IsLetter (c) || c == '_'
			: char.IsLetterOrDigit (c) || c == '_',
		// category: arithmetic operators
		(p, c) =&gt; c == '+' || c == '-' || c == '*' || c == '/',
		// category: grouping
		(p, c) =&gt; c == '(' || c == ')'
);
// Notice that all whitespace has been removed
Assert.IsTrue (
		new[]{"function", "(", "value1", "+", "value2", ")"}
		.SequenceEqual (exprTokens));
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="categories" /> contains no elements.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />, <paramref name="accumulate" />,
          <paramref name="resultSelector" />, or
          <paramref name="categories" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ToList``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          to convert into a 
          <see cref="T:System.Collections.Generic.List{System.Collections.Generic.List{TSource}}" /></param>
            <summary>
          Creates a 
          <see cref="T:System.Collections.Generic.List{System.Collections.Generic.List{TSource}}" />
          with the same ordering and values as <paramref name="self" />.
        </summary>
            <returns>
          A 
          <see cref="T:System.Collections.Generic.List{System.Collections.Generic.List{TSource}}" />
          with the same ordering and values as <paramref name="self" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#ToList">int[][] a = new int[][]{
	new int[]{1, 2, 3},
	new int[]{4, 5, 6},
};
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; b = a;
List&lt;List&lt;int&gt;&gt; c = b.ToList ();
Assert.AreEqual (a.Length, c.Count);
Assert.AreEqual (a [0].Length, c [0].Count);
Assert.AreEqual (a [1].Length, c [1].Count);
Assert.AreEqual (a [0][0], c [0][0]);
Assert.AreEqual (a [0][1], c [0][1]);
Assert.AreEqual (a [0][2], c [0][2]);
Assert.AreEqual (a [1][0], c [1][0]);
Assert.AreEqual (a [1][1], c [1][1]);
Assert.AreEqual (a [1][2], c [1][2]);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ToReadOnlyDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
            <typeparam name="TKey">
          The type of the key returned by <paramref name="keySelector" />.
        </typeparam>
            <param name="self">
          An
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          to create a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          from.
        </param>
            <param name="keySelector">
          A <see cref="T:System.Func{TSource,TKey}" /> used to extract a key 
          from each element in <paramref name="self" />.
        </param>
            <summary>
          Creates a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TSource}" />
          from an
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          according to a specified key selector and value selector delegate.
        </summary>
            <returns>
          A
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TSource}" />
          which contains the key/value values from <paramref name="self" />.
        </returns>
            <remarks />
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" />, <paramref name="keySelector" />, or
            <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="keySelector" /> produces a key that is
            <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ToReadOnlyDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
            <typeparam name="TKey">
          The type of the key returned by <paramref name="keySelector" />.
        </typeparam>
            <typeparam name="TValue">
          The type of the value returned by <paramref name="valueSelector" />.
        </typeparam>
            <param name="self">
          An
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          to create a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          from.
        </param>
            <param name="keySelector">
          A <see cref="T:System.Func{TSource,TKey}" /> used to extract a key 
          from each element in <paramref name="self" />.
        </param>
            <param name="valueSelector">
          A <see cref="T:System.Func{TSource,TValue}" /> used to extract a 
          value from each element in <paramref name="self" />.
        </param>
            <summary>
          Creates a 
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          from an
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          according to a specified key selector and value selector delegate.
        </summary>
            <returns>
          A
          <see cref="T:Cadenza.Collections.ReadOnlyDictionary{TKey,TValue}" />
          which contains the key/value values from <paramref name="self" />.
        </returns>
            <remarks />
            <exception cref="T:System.ArgumentNullException">
                <para>
                    <paramref name="self" />, <paramref name="keySelector" />, or
            <paramref name="valueSelector" /> is <see langword="null" />.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="keySelector" /> produces a key that is
            <see langword="null" />.
          </para>
            </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ToTuple(System.Collections.IEnumerable)">
            <param name="self">
          A <see cref="T:System.Collections.IEnumerable" /> containing the
          values to insert into a Tuple.
        </param>
            <summary>
          Creates a <c>Tuple</c> from a sequence.
        </summary>
            <returns>
                <para>
            A <see cref="T:System.Object" />
            backed by a <c>Tuple</c> containing the values within the sequence 
            <paramref name="self" />.
          </para>
                <para>
            No specific tuple is returned, as it depends upon the number of
            elements within <paramref name="self" />, thus a cast is necessary
            to the appropriate <c>Tuple</c> type to use it as a Tuple.
          </para>
            </returns>
            <remarks>
                <para>
            Converts a sequence into a <c>Tuple</c>.  The specific tuple
            returned is dependent upon <paramref name="self" />.
            <paramref name="self" /> must have between 1 and 
            <see cref="P:Cadenza.Tuple.MaxValues" /> elements, inclusive,
            otherwise a <see cref="T:System.NotSupportedException" /> is
            thrown.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#ToTuple">IEnumerable&lt;object&gt; s = new object[]{1, '2', 3L, "4"};
object tl = s.ToTuple ();
Assert.AreEqual (typeof(Tuple&lt;int, char, long, string&gt;), tl.GetType());

var t = (Tuple&lt;int, char, long, string&gt;) tl;
Assert.AreEqual (1,   t.Item1);
Assert.AreEqual ('2', t.Item2);
Assert.AreEqual (3L,  t.Item3);
Assert.AreEqual ("4", t.Item4);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.NotSupportedException">
          The number of elements within <paramref name="self" /> exceeds
          <see cref="P:Cadenza.Tuple.MaxValues" />, and thus no tuple type
          exists to contain all the elements within <paramref name="self" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ToValueReader(System.Collections.Generic.IEnumerable{System.String})">
            <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          containing elements to read values from.
        </param>
            <summary>
          Creates a <see cref="T:Cadenza.IO.TextValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.IO.TextValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />.
        </returns>
            <remarks />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.ToValueReader``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing elements to read values from.
        </param>
            <summary>
          Creates a <see cref="T:Cadenza.IO.EnumerableValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.IO.EnumerableValueReader" />
          which will extract values from an 
          <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />.
        </returns>
            <remarks />
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.TrailingSegments``1(System.Collections.Generic.IEnumerable{``0})">
            <typeparam name="TSource">
          The type of element in the sequence <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{TSource}" />
          containing the sequence for which to return the trailing segments.
        </param>
            <summary>
          Creates a 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all final segments of <paramref name="self" />,
          longest first.
        </summary>
            <returns>
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing all final segments of <paramref name="self" />,
          longest first.
        </returns>
            <remarks>
                <para>
            A "final segment" is the list of <typeparamref name="TSource" />
            values following the "current" index, in which the current index
            starts at the start of <paramref name="self" /> and increments
            until the end of <paramref name="self" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#TrailingSegments">IEnumerable&lt;IEnumerable&lt;char&gt;&gt; e = "abc".TrailingSegments ();
var l = e.ToList ();
Assert.AreEqual (4, l.Count);
AssertAreSame (new[]{'a', 'b', 'c'},  l [0]);
AssertAreSame (new[]{'a', 'b'},       l [1]);
AssertAreSame (new[]{'a'},            l [2]);
AssertAreSame (new char[]{},          l [3]);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.InitialSegments``1(System.Collections.Generic.IEnumerable{``0})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Transpose``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <typeparam name="TSource">
          The type of element to return.
        </typeparam>
            <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />
          containing rows and columns to transpose.
        </param>
            <summary>
          Transposes <paramref name="self" />, so that rows become columns and
          columns become rows in the returned 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />.
        </summary>
            <returns>
          A 
          <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />,
          in which columns and rows are transposed.
        </returns>
            <remarks>
                <para>
            If each row has a different number of elements, then the returned 
            <see cref="T:System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{TSource}}" />.
            will have as many rows as the longest number of columns within
            <paramref name="self" />, and any rows with fewer than the
            maximum number of input columns are "skipped" when an input column
            index exceeds the length of that row.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Transpose">IEnumerable&lt;IEnumerable&lt;int&gt;&gt; a = new int[][]{
	new int[]{1, 2, 3},
	new int[]{4, 5, 6},
};
IEnumerable&lt;IEnumerable&lt;int&gt;&gt; b = a.Transpose ();
List&lt;List&lt;int&gt;&gt; c = b.ToList ();
Assert.AreEqual (3, c.Count);
Assert.AreEqual (2, c [0].Count);
Assert.AreEqual (2, c [1].Count);
Assert.AreEqual (2, c [2].Count);
Assert.AreEqual (1, c [0][0]);
Assert.AreEqual (4, c [0][1]);
Assert.AreEqual (2, c [1][0]);
Assert.AreEqual (5, c [1][1]);
Assert.AreEqual (3, c [2][0]);
Assert.AreEqual (6, c [2][1]);

// Test non-"rectangular" array
a = new int[][]{
	new int[]{1, 2},
	new int[]{3},
	new int[]{4, 5},
};
b = a.Transpose ();
Assert.AreEqual (2, b.Count ());
Assert.IsTrue (new[]{1, 3, 4}.SequenceEqual (b.ElementAt (0)));
Assert.IsTrue (new[]{2, 5}.SequenceEqual (b.ElementAt (1)));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},``0@)">
            <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
            <param name="self">
          An <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> 
          containing the sequence of elements to extract the first element from.
        </param>
            <param name="first">
          When this method returns, contains a <typeparamref name="TSource" /> 
          which contains either the first element within <paramref name="self" />
          (if the return value is <see langword="true" />), or will 
          contain <c>default(<typeparamref name="TSource" />)</c>.
        </param>
            <summary>Attempts to obtain the first element in the sequence.</summary>
            <returns>
                <see langword="true" /> if <paramref name="self" /> contains elements
          and <paramref name="first" /> contains the value of the first element; 
          otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <block subset="none" type="note">
            Use this method instead of 
            <see cref="M:System.Linq.Enumerable.FirstOrDefault`1(System.Collections.Generic.IEnumerable{``0})" />
            when one of the elements in the sequence may be 
            <c>default(<typeparamref name="TSource" />)</c>, thus making it 
            impossible to tell if 
            <c>default(<typeparamref name="TSource" />)</c>, was returned 
            because no matching element was found or because 
            <c>default(<typeparamref name="TSource" />)</c>, was the matching
            element).
          </block>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#TryGetFirst">var seq = new int[]{0, 1, 2};
int first;

Assert.IsTrue (seq.TryGetFirst (out first));
Assert.IsTrue (0 == first);

seq = new int[]{};
Assert.IsFalse (seq.TryGetFirst (out first));
Assert.IsTrue (0 == first);
</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},``0@)">
            <typeparam name="TSource">The type of the elements in <paramref name="self" />.</typeparam>
            <param name="self">
          An <see cref="T:System.Collections.Generic.IEnumerable{TSource}" /> 
          containing the sequence of elements to extract the first element from.
        </param>
            <param name="predicate">
          A <see cref="T:System.Func{TSource,System.Boolean}" /> which is tested
          against each element within <paramref name="self" />.
        </param>
            <param name="first">
          When this method returns, contains a <typeparamref name="TSource" /> 
          which contains either the first element for which 
          <paramref name="predicate" /> returned <see langword="true" />
          (if the return value is <see langword="true" />), or will 
          contain <c>default(<typeparamref name="TSource" />)</c>.
        </param>
            <summary>Attempts to obtain the first element in the sequence that satisfies the specified condition.</summary>
            <returns>
                <see langword="true" /> if <paramref name="self" /> contains elements
          and <paramref name="predicate" /> returned <see langword="true" />
          for one of those elements and <paramref name="first" /> contains
          the value of the first matching value; otherwise, <see langword="false" />.
        </returns>
            <remarks>
                <block subset="none" type="note">
            Use this method instead of 
            <see cref="M:System.Linq.Enumerable.FirstOrDefault`1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
            when one of the elements in the sequence may be 
            <c>default(<typeparamref name="TSource" />)</c>, thus making it 
            impossible to tell if 
            <c>default(<typeparamref name="TSource" />)</c>, was returned 
            because no matching element was found or because 
            <c>default(<typeparamref name="TSource" />)</c>, was the matching
            element).
          </block>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#TryGetFirst2">var seq = new int[]{0, 1, 2};
int first;

Assert.IsTrue (seq.TryGetFirst (v =&gt; v.IsOdd (), out first));
Assert.IsTrue (1 == first);

Assert.IsTrue (seq.TryGetFirst (v =&gt; v.IsEven (), out first));
Assert.IsTrue (0 == first);

Assert.IsFalse (seq.TryGetFirst (v =&gt; v == 5, out first));
Assert.IsTrue (0 == first);
</code>
            </remarks>
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Unzip``2(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1}})">
            <typeparam name="T1">
          The type of the first sequence to return.
        </typeparam>
            <typeparam name="T2">
          The type of the second sequence to return.
        </typeparam>
            <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          to split up into separate lists.
        </param>
            <summary>
          Converts an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          into a tuple of lists, one for each 
          <see cref="T:Cadenza.Tuple{T1,T2}" />
          element.
        </summary>
            <returns>
          An 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{T1},System.Collections.Generic.IEnumerable{T2}}" />
          containing the appropriate elements from each 
          <see cref="T:Cadenza.Tuple{T1,T2}" />.
        </returns>
            <remarks>
                <para>
            This is analogous to undoing a <c>Zip</c> operation.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Unzip2">Assert.AreEqual ("1,2|3,4",
		new[]{1,2}.Zip (new[]{3,4,5}).Unzip ()
		.Aggregate ((a, b) =&gt; a.Implode (",") + "|" + b.Implode (",")));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Unzip``3(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1,``2}})">
            <typeparam name="T1">
          The type of the first sequence to return.
        </typeparam>
            <typeparam name="T2">
          The type of the second sequence to return.
        </typeparam>
            <typeparam name="T3">
          The type of the third sequence to return.
        </typeparam>
            <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3}}" />
          to split up into separate lists.
        </param>
            <summary>
          Converts an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3}}" />
          into a tuple of lists, one for each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3}" />
          element.
        </summary>
            <returns>
          An 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{T1},System.Collections.Generic.IEnumerable{T2},System.Collections.Generic.IEnumerable{T3}}" />
          containing the appropriate elements from each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3}" />.
        </returns>
            <remarks>
                <para>
            This is analogous to undoing a <c>Zip</c> operation.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Unzip3">Assert.AreEqual ("1,2|3,4|5,6",
		new[]{1,2}.Zip (new[]{3,4,5}, new[]{5,6}).Unzip ()
		.Aggregate ((a, b, c) =&gt; a.Implode (",") + "|" + b.Implode (",") + "|" + c.Implode (",")));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Unzip``4(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1,``2,``3}})">
            <typeparam name="T1">
          The type of the first sequence to return.
        </typeparam>
            <typeparam name="T2">
          The type of the second sequence to return.
        </typeparam>
            <typeparam name="T3">
          The type of the third sequence to return.
        </typeparam>
            <typeparam name="T4">
          The type of the fourth sequence to return.
        </typeparam>
            <param name="self">
          A
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3,T4}}" />
          to split up into separate lists.
        </param>
            <summary>
          Converts an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3,T4}}" />
          into a tuple of lists, one for each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" />
          element.
        </summary>
            <returns>
          An 
          <see cref="T:Cadenza.Tuple{System.Collections.Generic.IEnumerable{T1},System.Collections.Generic.IEnumerable{T2},System.Collections.Generic.IEnumerable{T3},System.Collections.Generic.IEnumerable{T4}}" />
          containing the appropriate elements from each 
          <see cref="T:Cadenza.Tuple{T1,T2,T3,T4}" />.
        </returns>
            <remarks>
                <para>
            This is analogous to undoing a <c>Zip</c> operation.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Unzip4">Assert.AreEqual ("1,2|3,4|5,6|7,8",
		new[]{1,2}.Zip (new[]{3,4,5,6}, new[]{5,6,7}, new[]{7,8}).Unzip ()
		.Aggregate ((a, b, c, d) =&gt; a.Implode (",") + "|" + b.Implode (",") + "|" + c.Implode (",") + "|" + d.Implode (",")));
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
            <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
            <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
            <summary>
          Creates and returns an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" /> and <paramref name="source2" />.
        </summary>
            <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" /> and <paramref name="source2" />.
        </returns>
            <remarks>
                <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
            where each <see cref="T:Cadenza.Tuple{T1,T2}" /> contains an
            element from <paramref name="self" /> and <paramref name="source2" /> 
            with the same element index.
          </para>
                <para>
            The number of items in the list returned is equal to the shorter
            of <paramref name="self" /> and <paramref name="source2" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Zip2">Assert.AreEqual ("1,5|2,4|",
		new[]{1,2}.Zip (new[]{5,4,3})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1}|", e.Item1, e.Item2)).ToString ());
Assert.AreEqual ("",
		new int[]{}.Zip (new[]{5,4,3})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1}|", e.Item1, e.Item2)).ToString ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> or <paramref name="source2" /> 
          is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Unzip``2(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1}})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
            <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
            <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
            <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
            <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
            <summary>
          Creates and returns an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
        </summary>
            <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
        </returns>
            <remarks>
                <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
            where each <see cref="T:Cadenza.Tuple{T1,T2}" /> contains an
            element from each of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />
            with the same element index.
          </para>
                <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, and <paramref name="source3" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Zip3">Assert.AreEqual ("1,3,5|2,4,6|",
		new[]{1,2}.Zip (new[]{3,4,5,6}, new[]{5,6,7})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2}|", e.Item1, e.Item2, e.Item3)).ToString ());
Assert.AreEqual ("",
		new int[]{}.Zip (new[]{5,4,3}, new[]{1,2,3})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2}|", e.Item1, e.Item2, e.Item3)).ToString ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />, <paramref name="source2" />, or <paramref name="source3" /> 
          is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})" />
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Unzip``3(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1,``2}})" />
        </member>
        <member name="M:Cadenza.Collections.EnumerableCoda.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3})">
            <typeparam name="T1">
          The type of elements in the first list.
        </typeparam>
            <typeparam name="T2">
          The type of elements in the second list.
        </typeparam>
            <typeparam name="T3">
          The type of elements in the third list.
        </typeparam>
            <typeparam name="T4">
          The type of elements in the fourth list.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.IEnumerable{T1}" />
          containing elements from the first list.
        </param>
            <param name="source2">
          A <see cref="T:System.Collections.Generic.IEnumerable{T2}" />
          containing elements from the second list.
        </param>
            <param name="source3">
          A <see cref="T:System.Collections.Generic.IEnumerable{T3}" />
          containing elements from the third list.
        </param>
            <param name="source4">
          A <see cref="T:System.Collections.Generic.IEnumerable{T4}" />
          containing elements from the fourth list.
        </param>
            <summary>
          Creates and returns an 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2,T3,T4}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
        </summary>
            <returns>
          An 
          <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
          containing the corresponding items from 
          <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
        </returns>
            <remarks>
                <para>
            Returns an
            <see cref="T:System.Collections.Generic.IEnumerable{Cadenza.Tuple{T1,T2}}" />
            where each <see cref="T:Cadenza.Tuple{T1,T2}" /> contains an
            element from each of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />
            with the same element index.
          </para>
                <para>
            The number of items in the list returned is equal to the shorter of
            <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, and <paramref name="source4" />.
          </para>
                <code lang="C#" src="../../Test/Cadenza.Collections/EnumerableCodaTest.cs#Zip4">Assert.AreEqual ("1,3,5,7|2,4,6,8|",
		new[]{1,2}.Zip (new[]{3,4,5,6}, new[]{5,6,7}, new[]{7,8})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2},{3}|", e.Item1, e.Item2, e.Item3, e.Item4)).ToString ());
Assert.AreEqual ("",
		new int[]{}.Zip (new[]{3,4,5,6}, new[]{5,6,7}, new[]{7,8})
		.Aggregate (new StringBuilder(), 
			(b, e) =&gt; b.AppendFormat ("{0},{1},{2},{3}|", e.Item1, e.Item2, e.Item3, e.Item4)).ToString ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" />, <paramref name="source2" />, <paramref name="source3" />, or <paramref name="source4" />
          is <see langword="null" />.
        </exception>
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.SelectFromEach``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})" />
            <altmember cref="M:Cadenza.Collections.EnumerableCoda.Unzip``4(System.Collections.Generic.IEnumerable{Cadenza.Tuple{``0,``1,``2,``3}})" />
        </member>
        <member name="T:Cadenza.Collections.IMutableLookup`2">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TElement">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.IMutableLookup`2.Add(``10TKey`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEnumerable`1``10`1{``10TElement`1``10`1})">
            <param name="key">To be added.</param>
            <param name="elements">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.IMutableLookup`2.Add(``10TKey`1``10`1,``10TElement`1``10`1)">
            <param name="key">To be added.</param>
            <param name="element">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.IMutableLookup`2.Clear">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.IMutableLookup`2.Remove(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.IMutableLookup`2.Remove(``10TKey`1``10`1,``10TElement`1``10`1)">
            <param name="key">To be added.</param>
            <param name="element">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.KeyValuePairCoda">
            <summary>
      Extension methods for 
      <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.KeyValuePairCoda.Aggregate``3(System.Collections.Generic.KeyValuePair{``0,``1},System.Func{``0,``1,``2})">
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">Type type of the value.</typeparam>
            <typeparam name="TResult">The type to accumulator value.</typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />.
          instance to convert into a <typeparamref name="TResult" />.
        </param>
            <param name="func">
          A <see cref="T:System.Func{TKey,TValue,TResult}" /> which is invoked
          to convert the 
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />
          into a <typeparamref name="TResult" />.
        </param>
            <summary>
          Applies an accumulator to a 
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />,
          converting the 
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />
          into a different value.
        </summary>
            <returns>
          A <typeparamref name="TResult" />, which is the return value of
          <paramref name="func" />.
        </returns>
            <remarks>
                <para>
            This is useful primarily to avoid an unseemly temporary (or to
            more easily use 
            <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />s
            within expressions).
          </para>
                <code lang="C#">
var dict = new Dictionary&lt;int, int&gt; { 
    { 1, 1 },
    { 2, 4 },
    { 3, 9 },
};
string entries = dict
    .Select( 
        e =&gt; /* e is a KeyValuePair&lt;int,int&gt; */ 
            e.Aggregate( (k, v) =&gt; string.Format("({0},{1})", k, v) ) )
    .Implode("|");
// entries contains "(1,1)|(2,4)|(3,9)"
          </code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.KeyValuePairCoda.Aggregate``3(System.Collections.Generic.KeyValuePair{``0,``1},System.Func{``0,``1,``2})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.KeyValuePairCoda.ToTuple``2(System.Collections.Generic.KeyValuePair{``0,``1})">
            <typeparam name="TKey">The type of the key.</typeparam>
            <typeparam name="TValue">The type of the value.</typeparam>
            <param name="self">
          A 
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />.
          to convert into a
          <see cref="T:Cadenza.Tuple{TKey,TValue}" />.
        </param>
            <summary>
          Converts a 
          <see cref="T:System.Collections.Generic.KeyValuePair{TKey,TValue}" />
          into a
          <see cref="T:Cadenza.Tuple{TKey,TValue}" />.
        </summary>
            <returns>
          A <see cref="T:Cadenza.Tuple{TKey,TValue}" /> struct.
        </returns>
            <remarks>
                <para>
            The value of the returned <see cref="P:Cadenza.Tuple`2._1" />
            property is copied from 
            <see cref="P:System.Collections.Generic.KeyValuePair`2.Key" />
            and the value of the returned 
            <see cref="P:Cadenza.Tuple`2._2" />
            is copied from 
            <see cref="P:System.Collections.Generic.KeyValuePair`2.Value" />.
          </para>
                <code lang="C#">
KeyValuePair&lt;string, int&gt; kvp   = new KeyValuePair&lt;string, int&gt; ("s", 1);
Tuple&lt;string, int&gt;        tuple = kvp.ToTuple ();
    // tuple._1 == "s", tuple._2 == 1</code>
            </remarks>
            <altmember cref="M:Cadenza.TupleCoda.ToKeyValuePair``2(Cadenza.Tuple{``0,``1})" />
        </member>
        <member name="T:Cadenza.Collections.LambdaComparer`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.LambdaComparer`1(`0System`0.`0Func`0{`0T`0,`0T`0,`0System`0.`0Int32`0})">
            <param name="func">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.LambdaComparer`1.Compare(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.LinkedListCoda">
            <summary>
                <see cref="T:System.Collections.Generic.LinkedList{T}" /> extension methods.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.LinkedListCoda.NodeAt``1(System.Collections.Generic.LinkedList{``0},System.Int32)">
            <typeparam name="T">
          The type of the elements within <paramref name="self" />.
        </typeparam>
            <param name="self">
          A <see cref="T:System.Collections.Generic.LinkedList{T}" />
          to get a
          <see cref="T:System.Collections.Generic.LinkedListNode{T}" /> from.
        </param>
            <param name="index">
          A <see cref="T:System.Int32" /> containing the zero-based index of the
          <see cref="T:System.Collections.Generic.LinkedListNode{T}" /> to
          retrieve.
        </param>
            <summary>
          Returns the
          <see cref="T:System.Collections.Generic.LinkedListNode{T}" />
          at the specified <paramref name="index" /> of the
          <see cref="T:System.Collections.Generic.LinkedList{T}" />.
        </summary>
            <returns>
          The
          <see cref="T:System.Collections.Generic.LinkedListNode{T}" />
          at the specified <paramref name="index" /> of the
          <see cref="T:System.Collections.Generic.LinkedList{T}" />.
        </returns>
            <remarks>
                <code lang="C#" src="../../Test/Cadenza.Collections/LinkedListCodaTest.cs#NodeAt">LinkedList&lt;int&gt; list = new LinkedList&lt;int&gt;();
list.AddLast (1); // first node;  index=0
list.AddLast (2); // middle node; index=1
list.AddLast (3); // last node;   index=2

Assert.AreSame (list.First,         list.NodeAt (0));
Assert.AreSame (list.First.Next,    list.NodeAt (1));
Assert.AreSame (list.Last.Previous, list.NodeAt (1));
Assert.AreSame (list.Last,          list.NodeAt (2));
Assert.AreEqual (3, list.NodeAt (2).Value);
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <para>
                    <paramref name="index" /> is negative.
          </para>
                <para>-or-</para>
                <para>
                    <paramref name="index" /> is greater than or equal to
            <see cref="P:System.Collections.Generic.LinkedList{T}.Count" />.
          </para>
            </exception>
        </member>
        <member name="T:Cadenza.Collections.ListCoda">
            <summary>
                <see cref="T:System.Collections.Generic.IList{T}" /> extension methods.</summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Collections.ListCoda.BinarySearch``2(System.Collections.Generic.IList{``0},``1,System.Func{``0,``1,System.Int32})">
            <typeparam name="TSource">The type of elements in <paramref name="self" />.</typeparam>
            <typeparam name="TValue">The type of the item to search for.</typeparam>
            <param name="self">The list to be searched for a given <paramref name="item" /> (must be sorted).</param>
            <param name="item">The element for which to search. (<paramref name="item" /> can be <see langword="null" /> if <typeparamref name="TValue" /> is a reference type.)</param>
            <param name="comparer">The function to compare an item in the list with <paramref name="item" />, <see cref="M:System.Collections.Generic.IComparer{T}.Compare" />.</param>
            <summary>Searches the entire sorted list for an element using the specified comparer and returns the zero-based index of the element.</summary>
            <returns>The zero-based index of <paramref name="item" /> in the sorted list, if <paramref name="item" /> is found;
        otherwise, a negative number, which is the bitwise complement of the index of the next element that is larger than <paramref name="item" />
        or, if there is no larger element, the bitwise complement of <see cref="M:System.Collections.Generic.IList{T}.Count" />.</returns>
            <remarks>This is similar to <see cref="M:System.Collections.Generic.IList{T}.BinarySearch(T, System.Collections.Generic.IComparer{T})" />
        except the type of the item being sought does not have to match the type of the elements in the list.</remarks>
        </member>
        <member name="T:Cadenza.Collections.MutableLookup`2">
            <typeparam name="TKey">The lookup key.</typeparam>
            <typeparam name="TElement">The elements under each <typeparamref name="TKey" />.</typeparam>
            <summary>
            A mutable lookup implementing <see cref="T:System.Linq.ILookup{TKey,TElement}" /></summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.MutableLookup`2">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.MutableLookup`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1})">
            <param name="comparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.MutableLookup`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})" /></exception>
        </member>
        <member name="C:Cadenza.Collections.MutableLookup`2(``10System`1``10`1.``10Linq`1``10`1.``10ILookup`1``10`1{``10TKey`1``10`1,``10TElement`1``10`1})">
            <param name="lookup">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.Add(``10TKey`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEnumerable`1``10`1{``10TElement`1``10`1})">
            <param name="key">To be added.</param>
            <param name="elements">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.MutableLookup`2.Add(`0,System.Collections.Generic.IEnumerable{`1})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.Add(``10TKey`1``10`1,``10TElement`1``10`1)">
            <param name="key">The key to add <paramref name="element" /> under.</param>
            <param name="element">The element to add.</param>
            <summary>
            Adds <paramref name="element" /> under the specified <paramref name="key" />. <paramref name="key" /> does not need to exist.
            </summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.Clear">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.Contains(``10TKey`1``10`1)">
            <param name="key">The key to check for.</param>
            <summary>
            Gets whether or not there's a grouping for <paramref name="key" />.
            </summary>
            <returns>
                <c>true</c> if <paramref name="key" /> is present.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.MutableLookup`2.Count">
            <summary>
            Gets the number of groupings.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.MutableLookup`2.Item(``10TKey`1``10`1)">
            <param name="key">The key to get the elements for.</param>
            <summary>
            Gets the elements for <paramref name="key" />.
        </summary>
            <value>The elements under <paramref name="key" />.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.Remove(``10TKey`1``10`1)">
            <param name="key">They to remove.</param>
            <summary>
            Removes <paramref name="key" /> from the lookup.
            </summary>
            <returns>
                <c>true</c> if <paramref name="key" /> existed.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.Remove(``10TKey`1``10`1,``10TElement`1``10`1)">
            <param name="key">The key that <paramref name="element" /> is located under.</param>
            <param name="element">The element to remove from <paramref name="key" />. </param>
            <summary>
            Removes <paramref name="element" /> from the <paramref name="key" />.
            </summary>
            <returns>
                <c>true</c> if <paramref name="key" /> and <paramref name="element" /> existed, <c>false</c> if not.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.MutableLookup`2.TryGetValues(``10TKey`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEnumerable`1``10`1{``10TElement`1``10`1}@)">
            <param name="key">To be added.</param>
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.OrderedDictionary`2">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.OrderedDictionary`2">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.OrderedDictionary`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10ICollection`1``10`1{``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1}})">
            <param name="dictionary">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.OrderedDictionary`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1})">
            <param name="equalityComparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.OrderedDictionary`2(``10System`1``10`1.``10Int32`1``10`1)">
            <param name="capacity">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.OrderedDictionary`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10ICollection`1``10`1{``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1}},``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1})">
            <param name="dictionary">To be added.</param>
            <param name="equalityComparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.OrderedDictionary`2(``10System`1``10`1.``10Int32`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IEqualityComparer`1``10`1{``10TKey`1``10`1})">
            <param name="capacity">To be added.</param>
            <param name="equalityComparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.Add(``10TKey`1``10`1,``10TValue`1``10`1)">
            <param name="key">The key to associate with the <paramref name="value" />.</param>
            <param name="value">The value to add.</param>
            <summary>
            Adds the <paramref name="key" /> and <paramref name="value" /> to the dictionary.
            </summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentException">
                <paramref name="key" /> already exists in the dictionary.</exception>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.Clear">
            <summary>
            Clears the dictionary.
            </summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.Comparer">
            <summary>
            Gets the equality comparer being used for <typeparam name="TKey" />.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.ContainsKey(``10TKey`1``10`1)">
            <param name="key">The key to look for.</param>
            <summary>
            Gets whether or not <paramref name="key" /> is in the dictionary.
            </summary>
            <returns>
                <c>true</c> if the key was found, <c>false</c> if not.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.ContainsValue(``10TValue`1``10`1)">
            <param name="value">The value to look for.</param>
            <summary>
            Gets whether or not <paramref name="value" /> is in the dictionary.
            </summary>
            <returns>
                <c>true</c> if the value was found, <c>false</c> if not.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.Count">
            <summary>
            Gets the number of items in the dictionary.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.IndexOf(``10TKey`1``10`1)">
            <param name="key">The key to find the index of.</param>
            <summary>
            Gets the index of <paramref name="key" />.
            </summary>
            <returns>-1 if the key was not found, the index otherwise.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.IndexOf(``10TKey`1``10`1,``10System`1``10`1.``10Int32`1``10`1)">
            <param name="key">The key to find the index of.</param>
            <param name="startIndex">The index to start the search at.</param>
            <summary>
            Gets the index of <paramref name="key" /> starting with <paramref name="startIndex" />.
            </summary>
            <returns>-1 if the key was not found, the index otherwise.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="startIndex" /> is not within the valid range of indexes.</exception>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.IndexOf(``10TKey`1``10`1,``10System`1``10`1.``10Int32`1``10`1,``10System`1``10`1.``10Int32`1``10`1)">
            <param name="key">The key to find the index of.</param>
            <param name="startIndex">The index to start the search at.</param>
            <param name="count">How many items to search, including the <paramref name="startIndex" />.</param>
            <summary>
            	Gets the index of <paramref name="key" /> between the range given by <paramref name="startIndex" /> and <paramref name="count" />.
            </summary>
            <returns>-1 if the key was not found, the index otherwise.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="count" /> is less than 0.</exception>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.Insert(``10System`1``10`1.``10Int32`1``10`1,``10TKey`1``10`1,``10TValue`1``10`1)">
            <param name="index">The index to insert the key and value at.</param>
            <param name="key">The key to assicate with the <paramref name="value" />.</param>
            <param name="value">The value to insert.</param>
            <summary>
            Inserts the <paramref name="key" /> and <paramref name="value" /> at the specified index.
            </summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
                <paramref name="index" /> is less than 0 or greater than <see cref="P:Cadenza.Collections.OrderedDictionary{`0,`1}.Count" /></exception>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.Item(``10System`1``10`1.``10Int32`1``10`1)">
            <param name="index">The index to get the value at.</param>
            <summary>
            Gets the value at the specified index.
            </summary>
            <value>The value at the specified index.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.IndexOutOfRangeException">
                <paramref name="index" /> is less than 0 or greater than <see cref="P:Cadenza.Collections.OrderedDictionary{`0,`1}.Count" />.</exception>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.Item(``10TKey`1``10`1)">
            <param name="key">The key to get or set the value for.</param>
            <summary>
            Gets or sets the value associated with <paramref name="key" />.
            </summary>
            <value>The value associated with the key.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
                <paramref name="key" /> was not found attempting to get.</exception>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.Keys">
            <summary>
            Gets a read only collection of keys in the dictionary.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.Remove(``10TKey`1``10`1)">
            <param name="key">The key to remove.</param>
            <summary>
            Removes the key and associated value from the dictionary if found.
            </summary>
            <returns>
                <c>true</c> if the key was found, <c>false</c> if not.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.RemoveAt(``10System`1``10`1.``10Int32`1``10`1)">
            <param name="index">The index at which to remove an item.</param>
            <summary>
            Removes they key and associated value from the dictionary located at <paramref name="index" />.
            </summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Add(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Contains(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#CopyTo(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1}[],``10System`1``10`1.``10Int32`1``10`1)">
            <param name="array">To be added.</param>
            <param name="arrayIndex">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Remove(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#IList{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IndexOf(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#IList{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Insert(``10System`1``10`1.``10Int32`1``10`1,``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="index">To be added.</param>
            <param name="item">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.System#Collections#Generic#IList{System#Collections#Generic#KeyValuePair{TKey,TValue}}#Item(``10System`1``10`1.``10Int32`1``10`1)">
            <param name="index">To be added.</param>
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.OrderedDictionary`2.TryGetValue(``10TKey`1``10`1,``10TValue`1``10`1@)">
            <param name="key">The key to search for.</param>
            <param name="value">The value, if found.</param>
            <summary>
            Attempts to get the <paramref name="value" /> for the <paramref name="key" />.
            </summary>
            <returns>
                <c>true</c> if the key was found, <c>false</c> otherwise.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key" /> is <c>null</c>.</exception>
        </member>
        <member name="P:Cadenza.Collections.OrderedDictionary`2.Values">
            <summary>
            Gets a read only collection of values in the dictionary.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.QueueCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.QueueCoda.DequeueOrDefault``1(System.Collections.Generic.Queue{``0})">
            <typeparam name="T">To be added.</typeparam>
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.QueueCoda.DequeueOrDefault``1(System.Collections.Generic.Queue{``0})" /></exception>
        </member>
        <member name="M:Cadenza.Collections.QueueCoda.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)">
            <typeparam name="T">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="element">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.QueueCoda.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)" /></exception>
        </member>
        <member name="T:Cadenza.Collections.ReadOnlyDictionary`2">
            <typeparam name="TKey">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.ReadOnlyDictionary`2(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10IDictionary`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="dict">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.Add(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>
            Not supported.
            </summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">Always.</exception>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.Add(``10TKey`1``10`1,``10TValue`1``10`1)">
            <param name="key">To be added.</param>
            <param name="value">To be added.</param>
            <summary>
            Not supported.
            </summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">Always.</exception>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.Clear">
            <summary>
            Not supported.
            </summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">Always.</exception>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.Contains(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">The <c>KeyValuePair</c> to check for.</param>
            <summary>
            Gets whether <paramref name="item" /> is in the collection.
            </summary>
            <returns>
                <c>true</c> if <paramref name="item" /> exists.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.ContainsKey(``10TKey`1``10`1)">
            <param name="key">The key to check for.</param>
            <summary>
            Gets whether <paramref name="key" /> exists in the dictionary.
            </summary>
            <returns>
                <c>true</c> if the key was found, <c>false</c> otherwise.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is null.</exception>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.CopyTo(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1}[],``10System`1``10`1.``10Int32`1``10`1)">
            <param name="array">The array to copy the collection to.</param>
            <param name="arrayIndex">The offset in <paramref name="array" /> to start copying to.</param>
            <summary>
            Copies the collection to <paramref name="array" /> starting at <paramref name="arrayIndex" />.
            </summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.ReadOnlyDictionary`2.Count">
            <summary>
            Gets the size of the collection.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.ReadOnlyDictionary`2.Item(``10TKey`1``10`1)">
            <param name="key">The key to get the value for.</param>
            <summary>
            Gets the value associated with <paramref name="key" />.
            </summary>
            <value>The value of <paramref name="key" />.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="key" /> is <c>null</c>.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
                <paramref name="key" /> is not found.</exception>
        </member>
        <member name="P:Cadenza.Collections.ReadOnlyDictionary`2.Keys">
            <summary>
            Gets a collection of this dictionary's keys.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.Remove(``10System`1``10`1.``10Collections`1``10`1.``10Generic`1``10`1.``10KeyValuePair`1``10`1{``10TKey`1``10`1,``10TValue`1``10`1})">
            <param name="item">To be added.</param>
            <summary>
            Not supported.
            </summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">Always.</exception>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.Remove(``10TKey`1``10`1)">
            <param name="key">To be added.</param>
            <summary>
            Not supported.
            </summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">Always.</exception>
        </member>
        <member name="P:Cadenza.Collections.ReadOnlyDictionary`2.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{TKey,TValue}}#IsReadOnly">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Collections.ReadOnlyDictionary`2.TryGetValue(``10TKey`1``10`1,``10TValue`1``10`1@)">
            <param name="key">The key to attempt to get <paramref name="value" /> for.</param>
            <param name="value" />
            <summary>
            Attempts to get the <paramref name="value" /> for <paramref name="key" />.
            </summary>
            <returns />
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.ReadOnlyDictionary`2.Values">
            <summary>
            Gets a collection of the values in this dictionary.
            </summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Collections.SequenceComparison`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.SequenceComparison`1(`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0},`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0})">
            <param name="original">To be added.</param>
            <param name="update">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Collections.SequenceComparison`1(`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0},`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0},`0System`0.`0Collections`0.`0Generic`0.`0IEqualityComparer`0{`0T`0})">
            <param name="original">To be added.</param>
            <param name="update">To be added.</param>
            <param name="comparer">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Collections.SequenceComparison`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />, <see cref="M:Cadenza.Collections.SequenceComparison`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" /></exception>
        </member>
        <member name="P:Cadenza.Collections.SequenceComparison`1.Added">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.SequenceComparison`1.Comparer">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.SequenceComparison`1.Removed">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Collections.SequenceComparison`1.Stayed">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.ComponentModel.NotifyingProperty">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.ComponentModel.NotifyingProperty.Create``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{System.ComponentModel.PropertyChangedEventHandler})">
            <typeparam name="TValue">To be added.</typeparam>
            <param name="expression">To be added.</param>
            <param name="notifier">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.ComponentModel.NotifyingProperty.CreateDependent``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Func{System.ComponentModel.PropertyChangedEventHandler},System.Linq.Expressions.Expression{System.Func{System.Object}}[])">
            <typeparam name="TValue">To be added.</typeparam>
            <param name="property">To be added.</param>
            <param name="notifier">To be added.</param>
            <param name="dependents">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.ComponentModel.NotifyingProperty`1">
            <typeparam name="TValue">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.ComponentModel.NotifyingProperty`1(`0System`0.`0Linq`0.`0Expressions`0.`0Expression`0{`0System`0.`0Func`0{`0TValue`0}},`0System`0.`0Func`0{`0System`0.`0ComponentModel`0.`0PropertyChangedEventHandler`0})">
            <param name="propertyExpression">To be added.</param>
            <param name="notifier">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentException">To be added; from: <see cref="M:Cadenza.ComponentModel.NotifyingProperty`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0}},System.Func{System.ComponentModel.PropertyChangedEventHandler})" />, <see cref="M:Cadenza.ComponentModel.NotifyingProperty`1.#ctor(System.Linq.Expressions.Expression{System.Func{`0}},System.Func{System.ComponentModel.PropertyChangedEventHandler})" /></exception>
        </member>
        <member name="P:Cadenza.ComponentModel.NotifyingProperty`1.Value">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.EnumerableValueReader`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.IO.EnumerableValueReader`1(`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0})">
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.IO.EnumerableValueReader`1.#ctor(System.Collections.Generic.IEnumerable{`0})" /></exception>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToBoolean(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToByte(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToChar(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToDateTime(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToDecimal(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToDouble(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToInt16(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToInt32(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToInt64(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToSByte(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToSingle(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToString(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToUInt16(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToUInt32(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.EnumerableValueReader`1.ToUInt64(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.IValueReader">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Boolean@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Byte@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Char@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.DateTime@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Decimal@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Double@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Int16@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Int32@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Int64@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.SByte@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.Single@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.String@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.UInt16@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.UInt32@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueReader.Read(System.UInt64@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.IValueWriter">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Boolean)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Byte)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Char)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.DateTime)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Decimal)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Double)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Int16)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Int32)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Int64)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.SByte)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.Single)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.UInt16)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.UInt32)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.IValueWriter.Write(System.UInt64)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.StreamCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamCoda.WithSystemConverter(System.IO.Stream)">
            <param name="self">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.IO.StreamCoda.WriteTo(System.IO.Stream,System.IO.Stream)">
            <param name="self">To be added.</param>
            <param name="destination">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.IO.Check.Destination(System.Object)" /></exception>
        </member>
        <member name="T:Cadenza.IO.StreamConverter">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.IO.StreamConverter">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Dispose">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Dispose(System.Boolean)">
            <param name="disposing">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Boolean@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Byte@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Byte[])">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Value(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Char@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.DateTime@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Decimal@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Double@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Int16@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Int32@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Int64@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.SByte@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Single@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.String@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.UInt16@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.UInt32@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.UInt64@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Byte[],System.Int32,System.Int32)">
            <param name="value">To be added.</param>
            <param name="offset">To be added.</param>
            <param name="count">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Read(System.Int32,System.Text.Encoding,System.String@)">
            <param name="size">To be added.</param>
            <param name="encoding">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Boolean)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Byte)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Byte[])">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Value(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Char)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.DateTime)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Decimal)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Double)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Int16)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Int32)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Int64)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.SByte)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Single)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.UInt16)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.UInt32)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.UInt64)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverter.Write(System.Byte[],System.Int32,System.Int32)">
            <param name="value">To be added.</param>
            <param name="offset">To be added.</param>
            <param name="count">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.StreamConverterCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.StreamConverterCoda.Read``1(Cadenza.IO.StreamConverter,``0@)">
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Value(System.Object)" /></exception>
        </member>
        <member name="M:Cadenza.IO.StreamConverterCoda.Write``1(Cadenza.IO.StreamConverter,``0)">
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.Check.Self(System.Object)" />, <see cref="M:Cadenza.Check.Value(System.Object)" /></exception>
        </member>
        <member name="T:Cadenza.IO.TextReaderCoda">
            <summary>
      Extension methods for <see cref="T:System.IO.TextReader" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.IO.TextReaderCoda.Lines(System.IO.TextReader)">
            <param name="self">
          A <see cref="T:System.IO.TextReader" /> to read lines from.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all lines of text from <paramref name="self" /> 
          while <see cref="M:System.IO.TextReader.Close" />ing 
          <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all lines of text from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <para>
                    <paramref name="self" /> is disposed.  
          </para>
                <block subset="none" type="note">
            A "line of text" is the same as that used by 
            <see cref="M:System.IO.TextReader.ReadLine" />.
          </block>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:System.IO.TextReader.ReadLine" />
        </member>
        <member name="M:Cadenza.IO.TextReaderCoda.Lines(System.IO.TextReader,Cadenza.IO.TextReaderCodaOptions)">
            <param name="self">
          A <see cref="T:System.IO.TextReader" /> to read lines from.
        </param>
            <param name="options">
          A <see cref="T:Cadenza.IO.TextReaderCodaOptions" /> controlling
          method execution.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all lines of text from <paramref name="self" />
          while optionally <see cref="M:System.IO.TextReader.Close" />ing 
          <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all lines of text from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <para>
            If <paramref name="options" /> contains
            <see cref="F:Cadenza.IO.TextReaderCodaOptions.CloseReader" />,
            then <paramref name="self" /> will be 
            <see cref="M:System.IO.TextReader.Close" />ed once all lines have
            been returned; if 
            <see cref="F:Cadenza.IO.TextReaderCodaOptions.CloseReader" />
            is not specified, then the 
            <see cref="T:System.IO.TextReader" /> will not be disposed.
          </para>
                <block subset="none" type="note">
            A "line of text" is the same as that used by 
            <see cref="M:System.IO.TextReader.ReadLine" />.
          </block>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="options" /> has an unsupported value.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:System.IO.TextReader.ReadLine" />
        </member>
        <member name="M:Cadenza.IO.TextReaderCoda.Tokens(System.IO.TextReader,System.Func{System.Nullable{System.Char},System.Char,System.Boolean}[])">
            <param name="self">
          A <see cref="T:System.IO.TextReader" /> to extract tokens from.
        </param>
            <param name="categories">
          A
          <see cref="T:System.Func{System.Nullable{System.Char},System.Char,System.Boolean}" />
          array containing the different categories of characters that 
          determines what makes up a "token."  If the 
          <see cref="T:System.Nullable{System.Char}" /> parameter is 
          <see langword="null" />, then the <see cref="T:System.Char" /> is
          the first character within the token; otherwise, the
          <see cref="T:System.Nullable{System.Char}" /> parameter contains the
          character preceding the <see cref="T:System.Char" />.
          The delegate should return <see langword="true" /> if the
          <see cref="T:System.Char" /> is a supported character; otherwise,
          <see langword="false" /> should be returned.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />
          while optionally <see cref="M:System.IO.TextReader.Close" />ing 
          <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all tokens from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <para>
            If <paramref name="options" /> contains
            <see cref="F:Cadenza.IO.TextReaderCodaOptions.CloseReader" />,
            then <paramref name="self" /> will be 
            <see cref="M:System.IO.TextReader.Close" />ed once all lines have
            been returned.
          </para>
                <block subset="none" type="note">
                    <para>
              A "token" is determined by <paramref name="categories" />, and
              is any contiguous sequence of characters for which the
              same <paramref name="categories" /> index returns 
              <see langword="true" />, starting from the first delegate.  This
              allows a "some characters are more important than others"
              philosphy, allowing e.g. parenthesis to be returned separately
              from alphanumeric characters, even if no whitespace separates
              them.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza.IO/TextReaderCodaTest.cs#Tokens">var r = new MyStringReader ("(append 3.5 \"hello, world!\")");
var words = r.Tokens (
	(p, c) =&gt; char.IsLetterOrDigit (c) || c == '.',
	(p, c) =&gt; !char.IsWhiteSpace (c))
	.ToArray ();
Assert.IsTrue (r.WasDisposed);
Assert.IsTrue (
		new[]{"(", "append", "3.5", "\"", "hello", ",", "world", "!\")"}
		.SequenceEqual (words));

r = new MyStringReader ("Hello, world!");
Assert.AreEqual (false, 
	r.Tokens (TextReaderCodaOptions.None,
		(p, c) =&gt; false).Any ());
Assert.IsFalse (r.WasDisposed);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="categories" /> is empty.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />, or
          <paramref name="categories" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.IO.TextReaderCoda.Tokens(System.IO.TextReader,Cadenza.IO.TextReaderCodaOptions,System.Func{System.Nullable{System.Char},System.Char,System.Boolean}[])">
            <param name="self">
          A <see cref="T:System.IO.TextReader" /> to extract tokens from.
        </param>
            <param name="options">
          A <see cref="T:Cadenza.IO.TextReaderCodaOptions" /> controlling
          method execution.
        </param>
            <param name="categories">
          A
          <see cref="T:System.Func{System.Nullable{System.Char},System.Char,System.Boolean}" />
          array containing the different categories of characters that 
          determines what makes up a "token."  If the 
          <see cref="T:System.Nullable{System.Char}" /> parameter is 
          <see langword="null" />, then the <see cref="T:System.Char" /> is
          the first character within the token; otherwise, the
          <see cref="T:System.Nullable{System.Char}" /> parameter contains the
          character preceding the <see cref="T:System.Char" />.
          The delegate should return <see langword="true" /> if the
          <see cref="T:System.Char" /> is a supported character; otherwise,
          <see langword="false" /> should be returned.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />
          while optionally <see cref="M:System.IO.TextReader.Close" />ing 
          <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all tokens from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <para>
            If <paramref name="options" /> contains
            <see cref="F:Cadenza.IO.TextReaderCodaOptions.CloseReader" />,
            then <paramref name="self" /> will be 
            <see cref="M:System.IO.TextReader.Close" />ed once all lines have
            been returned.
          </para>
                <block subset="none" type="note">
                    <para>
              A "token" is determined by <paramref name="categories" />, and
              is any contiguous sequence of characters for which the
              same <paramref name="categories" /> index returns 
              <see langword="true" />, starting from the first delegate.  This
              allows a "some characters are more important than others"
              philosphy, allowing e.g. parenthesis to be returned separately
              from alphanumeric characters, even if no whitespace separates
              them.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza.IO/TextReaderCodaTest.cs#Tokens">var r = new MyStringReader ("(append 3.5 \"hello, world!\")");
var words = r.Tokens (
	(p, c) =&gt; char.IsLetterOrDigit (c) || c == '.',
	(p, c) =&gt; !char.IsWhiteSpace (c))
	.ToArray ();
Assert.IsTrue (r.WasDisposed);
Assert.IsTrue (
		new[]{"(", "append", "3.5", "\"", "hello", ",", "world", "!\")"}
		.SequenceEqual (words));

r = new MyStringReader ("Hello, world!");
Assert.AreEqual (false, 
	r.Tokens (TextReaderCodaOptions.None,
		(p, c) =&gt; false).Any ());
Assert.IsFalse (r.WasDisposed);
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="options" /> contains an invalid value, or
          <paramref name="categories" /> is empty.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />, or
          <paramref name="categories" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.IO.TextReaderCoda.Words(System.IO.TextReader)">
            <param name="self">
          A <see cref="T:System.IO.TextReader" /> to extract words from.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />
          while <see cref="M:System.IO.TextReader.Close" />ing 
          <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <para>
                    <paramref name="self" /> is disposed.  
          </para>
                <block subset="none" type="note">
                    <para>
              A "word" is any contiguous sequence of characters for which
              <see cref="M:System.Char.IsWhiteSpace(System.Char)" />
              returns <see langword="false" />.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza.IO/TextReaderCodaTest.cs#Words">MyStringReader r = new MyStringReader ("   (skip  leading,\r\n\tand trailing\vwhitespace)   ");
string[] words = r.Words ().ToArray ();
Assert.IsTrue (r.WasDisposed);
Assert.AreEqual (5, words.Length);
Assert.AreEqual ("(skip",       words [0]);
Assert.AreEqual ("leading,",    words [1]);
Assert.AreEqual ("and",         words [2]);
Assert.AreEqual ("trailing",    words [3]);
Assert.AreEqual ("whitespace)", words [4]);

r = new MyStringReader ("notext");
words = r.Words (TextReaderCodaOptions.None).ToArray ();
Assert.IsFalse (r.WasDisposed);
Assert.AreEqual (1, words.Length);
Assert.AreEqual ("notext", words [0]);

r = new MyStringReader ("1 2 3 4");
Assert.AreEqual ("1", r.Words ().First ());
Assert.AreEqual ("2", r.Words ().First ());
Assert.AreEqual ("3", r.Words ().First ());
Assert.AreEqual ("4", r.Words ().First ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />, or
          <paramref name="categories" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
        </member>
        <member name="M:Cadenza.IO.TextReaderCoda.Words(System.IO.TextReader,Cadenza.IO.TextReaderCodaOptions)">
            <param name="self">
          A <see cref="T:System.IO.TextReader" /> to extract words from.
        </param>
            <param name="options">
          A <see cref="T:Cadenza.IO.TextReaderCodaOptions" /> controlling
          method execution.
        </param>
            <summary>
          Creates an
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />
          while optionally <see cref="M:System.IO.TextReader.Close" />ing 
          <paramref name="self" />.
        </summary>
            <returns>
          An
          <see cref="T:System.Collections.Generic.IEnumerable{System.String}" />
          which will return all words from <paramref name="self" />.
        </returns>
            <remarks>
                <para>
            This method is implemented by using deferred execution.
          </para>
                <para>
            If <paramref name="options" /> contains
            <see cref="F:Cadenza.IO.TextReaderCodaOptions.CloseReader" />,
            then <paramref name="self" /> will be 
            <see cref="M:System.IO.TextReader.Close" />ed once all lines have
            been returned; if 
            <see cref="F:Cadenza.IO.TextReaderCodaOptions.CloseReader" />
            is not specified, then the 
            <see cref="T:System.IO.TextReader" /> will not be disposed.
          </para>
                <block subset="none" type="note">
                    <para>
              A "word" is any contiguous sequence of characters for which
              <see cref="M:System.Char.IsWhiteSpace(System.Char)" />
              returns <see langword="false" />.
            </para>
                </block>
                <code lang="C#" src="../../Test/Cadenza.IO/TextReaderCodaTest.cs#Words">MyStringReader r = new MyStringReader ("   (skip  leading,\r\n\tand trailing\vwhitespace)   ");
string[] words = r.Words ().ToArray ();
Assert.IsTrue (r.WasDisposed);
Assert.AreEqual (5, words.Length);
Assert.AreEqual ("(skip",       words [0]);
Assert.AreEqual ("leading,",    words [1]);
Assert.AreEqual ("and",         words [2]);
Assert.AreEqual ("trailing",    words [3]);
Assert.AreEqual ("whitespace)", words [4]);

r = new MyStringReader ("notext");
words = r.Words (TextReaderCodaOptions.None).ToArray ();
Assert.IsFalse (r.WasDisposed);
Assert.AreEqual (1, words.Length);
Assert.AreEqual ("notext", words [0]);

r = new MyStringReader ("1 2 3 4");
Assert.AreEqual ("1", r.Words ().First ());
Assert.AreEqual ("2", r.Words ().First ());
Assert.AreEqual ("3", r.Words ().First ());
Assert.AreEqual ("4", r.Words ().First ());
</code>
            </remarks>
            <exception cref="T:System.ArgumentException">
                <paramref name="options" /> contains an invalid value.
        </exception>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
            <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
        </member>
        <member name="T:Cadenza.IO.TextReaderCodaOptions">
            <summary>
      Options to control <see cref="T:Cadenza.IO.TextReaderCoda" /> 
      method behavior.
    </summary>
            <remarks>
                <para>
        This enumeration is used to control the behavior of 
        <see cref="M:Cadenza.IO.TextReaderCoda.Lines(System.IO.TextReader,Cadenza.IO.TextReaderCodaOptions)" />
        and
        <see cref="M:Cadenza.IO.TextReaderCoda.Words(System.IO.TextReader,Cadenza.IO.TextReaderCodaOptions)" />
        behavior.
      </para>
            </remarks>
        </member>
        <member name="F:Cadenza.IO.TextReaderCodaOptions.CloseReader">
            <summary>
                <para>
            If specified, the <see cref="T:System.IO.TextReader" /> should be 
            <see cref="M:System.IO.TextReader.Close" />ed once all lines or
            words have been read from the TextReader.
          </para>
                <para>
            This may simplify resource disposal.
          </para>
                <para>
            If not specified, then the <see cref="T:System.IO.TextReader" />
            will not be <see cref="M:System.IO.TextReader.Close" />ed.
          </para>
            </summary>
        </member>
        <member name="F:Cadenza.IO.TextReaderCodaOptions.None">
            <summary>
                <para>
            No options specified.
          </para>
            </summary>
        </member>
        <member name="T:Cadenza.IO.TextValueReader">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.IO.TextValueReader(System.Collections.Generic.IEnumerable{System.String})">
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
            <exception cref="T:System.ArgumentNullException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.#ctor(System.Collections.Generic.IEnumerable{System.String})" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Byte@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.DateTime@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Decimal@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Double@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Int16@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Int32@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Int64@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.SByte@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.Single@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.UInt16@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.UInt32@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.Read(System.IFormatProvider,System.UInt64@)">
            <param name="provider">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.InvalidOperationException">To be added; from: <see cref="M:Cadenza.IO.TextValueReader.Word" /></exception>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToBoolean(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToByte(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToChar(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToDateTime(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToDecimal(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToDouble(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToInt16(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToInt32(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToInt64(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToSByte(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToSingle(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToString(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToUInt16(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToUInt32(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.TextValueReader.ToUInt64(System.String)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.ValueReader`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.IO.ValueReader`1(`0System`0.`0Collections`0.`0Generic`0.`0IEnumerable`0{`0T`0})">
            <param name="values">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Dispose">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Dispose(`0System`0.`0Boolean`0)">
            <param name="disposing">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.GetNextItem">
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Boolean`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Byte`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Char`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0DateTime`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Decimal`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Double`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Int16`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Int32`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Int64`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0SByte`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0Single`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0String`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0UInt16`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0UInt32`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.Read(`0System`0.`0UInt64`0@)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToBoolean(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToByte(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToChar(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToDateTime(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToDecimal(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToDouble(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToInt16(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToInt32(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToInt64(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToSByte(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToSingle(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToString(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToUInt16(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToUInt32(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReader`1.ToUInt64(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.IO.ValueReaderCoda">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.IO.ValueReaderCoda.Read``2(Cadenza.IO.ValueReader{``0},``1@)">
            <typeparam name="TSource">To be added.</typeparam>
            <typeparam name="TValue">To be added.</typeparam>
            <param name="self">To be added.</param>
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="T:Cadenza.Numerics.Math`1">
            <typeparam name="T">To be added.</typeparam>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="C:Cadenza.Numerics.Math`1">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Abs(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Abs(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Acos(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Add(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Add(`0,`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Asin(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Atan(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Atan2(`0T`0,`0T`0)">
            <param name="y">To be added.</param>
            <param name="x">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Atan2(`0,`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Ceiling(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Ceiling(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Compare(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Cos(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Cosh(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.Default">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">
          A <see cref="T:Cadenza.Numerics.Math{T}" /> implementation could not
          be found for <typeparam name="T" />.
        </exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Divide(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.DivideIntegral(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.DivideIntegralModulus(`0T`0,`0T`0,`0T`0@)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <param name="modulus">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.E">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.EnumerateFrom(`0T`0)">
            <param name="start">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.EnumerateFromThen(`0T`0,`0T`0)">
            <param name="first">To be added.</param>
            <param name="start">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.EnumerateFromThenTo(`0T`0,`0T`0,`0T`0)">
            <param name="first">To be added.</param>
            <param name="start">To be added.</param>
            <param name="end">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.EnumerateFromTo(`0T`0,`0T`0)">
            <param name="start">To be added.</param>
            <param name="end">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Equals(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Exp(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.Features">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.FloatDigits">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.get_FloatDigits" /></exception>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.FloatRadix">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.get_FloatRadix" /></exception>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.FloatRange">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.get_FloatRange" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Floor(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Floor(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.FromIConvertible(`0System`0.`0IConvertible`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.FromIConvertible(System.IConvertible)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.FromInt32(`0System`0.`0Int32`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.GetHashCode(`0T`0)">
            <param name="obj">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.GreaterThan(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.GreaterThanOrEqual(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.HasBounds">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.IEEERemainder(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.IEEERemainder(`0,`0)" /></exception>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.IsFloatingPoint">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.IsFractional">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.IsIEEE(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.IsIEEE(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.IsInfinite(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.IsInfinite(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.IsNaN(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.IsNaN(`0)" /></exception>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.IsTwosComplement">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.IsUnsigned">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.LessThan(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.LessThanOrEqual(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Log(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Log(`0T`0,`0T`0)">
            <param name="value">To be added.</param>
            <param name="newBase">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Max(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.MaxValue">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Min(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.MinValue">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Modulus(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Multiply(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Multiply(`0,`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Negate(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Negate(`0)" /></exception>
        </member>
        <member name="P:Cadenza.Numerics.Math`1.Pi">
            <summary>To be added.</summary>
            <value>To be added.</value>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Pow(`0T`0,`0T`0)">
            <param name="value">To be added.</param>
            <param name="exp">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Predecessor(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Quotient(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.QuotientRemainder(`0T`0,`0T`0,`0T`0@)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <param name="remainder">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Reciprocal(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Remainder(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Round(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Round(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.SetDefault(`0Cadenza`0.`0Numerics`0.`0Math`0{`0T`0})">
            <param name="provider">To be added.</param>
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Sign(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Sin(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Sinh(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Sqrt(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Subtract(`0T`0,`0T`0)">
            <param name="x">To be added.</param>
            <param name="y">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Subtract(`0,`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Successor(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Tan(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Tanh(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.ToIConvertible(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.ToIConvertible(`0)" /></exception>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.ToInt32(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
        </member>
        <member name="M:Cadenza.Numerics.Math`1.Truncate(`0T`0)">
            <param name="value">To be added.</param>
            <summary>To be added.</summary>
            <returns>To be added.</returns>
            <remarks>To be added.</remarks>
            <exception cref="T:System.NotSupportedException">To be added; from: <see cref="M:Cadenza.Numerics.Math`1.Truncate(`0)" /></exception>
        </member>
        <member name="T:Cadenza.Numerics.MathFeatures">
            <summary>To be added.</summary>
            <remarks>To be added.</remarks>
        </member>
        <member name="F:Cadenza.Numerics.MathFeatures.Bounded">
            <summary>To be added.</summary>
        </member>
        <member name="F:Cadenza.Numerics.MathFeatures.FloatingPoint">
            <summary>To be added.</summary>
        </member>
        <member name="F:Cadenza.Numerics.MathFeatures.Fractional">
            <summary>To be added.</summary>
        </member>
        <member name="F:Cadenza.Numerics.MathFeatures.None">
            <summary>To be added.</summary>
        </member>
        <member name="F:Cadenza.Numerics.MathFeatures.TwosComplement">
            <summary>To be added.</summary>
        </member>
        <member name="F:Cadenza.Numerics.MathFeatures.Unsigned">
            <summary>To be added.</summary>
        </member>
        <member name="T:Cadenza.Reflection.CustomAttributeProviderCoda">
            <summary>
      Extension methods for 
      <see cref="T:System.Reflection.ICustomAttributeProvider" />.
    </summary>
            <remarks />
        </member>
        <member name="M:Cadenza.Reflection.CustomAttributeProviderCoda.GetCustomAttribute``1(System.Reflection.ICustomAttributeProvider)">
            <typeparam name="TAttribute">The type of the custom attribute to return.</typeparam>
            <param name="self">
          A <see cref="T:System.Reflection.ICustomAttributeProvider" />
          from which to retrieve a custom attribute of type 
          <typeparamref name="TAttribute" />.
        </param>
            <summary>
          Retrieves a custom attribute of type 
          <typeparamref name="TAttribute" />.
        </summary>
            <returns>
          Returns the first custom attribute of type 
          <typeparamref name="TAttribute" /> or <see langword="null" /> if
          no type parameters of type <typeparamref name="TAttribute" /> are
          available.
        </returns>
            <remarks>
                <code lang="C#">
FooAttribute foo = typeof (Bar).GetCustomAttribute&lt;FooAttribute&gt; ();</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
        <member name="M:Cadenza.Reflection.CustomAttributeProviderCoda.GetCustomAttributes``1(System.Reflection.ICustomAttributeProvider)">
            <typeparam name="TAttribute">The type of the custom attribute to return.</typeparam>
            <param name="self">
          A <see cref="T:System.Reflection.ICustomAttributeProvider" />
          from which to retrieve custom attributes of type 
          <typeparamref name="TAttribute" />.
        </param>
            <summary>
          Retrieves all custom attributes of type 
          <typeparamref name="TAttribute" />.
        </summary>
            <returns>
          Returns all custom attributes of type 
          <typeparamref name="TAttribute" /> or an empty array if 
          no type parameters of type <typeparamref name="TAttribute" /> are
          available.
        </returns>
            <remarks>
                <code lang="C#">
var attributes = typeof (Bar).GetCustomAttributes&lt;FooAttribute&gt; ();</code>
            </remarks>
            <exception cref="T:System.ArgumentNullException">
                <paramref name="self" /> is <see langword="null" />.
        </exception>
        </member>
    </members>
</doc>
